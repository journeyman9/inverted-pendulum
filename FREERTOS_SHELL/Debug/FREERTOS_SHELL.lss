
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004af8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e0  00802000  00004af8  00004b8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000218d  008020e0  008020e0  00004c6c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004c6c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004c9c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000718  00000000  00000000  00004ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000110a1  00000000  00000000  000053f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000063e3  00000000  00000000  00016499  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004c7c  00000000  00000000  0001c87c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000153c  00000000  00000000  000214f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005ae6  00000000  00000000  00022a34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000066e1  00000000  00000000  0002851a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000608  00000000  00000000  0002ebfb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f0 02 	jmp	0x5e0	; 0x5e0 <__ctors_end>
       4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
       c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      10:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      14:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      18:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      1c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      20:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      24:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      28:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      2c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      30:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      34:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      38:	0c 94 e1 1e 	jmp	0x3dc2	; 0x3dc2 <__vector_14>
      3c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      40:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      44:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      48:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      4c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      50:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      54:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      58:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      5c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      60:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      64:	0c 94 50 19 	jmp	0x32a0	; 0x32a0 <__vector_25>
      68:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      6c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      70:	0c 94 a8 19 	jmp	0x3350	; 0x3350 <__vector_28>
      74:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      78:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      7c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      80:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      84:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      88:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      8c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      90:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      94:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      98:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      9c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      dc:	0c 94 f0 08 	jmp	0x11e0	; 0x11e0 <__vector_55>
      e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      e8:	0c 94 b0 1a 	jmp	0x3560	; 0x3560 <__vector_58>
      ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
      fc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     100:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     104:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     108:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     10c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     110:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     114:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     118:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     11c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     120:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     124:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     128:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     12c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     130:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     134:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     138:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     13c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     140:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     144:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     148:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     14c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     150:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     154:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     158:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     15c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     160:	0c 94 00 1a 	jmp	0x3400	; 0x3400 <__vector_88>
     164:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     168:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     16c:	0c 94 58 1a 	jmp	0x34b0	; 0x34b0 <__vector_91>
     170:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     174:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     178:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     17c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     180:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     184:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     188:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     18c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     190:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     194:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     198:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     19c:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1a8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ac:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1b8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1bc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1c8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1cc:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1d8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1dc:	0c 94 08 1b 	jmp	0x3610	; 0x3610 <__vector_119>
     1e0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1e8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1ec:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f0:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f4:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1f8:	0c 94 21 03 	jmp	0x642	; 0x642 <__bad_interrupt>
     1fc:	2b 17       	cp	r18, r27
     1fe:	2e 17       	cp	r18, r30
     200:	31 17       	cp	r19, r17
     202:	34 17       	cp	r19, r20
     204:	37 17       	cp	r19, r23
     206:	3a 17       	cp	r19, r26
     208:	3c 17       	cp	r19, r28
     20a:	4d 17       	cp	r20, r29
     20c:	55 17       	cp	r21, r21
     20e:	5f 17       	cp	r21, r31
     210:	5d 17       	cp	r21, r29
     212:	05 a8       	ldd	r0, Z+53	; 0x35
     214:	4c cd       	rjmp	.-1384   	; 0xfffffcae <__eeprom_end+0xff7efcae>
     216:	b2 d4       	rcall	.+2404   	; 0xb7c <_ZN9task_user3runEv+0x1e8>
     218:	4e b9       	out	0x0e, r20	; 14
     21a:	38 36       	cpi	r19, 0x68	; 104
     21c:	a9 02       	muls	r26, r25
     21e:	0c 50       	subi	r16, 0x0C	; 12
     220:	b9 91       	ld	r27, Y+
     222:	86 88       	ldd	r8, Z+22	; 0x16
     224:	08 3c       	cpi	r16, 0xC8	; 200
     226:	a6 aa       	std	Z+54, r10	; 0x36
     228:	aa 2a       	or	r10, r26
     22a:	be 00       	.word	0x00be	; ????
     22c:	00 00       	nop
     22e:	80 3f       	cpi	r24, 0xF0	; 240

00000230 <__trampolines_start>:
     230:	0c 94 45 1c 	jmp	0x388a	; 0x388a <_ZN9frt_queueIiE3getEPi>
     234:	0c 94 67 14 	jmp	0x28ce	; 0x28ce <_ZN14frt_text_queue14check_for_charEv>
     238:	0c 94 42 1d 	jmp	0x3a84	; 0x3a84 <_ZN9frt_queueIiE7butt_inERKi>
     23c:	0c 94 d6 16 	jmp	0x2dac	; 0x2dac <_ZN8emstream12clear_screenEv>
     240:	0c 94 be 1c 	jmp	0x397c	; 0x397c <_ZN9frt_queueIjE11ISR_butt_inERKj>
     244:	0c 94 d3 16 	jmp	0x2da6	; 0x2da6 <_ZN8emstream14check_for_charEv>
     248:	0c 94 aa 1b 	jmp	0x3754	; 0x3754 <_ZN9frt_queueIjE8is_emptyEv>
     24c:	0c 94 4d 17 	jmp	0x2e9a	; 0x2e9a <_ZN8emstreamlsE15ser_manipulator+0x62>
     250:	0c 94 8e 1b 	jmp	0x371c	; 0x371c <_ZN9frt_queueIiE12ISR_is_emptyEv>
     254:	0c 94 37 17 	jmp	0x2e6e	; 0x2e6e <_ZN8emstreamlsE15ser_manipulator+0x36>
     258:	0c 94 7d 1c 	jmp	0x38fa	; 0x38fa <_ZN9frt_queueIjE7ISR_getEv>
     25c:	0c 94 d0 1b 	jmp	0x37a0	; 0x37a0 <_ZN9frt_queueIjE10get_a_copyERj>
     260:	0c 94 31 17 	jmp	0x2e62	; 0x2e62 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     264:	0c 94 06 1d 	jmp	0x3a0c	; 0x3a0c <_ZN9frt_queueIiE7ISR_putERKi>
     268:	0c 94 c6 1b 	jmp	0x378c	; 0x378c <_ZN9frt_queueIiE8is_emptyEv>
     26c:	0c 94 98 1b 	jmp	0x3730	; 0x3730 <_ZN9frt_queueIjE12num_items_inEv>
     270:	0c 94 a3 18 	jmp	0x3146	; 0x3146 <_ZN5rs23214check_for_charEv>
     274:	0c 94 bb 1b 	jmp	0x3776	; 0x3776 <_ZN9frt_queueIiE9not_emptyEv>
     278:	0c 94 9f 1b 	jmp	0x373e	; 0x373e <_ZN9frt_queueIjE9not_emptyEv>
     27c:	0c 94 d0 0b 	jmp	0x17a0	; 0x17a0 <prvIdleTask>
     280:	0c 94 54 1d 	jmp	0x3aa8	; 0x3aa8 <_ZN9frt_queueIiE3putERKi>
     284:	0c 94 d5 16 	jmp	0x2daa	; 0x2daa <_ZN8emstream12transmit_nowEv>
     288:	0c 94 23 03 	jmp	0x646	; 0x646 <_ZN8task_LED3runEv>
     28c:	0c 94 2e 17 	jmp	0x2e5c	; 0x2e5c <_ZN8emstreamlsE15ser_manipulator+0x24>
     290:	0c 94 6b 21 	jmp	0x42d6	; 0x42d6 <_GLOBAL__sub_I_counter>
     294:	0c 94 ed 02 	jmp	0x5da	; 0x5da <_call_static_run_method>
     298:	0c 94 72 14 	jmp	0x28e4	; 0x28e4 <_ZN14frt_text_queue7putcharEc>
     29c:	0c 94 2b 17 	jmp	0x2e56	; 0x2e56 <_ZN8emstreamlsE15ser_manipulator+0x1e>
     2a0:	0c 94 5f 17 	jmp	0x2ebe	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
     2a4:	0c 94 dc 1b 	jmp	0x37b8	; 0x37b8 <_ZN9frt_queueIjE10get_a_copyEv>
     2a8:	0c 94 34 17 	jmp	0x2e68	; 0x2e68 <_ZN8emstreamlsE15ser_manipulator+0x30>
     2ac:	0c 94 67 1b 	jmp	0x36ce	; 0x36ce <_ZN9frt_queueIjE13ISR_not_emptyEv>
     2b0:	0c 94 5d 17 	jmp	0x2eba	; 0x2eba <_ZN8emstreamlsE15ser_manipulator+0x82>
     2b4:	0c 94 ee 1c 	jmp	0x39dc	; 0x39dc <_ZN9frt_queueIiE11ISR_butt_inERKi>
     2b8:	0c 94 ca 04 	jmp	0x994	; 0x994 <_ZN9task_user3runEv>
     2bc:	0c 94 3c 17 	jmp	0x2e78	; 0x2e78 <_ZN8emstreamlsE15ser_manipulator+0x40>
     2c0:	0c 94 7c 1b 	jmp	0x36f8	; 0x36f8 <_ZN9frt_queueIiE16ISR_num_items_inEv>
     2c4:	0c 94 d6 1c 	jmp	0x39ac	; 0x39ac <_ZN9frt_queueIjE7ISR_putERKj>
     2c8:	0c 94 3a 17 	jmp	0x2e74	; 0x2e74 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     2cc:	0c 94 6c 1c 	jmp	0x38d8	; 0x38d8 <_ZN9frt_queueIjE7ISR_getEPj>
     2d0:	0c 94 59 18 	jmp	0x30b2	; 0x30b2 <_ZN5rs2327putcharEc>
     2d4:	0c 94 30 1d 	jmp	0x3a60	; 0x3a60 <_ZN9frt_queueIjE3putERKj>
     2d8:	0c 94 ce 16 	jmp	0x2d9c	; 0x2d9c <_ZN8emstream13ready_to_sendEv>
     2dc:	0c 94 83 1b 	jmp	0x3706	; 0x3706 <_ZN9frt_queueIiE13ISR_not_emptyEv>
     2e0:	0c 94 95 1c 	jmp	0x392a	; 0x392a <_ZN9frt_queueIiE7ISR_getEPi>
     2e4:	0c 94 a6 1c 	jmp	0x394c	; 0x394c <_ZN9frt_queueIiE7ISR_getEv>
     2e8:	0c 94 d0 16 	jmp	0x2da0	; 0x2da0 <_ZN8emstream7getcharEv>
     2ec:	0c 94 ff 12 	jmp	0x25fe	; 0x25fe <_ZN8frt_task12print_statusER8emstream>
     2f0:	0c 94 55 17 	jmp	0x2eaa	; 0x2eaa <_ZN8emstreamlsE15ser_manipulator+0x72>
     2f4:	0c 94 f7 1b 	jmp	0x37ee	; 0x37ee <_ZN9frt_queueIjE3getEPj>
     2f8:	0c 94 72 1b 	jmp	0x36e4	; 0x36e4 <_ZN9frt_queueIjE12ISR_is_emptyEv>
     2fc:	0c 94 2a 16 	jmp	0x2c54	; 0x2c54 <__cxa_pure_virtual>
     300:	0c 94 1e 1c 	jmp	0x383c	; 0x383c <_ZN9frt_queueIiE10get_a_copyERi>
     304:	0c 94 1e 1d 	jmp	0x3a3c	; 0x3a3c <_ZN9frt_queueIjE7butt_inERKj>
     308:	0c 94 b6 18 	jmp	0x316c	; 0x316c <_ZN5rs23212clear_screenEv>
     30c:	0c 94 b4 1b 	jmp	0x3768	; 0x3768 <_ZN9frt_queueIiE12num_items_inEv>
     310:	0c 94 51 1c 	jmp	0x38a2	; 0x38a2 <_ZN9frt_queueIiE3getEv>
     314:	0c 94 60 1b 	jmp	0x36c0	; 0x36c0 <_ZN9frt_queueIjE16ISR_num_items_inEv>
     318:	0c 94 7d 18 	jmp	0x30fa	; 0x30fa <_ZN5rs2327getcharEv>
     31c:	0c 94 2a 1c 	jmp	0x3854	; 0x3854 <_ZN9frt_queueIiE10get_a_copyEv>
     320:	0c 94 03 1c 	jmp	0x3806	; 0x3806 <_ZN9frt_queueIjE3getEv>
     324:	0c 94 49 14 	jmp	0x2892	; 0x2892 <_ZN14frt_text_queue7getcharEv>

00000328 <__trampolines_end>:
     328:	2c 20       	and	r2, r12
     32a:	54 43       	sbci	r21, 0x34	; 52
     32c:	43 30       	cpi	r20, 0x03	; 3
     32e:	43 43       	sbci	r20, 0x33	; 51
     330:	41 3d       	cpi	r20, 0xD1	; 209
	...

00000333 <_ZZN9task_user11show_statusEvE3__c_3>:
     333:	2f 00                                               /.

00000335 <_ZZN9task_user11show_statusEvE3__c_2>:
     335:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

00000343 <_ZZN9task_user11show_statusEvE3__c_1>:
     343:	54 69 6d 65 3a 20 00                                Time: .

0000034a <_ZZN9task_user11show_statusEvE3__c_0>:
     34a:	53 65 70 20 32 34 20 32 30 31 37 00                 Sep 24 2017.

00000356 <_ZZN9task_user11show_statusEvE3__c>:
     356:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     366:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000375 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     375:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

00000384 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     384:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     394:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

0000039f <_ZZN9task_user18print_help_messageEvE3__c_8>:
     39f:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     3af:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

000003bd <_ZZN9task_user18print_help_messageEvE3__c_7>:
     3bd:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     3cd:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     3dd:	6d 61 74 69 6f 6e 00                                mation.

000003e4 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     3e4:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     3f4:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000405 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     405:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     415:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000041d <_ZZN9task_user18print_help_messageEvE3__c_4>:
     41d:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     42d:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

00000439 <_ZZN9task_user18print_help_messageEvE3__c_3>:
     439:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     449:	68 65 20 41 56 52 00                                he AVR.

00000450 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     450:	20 68 65 6c 70 00                                    help.

00000456 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     456:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     466:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

00000475 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     475:	1b 5b 33 30 6d 00                                   .[30m.

0000047b <_ZZN9task_user18print_help_messageEvE3__c>:
     47b:	1b 5b 34 36 6d 00                                   .[46m.

00000481 <_ZZN9task_user3runEvE3__c_3>:
     481:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     491:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

0000049e <_ZZN9task_user3runEvE3__c_2>:
     49e:	3a 57 54 46 3f 00                                   :WTF?.

000004a4 <_ZZN9task_user3runEvE3__c_1>:
     4a4:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     4b4:	65 00                                               e.

000004b6 <_ZZN9task_user3runEvE3__c_0>:
     4b6:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

000004c4 <_ZZN9task_user3runEvE3__c>:
     4c4:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     4d4:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

000004e2 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     4e2:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

000004ec <_ZZN8frt_task15emergency_resetEvE3__c>:
     4ec:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

000004fb <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     4fb:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     50b:	61 73 6b 20 00                                      ask .

00000510 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     510:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

0000051e <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     51e:	20 63 72 65 61 74 65 64 00                           created.

00000527 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     527:	54 61 73 6b 20 00                                   Task .

0000052d <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     52d:	1b 5b 32 32 6d 00                                   .[22m.

00000533 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     533:	54 61 73 6b 3a 20 00                                Task: .

0000053a <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     53a:	1b 5b 31 6d 00                                      .[1m.

0000053f <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     53f:	1b 5b 32 32 6d 00                                   .[22m.

00000545 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     545:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

00000550 <_ZZ17print_task_stacksP8emstreamE3__c>:
     550:	1b 5b 31 6d 00                                      .[1m.

00000555 <_ZZ15print_task_listP8emstreamE3__c_9>:
     555:	09 09 00                                            ...

00000558 <_ZZ15print_task_listP8emstreamE3__c_8>:
     558:	2f 00                                               /.

0000055a <_ZZ15print_task_listP8emstreamE3__c_7>:
     55a:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

00000565 <_ZZ15print_task_listP8emstreamE3__c_6>:
     565:	09 2d 2d 2d 2d 00                                   .----.

0000056b <_ZZ15print_task_listP8emstreamE3__c_5>:
     56b:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

00000577 <_ZZ15print_task_listP8emstreamE3__c_4>:
     577:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

00000588 <_ZZ15print_task_listP8emstreamE3__c_3>:
     588:	09 52 75 6e 73 00                                   .Runs.

0000058e <_ZZ15print_task_listP8emstreamE3__c_2>:
     58e:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000059a <_ZZ15print_task_listP8emstreamE3__c_1>:
     59a:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

000005ab <_ZZ15print_task_listP8emstreamE3__c_0>:
     5ab:	09 53 74 61 63 6b 00                                .Stack.

000005b2 <_ZZ15print_task_listP8emstreamE3__c>:
     5b2:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

000005bd <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     5bd:	09 00                                               ..

000005bf <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     5bf:	09 00                                               ..

000005c1 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     5c1:	2f 00                                               /.

000005c3 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     5c3:	09 00                                               ..

000005c5 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     5c5:	09 00                                               ..

000005c7 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     5c7:	1b 5b 32 32 6d 00                                   .[22m.

000005cd <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     5cd:	1b 5b 31 6d 00                                      .[1m.

000005d2 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     5d2:	1b 5b 31 6d 00                                      .[1m.

000005d7 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     5d7:	20 20 00                                              .

000005da <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     5da:	0e 94 97 11 	call	0x232e	; 0x232e <_ZN8frt_task22_call_users_run_methodEPS_>

000005de <__ctors_start>:
     5de:	6b 21       	and	r22, r11

000005e0 <__ctors_end>:
     5e0:	11 24       	eor	r1, r1
     5e2:	1f be       	out	0x3f, r1	; 63
     5e4:	cf ef       	ldi	r28, 0xFF	; 255
     5e6:	cd bf       	out	0x3d, r28	; 61
     5e8:	df e5       	ldi	r29, 0x5F	; 95
     5ea:	de bf       	out	0x3e, r29	; 62
     5ec:	00 e0       	ldi	r16, 0x00	; 0
     5ee:	0c bf       	out	0x3c, r16	; 60

000005f0 <__do_copy_data>:
     5f0:	10 e2       	ldi	r17, 0x20	; 32
     5f2:	a0 e0       	ldi	r26, 0x00	; 0
     5f4:	b0 e2       	ldi	r27, 0x20	; 32
     5f6:	e8 ef       	ldi	r30, 0xF8	; 248
     5f8:	fa e4       	ldi	r31, 0x4A	; 74
     5fa:	00 e0       	ldi	r16, 0x00	; 0
     5fc:	0b bf       	out	0x3b, r16	; 59
     5fe:	02 c0       	rjmp	.+4      	; 0x604 <__do_copy_data+0x14>
     600:	07 90       	elpm	r0, Z+
     602:	0d 92       	st	X+, r0
     604:	a0 3e       	cpi	r26, 0xE0	; 224
     606:	b1 07       	cpc	r27, r17
     608:	d9 f7       	brne	.-10     	; 0x600 <__do_copy_data+0x10>

0000060a <__do_clear_bss>:
     60a:	22 e4       	ldi	r18, 0x42	; 66
     60c:	a0 ee       	ldi	r26, 0xE0	; 224
     60e:	b0 e2       	ldi	r27, 0x20	; 32
     610:	01 c0       	rjmp	.+2      	; 0x614 <.do_clear_bss_start>

00000612 <.do_clear_bss_loop>:
     612:	1d 92       	st	X+, r1

00000614 <.do_clear_bss_start>:
     614:	ad 36       	cpi	r26, 0x6D	; 109
     616:	b2 07       	cpc	r27, r18
     618:	e1 f7       	brne	.-8      	; 0x612 <.do_clear_bss_loop>

0000061a <__do_global_ctors>:
     61a:	12 e0       	ldi	r17, 0x02	; 2
     61c:	c0 ef       	ldi	r28, 0xF0	; 240
     61e:	d2 e0       	ldi	r29, 0x02	; 2
     620:	00 e0       	ldi	r16, 0x00	; 0
     622:	06 c0       	rjmp	.+12     	; 0x630 <__do_global_ctors+0x16>
     624:	21 97       	sbiw	r28, 0x01	; 1
     626:	01 09       	sbc	r16, r1
     628:	80 2f       	mov	r24, r16
     62a:	fe 01       	movw	r30, r28
     62c:	0e 94 d7 24 	call	0x49ae	; 0x49ae <__tablejump2__>
     630:	cf 3e       	cpi	r28, 0xEF	; 239
     632:	d1 07       	cpc	r29, r17
     634:	80 e0       	ldi	r24, 0x00	; 0
     636:	08 07       	cpc	r16, r24
     638:	a9 f7       	brne	.-22     	; 0x624 <__do_global_ctors+0xa>
     63a:	0e 94 7b 1d 	call	0x3af6	; 0x3af6 <main>
     63e:	0c 94 7a 25 	jmp	0x4af4	; 0x4af4 <_exit>

00000642 <__bad_interrupt>:
     642:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000646 <_ZN8task_LED3runEv>:
//-------------------------------------------------------------------------------------
/** This task blinks an LED attached to PORTR Pin 1
 */

void task_LED::run (void)
{
     646:	cf 93       	push	r28
     648:	df 93       	push	r29
     64a:	00 d0       	rcall	.+0      	; 0x64c <_ZN8task_LED3runEv+0x6>
     64c:	1f 92       	push	r1
     64e:	cd b7       	in	r28, 0x3d	; 61
     650:	de b7       	in	r29, 0x3e	; 62
     652:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     654:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xTaskGetTickCount>
     658:	69 83       	std	Y+1, r22	; 0x01
     65a:	7a 83       	std	Y+2, r23	; 0x02
     65c:	8b 83       	std	Y+3, r24	; 0x03
     65e:	9c 83       	std	Y+4, r25	; 0x04
	
	
	// Configure PORT C to be used for PWM output on PC0-PC2 and for bit toggling on PC3
	PORTC.OUT &= ~(1 << 0 | 1 << 1 | 1 << 2 | 1 << 3); // Clear Bits 0-2 on port c
     660:	e0 e4       	ldi	r30, 0x40	; 64
     662:	f6 e0       	ldi	r31, 0x06	; 6
     664:	84 81       	ldd	r24, Z+4	; 0x04
     666:	80 7f       	andi	r24, 0xF0	; 240
     668:	84 83       	std	Z+4, r24	; 0x04
	PORTC.DIR |= (1 << 0 | 1 << 1 | 1 << 2 | 1 << 3); // Set Bits 0-2 on port c as outputs
     66a:	80 81       	ld	r24, Z
     66c:	8f 60       	ori	r24, 0x0F	; 15
     66e:	80 83       	st	Z, r24
	
	// Configure Timer Counter C0 for center-aligned 64KHz PWM on ChA ChB and ChC (PC0-PC2)
	// and enable interrupts on ovf so that a new duty cycle may be selected
	TCC0.CTRLA = (1 << TC0_CLKSEL0_bp); // Select a pre-scaler of 1
     670:	e0 e0       	ldi	r30, 0x00	; 0
     672:	f8 e0       	ldi	r31, 0x08	; 8
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	80 83       	st	Z, r24
	TCC0.CTRLB = (1 << TC0_CCAEN_bp | 1 << TC0_CCBEN_bp | 1 << TC0_CCCEN_bp | 0b101 << TC0_WGMODE0_bp); // Enable channels A, B, and C and Configure for Dual Slope PWM
     678:	85 e7       	ldi	r24, 0x75	; 117
     67a:	81 83       	std	Z+1, r24	; 0x01
	TCC0.CTRLD = 0;
     67c:	13 82       	std	Z+3, r1	; 0x03
	TCC0.CTRLE = 0;
     67e:	14 82       	std	Z+4, r1	; 0x04
	TCC0.INTCTRLA |= (0b11 << TC0_OVFINTLVL0_bp); // Enable high level interrupts on ovf
     680:	86 81       	ldd	r24, Z+6	; 0x06
     682:	83 60       	ori	r24, 0x03	; 3
     684:	86 83       	std	Z+6, r24	; 0x06

	// Set the duty cycles all to 0 and set the period to 256 clock ticks; this will be the PWM resolution
	TCC0.CCABUF = 0x00;
     686:	10 ae       	std	Z+56, r1	; 0x38
     688:	11 ae       	std	Z+57, r1	; 0x39
	TCC0.CCBBUF = 0x00;
     68a:	12 ae       	std	Z+58, r1	; 0x3a
     68c:	13 ae       	std	Z+59, r1	; 0x3b
	TCC0.CCCBUF = 0x00;
     68e:	14 ae       	std	Z+60, r1	; 0x3c
     690:	15 ae       	std	Z+61, r1	; 0x3d
	TCC0.PERBUF = 0xFF; // Set Period to 256 clock ticks (64KHz pwm)
     692:	8f ef       	ldi	r24, 0xFF	; 255
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	86 ab       	std	Z+54, r24	; 0x36
     698:	97 ab       	std	Z+55, r25	; 0x37
		 *  @param milliseconds The number of milliseconds to delay
		 */
		void delay_ms (portTickType milliseconds)
		{
			portTickType duration = configMS_TO_TICKS (milliseconds);
			vTaskDelay (duration);
     69a:	6a e0       	ldi	r22, 0x0A	; 10
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	80 e0       	ldi	r24, 0x00	; 0
     6a0:	90 e0       	ldi	r25, 0x00	; 0
     6a2:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vTaskDelay>

	// Wait a little while for user interface task to finish up
	delay_ms(10);
	
	// Print the header for the PWM output table
	*p_serial << endl << "t\tang\tA\tB\tC\t" << endl;
     6a6:	66 e0       	ldi	r22, 0x06	; 6
     6a8:	f8 01       	movw	r30, r16
     6aa:	86 81       	ldd	r24, Z+6	; 0x06
     6ac:	97 81       	ldd	r25, Z+7	; 0x07
     6ae:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     6b2:	7c 01       	movw	r14, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     6b4:	6a e0       	ldi	r22, 0x0A	; 10
     6b6:	70 e2       	ldi	r23, 0x20	; 32
     6b8:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     6bc:	66 e0       	ldi	r22, 0x06	; 6
     6be:	c7 01       	movw	r24, r14
     6c0:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
			//*p_serial << time_queue.get() << "\t" << ang_queue.get() << "\t" << A_queue.get() << "\t"  << B_queue.get() << "\t"  << C_queue.get() << endl;	
		//}
		
		// Increment the run counter. This counter belongs to the parent class and can
		// be printed out for debugging purposes
		runs++;
     6c4:	f8 01       	movw	r30, r16
     6c6:	86 85       	ldd	r24, Z+14	; 0x0e
     6c8:	97 85       	ldd	r25, Z+15	; 0x0f
     6ca:	a0 89       	ldd	r26, Z+16	; 0x10
     6cc:	b1 89       	ldd	r27, Z+17	; 0x11
     6ce:	01 96       	adiw	r24, 0x01	; 1
     6d0:	a1 1d       	adc	r26, r1
     6d2:	b1 1d       	adc	r27, r1
     6d4:	86 87       	std	Z+14, r24	; 0x0e
     6d6:	97 87       	std	Z+15, r25	; 0x0f
     6d8:	a0 8b       	std	Z+16, r26	; 0x10
     6da:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     6dc:	41 e0       	ldi	r20, 0x01	; 1
     6de:	50 e0       	ldi	r21, 0x00	; 0
     6e0:	60 e0       	ldi	r22, 0x00	; 0
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	ce 01       	movw	r24, r28
     6e6:	01 96       	adiw	r24, 0x01	; 1
     6e8:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <vTaskDelayUntil>
     6ec:	eb cf       	rjmp	.-42     	; 0x6c4 <_ZN8task_LED3runEv+0x7e>

000006ee <_ZN8task_LEDC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_LED::task_LED (const char* a_name, 
     6ee:	0f 93       	push	r16
     6f0:	1f 93       	push	r17
     6f2:	cf 93       	push	r28
     6f4:	df 93       	push	r29
     6f6:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     6f8:	0e 94 aa 11 	call	0x2354	; 0x2354 <_ZN8frt_taskC1EPKchjP8emstream>
     6fc:	8b e1       	ldi	r24, 0x1B	; 27
     6fe:	90 e2       	ldi	r25, 0x20	; 32
     700:	88 83       	st	Y, r24
     702:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	1f 91       	pop	r17
     70a:	0f 91       	pop	r16
     70c:	08 95       	ret

0000070e <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     70e:	0f 93       	push	r16
     710:	1f 93       	push	r17
     712:	cf 93       	push	r28
     714:	df 93       	push	r29
     716:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     718:	0e 94 aa 11 	call	0x2354	; 0x2354 <_ZN8frt_taskC1EPKchjP8emstream>
     71c:	83 e2       	ldi	r24, 0x23	; 35
     71e:	90 e2       	ldi	r25, 0x20	; 32
     720:	88 83       	st	Y, r24
     722:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     724:	df 91       	pop	r29
     726:	cf 91       	pop	r28
     728:	1f 91       	pop	r17
     72a:	0f 91       	pop	r16
     72c:	08 95       	ret

0000072e <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     72e:	0f 93       	push	r16
     730:	1f 93       	push	r17
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     738:	6a e0       	ldi	r22, 0x0A	; 10
     73a:	8e 81       	ldd	r24, Y+6	; 0x06
     73c:	9f 81       	ldd	r25, Y+7	; 0x07
     73e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     742:	8c 01       	movw	r16, r24
     744:	6b e7       	ldi	r22, 0x7B	; 123
     746:	74 e0       	ldi	r23, 0x04	; 4
     748:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     74c:	6a e0       	ldi	r22, 0x0A	; 10
     74e:	c8 01       	movw	r24, r16
     750:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     754:	8c 01       	movw	r16, r24
     756:	65 e7       	ldi	r22, 0x75	; 117
     758:	74 e0       	ldi	r23, 0x04	; 4
     75a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     75e:	67 e0       	ldi	r22, 0x07	; 7
     760:	c8 01       	movw	r24, r16
     762:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     766:	6a e0       	ldi	r22, 0x0A	; 10
     768:	8e 81       	ldd	r24, Y+6	; 0x06
     76a:	9f 81       	ldd	r25, Y+7	; 0x07
     76c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     770:	8c 01       	movw	r16, r24
     772:	66 e5       	ldi	r22, 0x56	; 86
     774:	74 e0       	ldi	r23, 0x04	; 4
     776:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     77a:	6a e0       	ldi	r22, 0x0A	; 10
     77c:	c8 01       	movw	r24, r16
     77e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     782:	8c 01       	movw	r16, r24
     784:	60 e5       	ldi	r22, 0x50	; 80
     786:	74 e0       	ldi	r23, 0x04	; 4
     788:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     78c:	66 e0       	ldi	r22, 0x06	; 6
     78e:	c8 01       	movw	r24, r16
     790:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     794:	6a e0       	ldi	r22, 0x0A	; 10
     796:	8e 81       	ldd	r24, Y+6	; 0x06
     798:	9f 81       	ldd	r25, Y+7	; 0x07
     79a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     79e:	8c 01       	movw	r16, r24
     7a0:	69 e3       	ldi	r22, 0x39	; 57
     7a2:	74 e0       	ldi	r23, 0x04	; 4
     7a4:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     7a8:	66 e0       	ldi	r22, 0x06	; 6
     7aa:	c8 01       	movw	r24, r16
     7ac:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     7b0:	6a e0       	ldi	r22, 0x0A	; 10
     7b2:	8e 81       	ldd	r24, Y+6	; 0x06
     7b4:	9f 81       	ldd	r25, Y+7	; 0x07
     7b6:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     7ba:	8c 01       	movw	r16, r24
     7bc:	6d e1       	ldi	r22, 0x1D	; 29
     7be:	74 e0       	ldi	r23, 0x04	; 4
     7c0:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     7c4:	66 e0       	ldi	r22, 0x06	; 6
     7c6:	c8 01       	movw	r24, r16
     7c8:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     7cc:	6a e0       	ldi	r22, 0x0A	; 10
     7ce:	8e 81       	ldd	r24, Y+6	; 0x06
     7d0:	9f 81       	ldd	r25, Y+7	; 0x07
     7d2:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     7d6:	8c 01       	movw	r16, r24
     7d8:	65 e0       	ldi	r22, 0x05	; 5
     7da:	74 e0       	ldi	r23, 0x04	; 4
     7dc:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     7e0:	66 e0       	ldi	r22, 0x06	; 6
     7e2:	c8 01       	movw	r24, r16
     7e4:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     7e8:	6a e0       	ldi	r22, 0x0A	; 10
     7ea:	8e 81       	ldd	r24, Y+6	; 0x06
     7ec:	9f 81       	ldd	r25, Y+7	; 0x07
     7ee:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     7f2:	8c 01       	movw	r16, r24
     7f4:	64 ee       	ldi	r22, 0xE4	; 228
     7f6:	73 e0       	ldi	r23, 0x03	; 3
     7f8:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     7fc:	66 e0       	ldi	r22, 0x06	; 6
     7fe:	c8 01       	movw	r24, r16
     800:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     804:	6a e0       	ldi	r22, 0x0A	; 10
     806:	8e 81       	ldd	r24, Y+6	; 0x06
     808:	9f 81       	ldd	r25, Y+7	; 0x07
     80a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     80e:	8c 01       	movw	r16, r24
     810:	6d eb       	ldi	r22, 0xBD	; 189
     812:	73 e0       	ldi	r23, 0x03	; 3
     814:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     818:	66 e0       	ldi	r22, 0x06	; 6
     81a:	c8 01       	movw	r24, r16
     81c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     820:	6a e0       	ldi	r22, 0x0A	; 10
     822:	8e 81       	ldd	r24, Y+6	; 0x06
     824:	9f 81       	ldd	r25, Y+7	; 0x07
     826:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     82a:	8c 01       	movw	r16, r24
     82c:	6f e9       	ldi	r22, 0x9F	; 159
     82e:	73 e0       	ldi	r23, 0x03	; 3
     830:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     834:	66 e0       	ldi	r22, 0x06	; 6
     836:	c8 01       	movw	r24, r16
     838:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     83c:	6a e0       	ldi	r22, 0x0A	; 10
     83e:	8e 81       	ldd	r24, Y+6	; 0x06
     840:	9f 81       	ldd	r25, Y+7	; 0x07
     842:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     846:	8c 01       	movw	r16, r24
     848:	64 e8       	ldi	r22, 0x84	; 132
     84a:	73 e0       	ldi	r23, 0x03	; 3
     84c:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     850:	66 e0       	ldi	r22, 0x06	; 6
     852:	c8 01       	movw	r24, r16
     854:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     858:	6a e0       	ldi	r22, 0x0A	; 10
     85a:	8e 81       	ldd	r24, Y+6	; 0x06
     85c:	9f 81       	ldd	r25, Y+7	; 0x07
     85e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     862:	ec 01       	movw	r28, r24
     864:	65 e7       	ldi	r22, 0x75	; 117
     866:	73 e0       	ldi	r23, 0x03	; 3
     868:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     86c:	66 e0       	ldi	r22, 0x06	; 6
     86e:	ce 01       	movw	r24, r28
     870:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
}
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	1f 91       	pop	r17
     87a:	0f 91       	pop	r16
     87c:	08 95       	ret

0000087e <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     87e:	af 92       	push	r10
     880:	bf 92       	push	r11
     882:	cf 92       	push	r12
     884:	df 92       	push	r13
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	0f 93       	push	r16
     88c:	1f 93       	push	r17
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	00 d0       	rcall	.+0      	; 0x894 <_ZN9task_user11show_statusEv+0x16>
     894:	00 d0       	rcall	.+0      	; 0x896 <_ZN9task_user11show_statusEv+0x18>
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
     89a:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     89c:	19 82       	std	Y+1, r1	; 0x01
     89e:	1a 82       	std	Y+2, r1	; 0x02
     8a0:	1b 82       	std	Y+3, r1	; 0x03
     8a2:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     8a4:	1d 82       	std	Y+5, r1	; 0x05
     8a6:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     8a8:	0e 94 c4 06 	call	0xd88	; 0xd88 <xPortGetFreeHeapSize>
     8ac:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     8ae:	ce 01       	movw	r24, r28
     8b0:	01 96       	adiw	r24, 0x01	; 1
     8b2:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <_ZN10time_stamp10set_to_nowEv>
     8b6:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     8b8:	66 e0       	ldi	r22, 0x06	; 6
     8ba:	f8 01       	movw	r30, r16
     8bc:	86 81       	ldd	r24, Z+6	; 0x06
     8be:	97 81       	ldd	r25, Z+7	; 0x07
     8c0:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     8c4:	6a e0       	ldi	r22, 0x0A	; 10
     8c6:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     8ca:	7c 01       	movw	r14, r24
     8cc:	66 e5       	ldi	r22, 0x56	; 86
     8ce:	73 e0       	ldi	r23, 0x03	; 3
     8d0:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     8d4:	6a e0       	ldi	r22, 0x0A	; 10
     8d6:	c7 01       	movw	r24, r14
     8d8:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     8dc:	7c 01       	movw	r14, r24
     8de:	6a e4       	ldi	r22, 0x4A	; 74
     8e0:	73 e0       	ldi	r23, 0x03	; 3
     8e2:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     8e6:	66 e0       	ldi	r22, 0x06	; 6
     8e8:	c7 01       	movw	r24, r14
     8ea:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     8ee:	6a e0       	ldi	r22, 0x0A	; 10
     8f0:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     8f4:	7c 01       	movw	r14, r24
     8f6:	63 e4       	ldi	r22, 0x43	; 67
     8f8:	73 e0       	ldi	r23, 0x03	; 3
     8fa:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     8fe:	b5 01       	movw	r22, r10
     900:	c7 01       	movw	r24, r14
     902:	0e 94 ff 14 	call	0x29fe	; 0x29fe <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     906:	6a e0       	ldi	r22, 0x0A	; 10
     908:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     90c:	7c 01       	movw	r14, r24
     90e:	65 e3       	ldi	r22, 0x35	; 53
     910:	73 e0       	ldi	r23, 0x03	; 3
     912:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     916:	b6 01       	movw	r22, r12
     918:	c7 01       	movw	r24, r14
     91a:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN8emstreamlsEj>
     91e:	6a e0       	ldi	r22, 0x0A	; 10
     920:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     924:	7c 01       	movw	r14, r24
     926:	63 e3       	ldi	r22, 0x33	; 51
     928:	73 e0       	ldi	r23, 0x03	; 3
     92a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     92e:	4f ef       	ldi	r20, 0xFF	; 255
     930:	5f e1       	ldi	r21, 0x1F	; 31
     932:	60 e0       	ldi	r22, 0x00	; 0
     934:	70 e0       	ldi	r23, 0x00	; 0
     936:	c7 01       	movw	r24, r14
     938:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     93c:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     940:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     944:	6a e0       	ldi	r22, 0x0A	; 10
     946:	f8 01       	movw	r30, r16
     948:	86 81       	ldd	r24, Z+6	; 0x06
     94a:	97 81       	ldd	r25, Z+7	; 0x07
     94c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     950:	7c 01       	movw	r14, r24
     952:	68 e2       	ldi	r22, 0x28	; 40
     954:	73 e0       	ldi	r23, 0x03	; 3
     956:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     95a:	b6 01       	movw	r22, r12
     95c:	c7 01       	movw	r24, r14
     95e:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN8emstreamlsEj>
     962:	66 e0       	ldi	r22, 0x06	; 6
     964:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     968:	66 e0       	ldi	r22, 0x06	; 6
     96a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     96e:	f8 01       	movw	r30, r16
     970:	86 81       	ldd	r24, Z+6	; 0x06
     972:	97 81       	ldd	r25, Z+7	; 0x07
     974:	0e 94 b8 13 	call	0x2770	; 0x2770 <_Z15print_task_listP8emstream>
}
     978:	26 96       	adiw	r28, 0x06	; 6
     97a:	cd bf       	out	0x3d, r28	; 61
     97c:	de bf       	out	0x3e, r29	; 62
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	1f 91       	pop	r17
     984:	0f 91       	pop	r16
     986:	ff 90       	pop	r15
     988:	ef 90       	pop	r14
     98a:	df 90       	pop	r13
     98c:	cf 90       	pop	r12
     98e:	bf 90       	pop	r11
     990:	af 90       	pop	r10
     992:	08 95       	ret

00000994 <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	00 d0       	rcall	.+0      	; 0x99a <_ZN9task_user3runEv+0x6>
     99a:	00 d0       	rcall	.+0      	; 0x99c <_ZN9task_user3runEv+0x8>
     99c:	cd b7       	in	r28, 0x3d	; 61
     99e:	de b7       	in	r29, 0x3e	; 62
     9a0:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     9a2:	19 82       	std	Y+1, r1	; 0x01
     9a4:	1a 82       	std	Y+2, r1	; 0x02
     9a6:	1b 82       	std	Y+3, r1	; 0x03
     9a8:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     9aa:	1d 82       	std	Y+5, r1	; 0x05
     9ac:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     9ae:	6a e0       	ldi	r22, 0x0A	; 10
     9b0:	dc 01       	movw	r26, r24
     9b2:	16 96       	adiw	r26, 0x06	; 6
     9b4:	8d 91       	ld	r24, X+
     9b6:	9c 91       	ld	r25, X
     9b8:	17 97       	sbiw	r26, 0x07	; 7
     9ba:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     9be:	7c 01       	movw	r14, r24
     9c0:	64 ec       	ldi	r22, 0xC4	; 196
     9c2:	74 e0       	ldi	r23, 0x04	; 4
     9c4:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     9c8:	66 e0       	ldi	r22, 0x06	; 6
     9ca:	c7 01       	movw	r24, r14
     9cc:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     9d0:	f8 01       	movw	r30, r16
     9d2:	84 85       	ldd	r24, Z+12	; 0x0c
     9d4:	88 23       	and	r24, r24
     9d6:	21 f0       	breq	.+8      	; 0x9e0 <_ZN9task_user3runEv+0x4c>
     9d8:	81 30       	cpi	r24, 0x01	; 1
     9da:	09 f4       	brne	.+2      	; 0x9de <_ZN9task_user3runEv+0x4a>
     9dc:	5d c0       	rjmp	.+186    	; 0xa98 <_ZN9task_user3runEv+0x104>
     9de:	d8 c0       	rjmp	.+432    	; 0xb90 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     9e0:	86 81       	ldd	r24, Z+6	; 0x06
     9e2:	97 81       	ldd	r25, Z+7	; 0x07
     9e4:	dc 01       	movw	r26, r24
     9e6:	ed 91       	ld	r30, X+
     9e8:	fc 91       	ld	r31, X
     9ea:	04 80       	ldd	r0, Z+4	; 0x04
     9ec:	f5 81       	ldd	r31, Z+5	; 0x05
     9ee:	e0 2d       	mov	r30, r0
     9f0:	19 95       	eicall
     9f2:	88 23       	and	r24, r24
     9f4:	a9 f1       	breq	.+106    	; 0xa60 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     9f6:	f8 01       	movw	r30, r16
     9f8:	86 81       	ldd	r24, Z+6	; 0x06
     9fa:	97 81       	ldd	r25, Z+7	; 0x07
     9fc:	dc 01       	movw	r26, r24
     9fe:	ed 91       	ld	r30, X+
     a00:	fc 91       	ld	r31, X
     a02:	06 80       	ldd	r0, Z+6	; 0x06
     a04:	f7 81       	ldd	r31, Z+7	; 0x07
     a06:	e0 2d       	mov	r30, r0
     a08:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     a0a:	99 27       	eor	r25, r25
     a0c:	81 30       	cpi	r24, 0x01	; 1
     a0e:	91 05       	cpc	r25, r1
     a10:	f9 f0       	breq	.+62     	; 0xa50 <_ZN9task_user3runEv+0xbc>
     a12:	03 97       	sbiw	r24, 0x03	; 3
     a14:	09 f0       	breq	.+2      	; 0xa18 <_ZN9task_user3runEv+0x84>
     a16:	d8 c0       	rjmp	.+432    	; 0xbc8 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     a18:	6a e0       	ldi	r22, 0x0A	; 10
     a1a:	f8 01       	movw	r30, r16
     a1c:	86 81       	ldd	r24, Z+6	; 0x06
     a1e:	97 81       	ldd	r25, Z+7	; 0x07
     a20:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     a24:	8c 01       	movw	r16, r24
     a26:	66 eb       	ldi	r22, 0xB6	; 182
     a28:	74 e0       	ldi	r23, 0x04	; 4
     a2a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     a2e:	66 e0       	ldi	r22, 0x06	; 6
     a30:	c8 01       	movw	r24, r16
     a32:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     a36:	93 e0       	ldi	r25, 0x03	; 3
     a38:	88 ed       	ldi	r24, 0xD8	; 216
     a3a:	08 b6       	in	r0, 0x38	; 56
     a3c:	18 be       	out	0x38, r1	; 56
     a3e:	84 bf       	out	0x34, r24	; 52
     a40:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     a44:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     a48:	81 fd       	sbrc	r24, 1
     a4a:	fc cf       	rjmp	.-8      	; 0xa44 <_ZN9task_user3runEv+0xb0>
     a4c:	08 be       	out	0x38, r0	; 56
     a4e:	ff cf       	rjmp	.-2      	; 0xa4e <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     a50:	c8 01       	movw	r24, r16
     a52:	0e 94 97 03 	call	0x72e	; 0x72e <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     a56:	61 e0       	ldi	r22, 0x01	; 1
     a58:	c8 01       	movw	r24, r16
     a5a:	0e 94 a6 11 	call	0x234c	; 0x234c <_ZN8frt_task13transition_toEh>
							break;
     a5e:	b4 c0       	rjmp	.+360    	; 0xbc8 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     a60:	8b e5       	ldi	r24, 0x5B	; 91
     a62:	92 e4       	ldi	r25, 0x42	; 66
     a64:	0e 94 67 14 	call	0x28ce	; 0x28ce <_ZN14frt_text_queue14check_for_charEv>
     a68:	88 23       	and	r24, r24
     a6a:	09 f4       	brne	.+2      	; 0xa6e <_ZN9task_user3runEv+0xda>
     a6c:	ad c0       	rjmp	.+346    	; 0xbc8 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     a6e:	d8 01       	movw	r26, r16
     a70:	16 96       	adiw	r26, 0x06	; 6
     a72:	ed 91       	ld	r30, X+
     a74:	fc 91       	ld	r31, X
     a76:	17 97       	sbiw	r26, 0x07	; 7
     a78:	01 90       	ld	r0, Z+
     a7a:	f0 81       	ld	r31, Z
     a7c:	e0 2d       	mov	r30, r0
     a7e:	e2 80       	ldd	r14, Z+2	; 0x02
     a80:	f3 80       	ldd	r15, Z+3	; 0x03
     a82:	8b e5       	ldi	r24, 0x5B	; 91
     a84:	92 e4       	ldi	r25, 0x42	; 66
     a86:	0e 94 49 14 	call	0x2892	; 0x2892 <_ZN14frt_text_queue7getcharEv>
     a8a:	68 2f       	mov	r22, r24
     a8c:	f8 01       	movw	r30, r16
     a8e:	86 81       	ldd	r24, Z+6	; 0x06
     a90:	97 81       	ldd	r25, Z+7	; 0x07
     a92:	f7 01       	movw	r30, r14
     a94:	19 95       	eicall
     a96:	98 c0       	rjmp	.+304    	; 0xbc8 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     a98:	86 81       	ldd	r24, Z+6	; 0x06
     a9a:	97 81       	ldd	r25, Z+7	; 0x07
     a9c:	dc 01       	movw	r26, r24
     a9e:	ed 91       	ld	r30, X+
     aa0:	fc 91       	ld	r31, X
     aa2:	04 80       	ldd	r0, Z+4	; 0x04
     aa4:	f5 81       	ldd	r31, Z+5	; 0x05
     aa6:	e0 2d       	mov	r30, r0
     aa8:	19 95       	eicall
     aaa:	88 23       	and	r24, r24
     aac:	09 f4       	brne	.+2      	; 0xab0 <_ZN9task_user3runEv+0x11c>
     aae:	8c c0       	rjmp	.+280    	; 0xbc8 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     ab0:	f8 01       	movw	r30, r16
     ab2:	86 81       	ldd	r24, Z+6	; 0x06
     ab4:	97 81       	ldd	r25, Z+7	; 0x07
     ab6:	dc 01       	movw	r26, r24
     ab8:	ed 91       	ld	r30, X+
     aba:	fc 91       	ld	r31, X
     abc:	06 80       	ldd	r0, Z+6	; 0x06
     abe:	f7 81       	ldd	r31, Z+7	; 0x07
     ac0:	e0 2d       	mov	r30, r0
     ac2:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     ac4:	9c 01       	movw	r18, r24
     ac6:	33 27       	eor	r19, r19
     ac8:	28 36       	cpi	r18, 0x68	; 104
     aca:	31 05       	cpc	r19, r1
     acc:	59 f1       	breq	.+86     	; 0xb24 <_ZN9task_user3runEv+0x190>
     ace:	3c f4       	brge	.+14     	; 0xade <_ZN9task_user3runEv+0x14a>
     ad0:	2b 31       	cpi	r18, 0x1B	; 27
     ad2:	31 05       	cpc	r19, r1
     ad4:	59 f1       	breq	.+86     	; 0xb2c <_ZN9task_user3runEv+0x198>
     ad6:	25 36       	cpi	r18, 0x65	; 101
     ad8:	31 05       	cpc	r19, r1
     ada:	41 f1       	breq	.+80     	; 0xb2c <_ZN9task_user3runEv+0x198>
     adc:	3b c0       	rjmp	.+118    	; 0xb54 <_ZN9task_user3runEv+0x1c0>
     ade:	23 37       	cpi	r18, 0x73	; 115
     ae0:	31 05       	cpc	r19, r1
     ae2:	c1 f0       	breq	.+48     	; 0xb14 <_ZN9task_user3runEv+0x180>
     ae4:	26 37       	cpi	r18, 0x76	; 118
     ae6:	31 05       	cpc	r19, r1
     ae8:	89 f0       	breq	.+34     	; 0xb0c <_ZN9task_user3runEv+0x178>
     aea:	2e 36       	cpi	r18, 0x6E	; 110
     aec:	31 05       	cpc	r19, r1
     aee:	91 f5       	brne	.+100    	; 0xb54 <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     af0:	ce 01       	movw	r24, r28
     af2:	01 96       	adiw	r24, 0x01	; 1
     af4:	0e 94 5b 15 	call	0x2ab6	; 0x2ab6 <_ZN10time_stamp10set_to_nowEv>
     af8:	bc 01       	movw	r22, r24
     afa:	f8 01       	movw	r30, r16
     afc:	86 81       	ldd	r24, Z+6	; 0x06
     afe:	97 81       	ldd	r25, Z+7	; 0x07
     b00:	0e 94 ff 14 	call	0x29fe	; 0x29fe <_ZlsR8emstreamR10time_stamp>
     b04:	66 e0       	ldi	r22, 0x06	; 6
     b06:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
							break;
     b0a:	5e c0       	rjmp	.+188    	; 0xbc8 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     b0c:	c8 01       	movw	r24, r16
     b0e:	0e 94 3f 04 	call	0x87e	; 0x87e <_ZN9task_user11show_statusEv>
							break;
     b12:	5a c0       	rjmp	.+180    	; 0xbc8 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     b14:	d8 01       	movw	r26, r16
     b16:	16 96       	adiw	r26, 0x06	; 6
     b18:	8d 91       	ld	r24, X+
     b1a:	9c 91       	ld	r25, X
     b1c:	17 97       	sbiw	r26, 0x07	; 7
     b1e:	0e 94 bf 12 	call	0x257e	; 0x257e <_Z17print_task_stacksP8emstream>
							break;
     b22:	52 c0       	rjmp	.+164    	; 0xbc8 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     b24:	c8 01       	movw	r24, r16
     b26:	0e 94 97 03 	call	0x72e	; 0x72e <_ZN9task_user18print_help_messageEv>
							break;
     b2a:	4e c0       	rjmp	.+156    	; 0xbc8 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     b2c:	6a e0       	ldi	r22, 0x0A	; 10
     b2e:	f8 01       	movw	r30, r16
     b30:	86 81       	ldd	r24, Z+6	; 0x06
     b32:	97 81       	ldd	r25, Z+7	; 0x07
     b34:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     b38:	7c 01       	movw	r14, r24
     b3a:	64 ea       	ldi	r22, 0xA4	; 164
     b3c:	74 e0       	ldi	r23, 0x04	; 4
     b3e:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     b42:	66 e0       	ldi	r22, 0x06	; 6
     b44:	c7 01       	movw	r24, r14
     b46:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     b4a:	60 e0       	ldi	r22, 0x00	; 0
     b4c:	c8 01       	movw	r24, r16
     b4e:	0e 94 a6 11 	call	0x234c	; 0x234c <_ZN8frt_task13transition_toEh>
							break;
     b52:	3a c0       	rjmp	.+116    	; 0xbc8 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     b54:	f8 01       	movw	r30, r16
     b56:	a6 81       	ldd	r26, Z+6	; 0x06
     b58:	b7 81       	ldd	r27, Z+7	; 0x07
     b5a:	ed 91       	ld	r30, X+
     b5c:	fc 91       	ld	r31, X
     b5e:	11 97       	sbiw	r26, 0x01	; 1
     b60:	02 80       	ldd	r0, Z+2	; 0x02
     b62:	f3 81       	ldd	r31, Z+3	; 0x03
     b64:	e0 2d       	mov	r30, r0
     b66:	68 2f       	mov	r22, r24
     b68:	cd 01       	movw	r24, r26
     b6a:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     b6c:	6a e0       	ldi	r22, 0x0A	; 10
     b6e:	d8 01       	movw	r26, r16
     b70:	16 96       	adiw	r26, 0x06	; 6
     b72:	8d 91       	ld	r24, X+
     b74:	9c 91       	ld	r25, X
     b76:	17 97       	sbiw	r26, 0x07	; 7
     b78:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     b7c:	7c 01       	movw	r14, r24
     b7e:	6e e9       	ldi	r22, 0x9E	; 158
     b80:	74 e0       	ldi	r23, 0x04	; 4
     b82:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     b86:	66 e0       	ldi	r22, 0x06	; 6
     b88:	c7 01       	movw	r24, r14
     b8a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
							break;
     b8e:	1c c0       	rjmp	.+56     	; 0xbc8 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     b90:	6a e0       	ldi	r22, 0x0A	; 10
     b92:	f8 01       	movw	r30, r16
     b94:	86 81       	ldd	r24, Z+6	; 0x06
     b96:	97 81       	ldd	r25, Z+7	; 0x07
     b98:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
     b9c:	8c 01       	movw	r16, r24
     b9e:	61 e8       	ldi	r22, 0x81	; 129
     ba0:	74 e0       	ldi	r23, 0x04	; 4
     ba2:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
     ba6:	66 e0       	ldi	r22, 0x06	; 6
     ba8:	c8 01       	movw	r24, r16
     baa:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     bae:	93 e0       	ldi	r25, 0x03	; 3
     bb0:	88 ed       	ldi	r24, 0xD8	; 216
     bb2:	08 b6       	in	r0, 0x38	; 56
     bb4:	18 be       	out	0x38, r1	; 56
     bb6:	84 bf       	out	0x34, r24	; 52
     bb8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     bbc:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     bc0:	81 fd       	sbrc	r24, 1
     bc2:	fc cf       	rjmp	.-8      	; 0xbbc <_ZN9task_user3runEv+0x228>
     bc4:	08 be       	out	0x38, r0	; 56
     bc6:	ff cf       	rjmp	.-2      	; 0xbc6 <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     bc8:	f8 01       	movw	r30, r16
     bca:	86 85       	ldd	r24, Z+14	; 0x0e
     bcc:	97 85       	ldd	r25, Z+15	; 0x0f
     bce:	a0 89       	ldd	r26, Z+16	; 0x10
     bd0:	b1 89       	ldd	r27, Z+17	; 0x11
     bd2:	01 96       	adiw	r24, 0x01	; 1
     bd4:	a1 1d       	adc	r26, r1
     bd6:	b1 1d       	adc	r27, r1
     bd8:	86 87       	std	Z+14, r24	; 0x0e
     bda:	97 87       	std	Z+15, r25	; 0x0f
     bdc:	a0 8b       	std	Z+16, r26	; 0x10
     bde:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     be0:	61 e0       	ldi	r22, 0x01	; 1
     be2:	70 e0       	ldi	r23, 0x00	; 0
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	90 e0       	ldi	r25, 0x00	; 0
     be8:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     bec:	f1 ce       	rjmp	.-542    	; 0x9d0 <_ZN9task_user3runEv+0x3c>

00000bee <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     bee:	0f 93       	push	r16
     bf0:	1f 93       	push	r17
     bf2:	cf 93       	push	r28
     bf4:	df 93       	push	r29
     bf6:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     bf8:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     bfc:	80 91 e0 20 	lds	r24, 0x20E0	; 0x8020e0 <__data_end>
     c00:	81 11       	cpse	r24, r1
     c02:	1d c0       	rjmp	.+58     	; 0xc3e <pvPortMalloc+0x50>
		{
			prvHeapInit();
     c04:	a5 ee       	ldi	r26, 0xE5	; 229
     c06:	b0 e2       	ldi	r27, 0x20	; 32
     c08:	e9 ee       	ldi	r30, 0xE9	; 233
     c0a:	f0 e2       	ldi	r31, 0x20	; 32
     c0c:	ed 93       	st	X+, r30
     c0e:	fc 93       	st	X, r31
     c10:	11 97       	sbiw	r26, 0x01	; 1
     c12:	12 96       	adiw	r26, 0x02	; 2
     c14:	1d 92       	st	X+, r1
     c16:	1c 92       	st	X, r1
     c18:	13 97       	sbiw	r26, 0x03	; 3
     c1a:	a1 ee       	ldi	r26, 0xE1	; 225
     c1c:	b0 e2       	ldi	r27, 0x20	; 32
     c1e:	8f ef       	ldi	r24, 0xFF	; 255
     c20:	9f e1       	ldi	r25, 0x1F	; 31
     c22:	12 96       	adiw	r26, 0x02	; 2
     c24:	8d 93       	st	X+, r24
     c26:	9c 93       	st	X, r25
     c28:	13 97       	sbiw	r26, 0x03	; 3
     c2a:	1d 92       	st	X+, r1
     c2c:	1c 92       	st	X, r1
     c2e:	11 97       	sbiw	r26, 0x01	; 1
     c30:	82 83       	std	Z+2, r24	; 0x02
     c32:	93 83       	std	Z+3, r25	; 0x03
     c34:	a0 83       	st	Z, r26
     c36:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     c38:	81 e0       	ldi	r24, 0x01	; 1
     c3a:	80 93 e0 20 	sts	0x20E0, r24	; 0x8020e0 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     c3e:	20 97       	sbiw	r28, 0x00	; 0
     c40:	09 f4       	brne	.+2      	; 0xc44 <pvPortMalloc+0x56>
     c42:	5f c0       	rjmp	.+190    	; 0xd02 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     c44:	9e 01       	movw	r18, r28
     c46:	2b 5f       	subi	r18, 0xFB	; 251
     c48:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     c4a:	24 96       	adiw	r28, 0x04	; 4
     c4c:	ce 3f       	cpi	r28, 0xFE	; 254
     c4e:	df 41       	sbci	r29, 0x1F	; 31
     c50:	08 f0       	brcs	.+2      	; 0xc54 <pvPortMalloc+0x66>
     c52:	5a c0       	rjmp	.+180    	; 0xd08 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     c54:	e0 91 e5 20 	lds	r30, 0x20E5	; 0x8020e5 <xStart>
     c58:	f0 91 e6 20 	lds	r31, 0x20E6	; 0x8020e6 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     c5c:	a5 ee       	ldi	r26, 0xE5	; 229
     c5e:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     c60:	02 c0       	rjmp	.+4      	; 0xc66 <pvPortMalloc+0x78>
     c62:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     c64:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     c66:	82 81       	ldd	r24, Z+2	; 0x02
     c68:	93 81       	ldd	r25, Z+3	; 0x03
     c6a:	82 17       	cp	r24, r18
     c6c:	93 07       	cpc	r25, r19
     c6e:	20 f4       	brcc	.+8      	; 0xc78 <pvPortMalloc+0x8a>
     c70:	80 81       	ld	r24, Z
     c72:	91 81       	ldd	r25, Z+1	; 0x01
     c74:	00 97       	sbiw	r24, 0x00	; 0
     c76:	a9 f7       	brne	.-22     	; 0xc62 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     c78:	c0 e2       	ldi	r28, 0x20	; 32
     c7a:	e1 3e       	cpi	r30, 0xE1	; 225
     c7c:	fc 07       	cpc	r31, r28
     c7e:	09 f4       	brne	.+2      	; 0xc82 <pvPortMalloc+0x94>
     c80:	46 c0       	rjmp	.+140    	; 0xd0e <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     c82:	cd 91       	ld	r28, X+
     c84:	dc 91       	ld	r29, X
     c86:	11 97       	sbiw	r26, 0x01	; 1
     c88:	8e 01       	movw	r16, r28
     c8a:	0b 5f       	subi	r16, 0xFB	; 251
     c8c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     c8e:	80 81       	ld	r24, Z
     c90:	91 81       	ldd	r25, Z+1	; 0x01
     c92:	8d 93       	st	X+, r24
     c94:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     c96:	82 81       	ldd	r24, Z+2	; 0x02
     c98:	93 81       	ldd	r25, Z+3	; 0x03
     c9a:	82 1b       	sub	r24, r18
     c9c:	93 0b       	sbc	r25, r19
     c9e:	8b 30       	cpi	r24, 0x0B	; 11
     ca0:	91 05       	cpc	r25, r1
     ca2:	10 f1       	brcs	.+68     	; 0xce8 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     ca4:	bf 01       	movw	r22, r30
     ca6:	62 0f       	add	r22, r18
     ca8:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     caa:	db 01       	movw	r26, r22
     cac:	12 96       	adiw	r26, 0x02	; 2
     cae:	8d 93       	st	X+, r24
     cb0:	9c 93       	st	X, r25
     cb2:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     cb4:	22 83       	std	Z+2, r18	; 0x02
     cb6:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     cb8:	12 96       	adiw	r26, 0x02	; 2
     cba:	4d 91       	ld	r20, X+
     cbc:	5c 91       	ld	r21, X
     cbe:	13 97       	sbiw	r26, 0x03	; 3
     cc0:	85 ee       	ldi	r24, 0xE5	; 229
     cc2:	90 e2       	ldi	r25, 0x20	; 32
     cc4:	01 c0       	rjmp	.+2      	; 0xcc8 <pvPortMalloc+0xda>
     cc6:	cd 01       	movw	r24, r26
     cc8:	ec 01       	movw	r28, r24
     cca:	a8 81       	ld	r26, Y
     ccc:	b9 81       	ldd	r27, Y+1	; 0x01
     cce:	12 96       	adiw	r26, 0x02	; 2
     cd0:	2d 91       	ld	r18, X+
     cd2:	3c 91       	ld	r19, X
     cd4:	13 97       	sbiw	r26, 0x03	; 3
     cd6:	24 17       	cp	r18, r20
     cd8:	35 07       	cpc	r19, r21
     cda:	a8 f3       	brcs	.-22     	; 0xcc6 <pvPortMalloc+0xd8>
     cdc:	eb 01       	movw	r28, r22
     cde:	a8 83       	st	Y, r26
     ce0:	b9 83       	std	Y+1, r27	; 0x01
     ce2:	dc 01       	movw	r26, r24
     ce4:	6d 93       	st	X+, r22
     ce6:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     ce8:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     cec:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     cf0:	22 81       	ldd	r18, Z+2	; 0x02
     cf2:	33 81       	ldd	r19, Z+3	; 0x03
     cf4:	82 1b       	sub	r24, r18
     cf6:	93 0b       	sbc	r25, r19
     cf8:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     cfc:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
     d00:	08 c0       	rjmp	.+16     	; 0xd12 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     d02:	00 e0       	ldi	r16, 0x00	; 0
     d04:	10 e0       	ldi	r17, 0x00	; 0
     d06:	05 c0       	rjmp	.+10     	; 0xd12 <pvPortMalloc+0x124>
     d08:	00 e0       	ldi	r16, 0x00	; 0
     d0a:	10 e0       	ldi	r17, 0x00	; 0
     d0c:	02 c0       	rjmp	.+4      	; 0xd12 <pvPortMalloc+0x124>
     d0e:	00 e0       	ldi	r16, 0x00	; 0
     d10:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     d12:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     d16:	c8 01       	movw	r24, r16
     d18:	df 91       	pop	r29
     d1a:	cf 91       	pop	r28
     d1c:	1f 91       	pop	r17
     d1e:	0f 91       	pop	r16
     d20:	08 95       	ret

00000d22 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d22:	0f 93       	push	r16
     d24:	1f 93       	push	r17
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     d2a:	00 97       	sbiw	r24, 0x00	; 0
     d2c:	41 f1       	breq	.+80     	; 0xd7e <vPortFree+0x5c>
     d2e:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     d30:	8c 01       	movw	r16, r24
     d32:	05 50       	subi	r16, 0x05	; 5
     d34:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     d36:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     d3a:	f8 01       	movw	r30, r16
     d3c:	42 81       	ldd	r20, Z+2	; 0x02
     d3e:	53 81       	ldd	r21, Z+3	; 0x03
     d40:	a5 ee       	ldi	r26, 0xE5	; 229
     d42:	b0 e2       	ldi	r27, 0x20	; 32
     d44:	01 c0       	rjmp	.+2      	; 0xd48 <vPortFree+0x26>
     d46:	df 01       	movw	r26, r30
     d48:	ed 91       	ld	r30, X+
     d4a:	fc 91       	ld	r31, X
     d4c:	11 97       	sbiw	r26, 0x01	; 1
     d4e:	22 81       	ldd	r18, Z+2	; 0x02
     d50:	33 81       	ldd	r19, Z+3	; 0x03
     d52:	24 17       	cp	r18, r20
     d54:	35 07       	cpc	r19, r21
     d56:	b8 f3       	brcs	.-18     	; 0xd46 <vPortFree+0x24>
     d58:	25 97       	sbiw	r28, 0x05	; 5
     d5a:	e8 83       	st	Y, r30
     d5c:	f9 83       	std	Y+1, r31	; 0x01
     d5e:	0d 93       	st	X+, r16
     d60:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     d62:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
     d66:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
     d6a:	8a 81       	ldd	r24, Y+2	; 0x02
     d6c:	9b 81       	ldd	r25, Y+3	; 0x03
     d6e:	82 0f       	add	r24, r18
     d70:	93 1f       	adc	r25, r19
     d72:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_start>
     d76:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__data_start+0x1>
		}
		xTaskResumeAll();
     d7a:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
	}
}
     d7e:	df 91       	pop	r29
     d80:	cf 91       	pop	r28
     d82:	1f 91       	pop	r17
     d84:	0f 91       	pop	r16
     d86:	08 95       	ret

00000d88 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     d88:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__data_start>
     d8c:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__data_start+0x1>
     d90:	08 95       	ret

00000d92 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     d92:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     d94:	03 96       	adiw	r24, 0x03	; 3
     d96:	81 83       	std	Z+1, r24	; 0x01
     d98:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     d9a:	4f ef       	ldi	r20, 0xFF	; 255
     d9c:	5f ef       	ldi	r21, 0xFF	; 255
     d9e:	ba 01       	movw	r22, r20
     da0:	43 83       	std	Z+3, r20	; 0x03
     da2:	54 83       	std	Z+4, r21	; 0x04
     da4:	65 83       	std	Z+5, r22	; 0x05
     da6:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     da8:	87 83       	std	Z+7, r24	; 0x07
     daa:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     dac:	81 87       	std	Z+9, r24	; 0x09
     dae:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     db0:	10 82       	st	Z, r1
     db2:	08 95       	ret

00000db4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     db4:	fc 01       	movw	r30, r24
     db6:	12 86       	std	Z+10, r1	; 0x0a
     db8:	13 86       	std	Z+11, r1	; 0x0b
     dba:	08 95       	ret

00000dbc <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     dbc:	cf 93       	push	r28
     dbe:	df 93       	push	r29
     dc0:	fc 01       	movw	r30, r24
     dc2:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     dc4:	21 81       	ldd	r18, Z+1	; 0x01
     dc6:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     dc8:	e9 01       	movw	r28, r18
     dca:	8c 81       	ldd	r24, Y+4	; 0x04
     dcc:	9d 81       	ldd	r25, Y+5	; 0x05
     dce:	14 96       	adiw	r26, 0x04	; 4
     dd0:	8d 93       	st	X+, r24
     dd2:	9c 93       	st	X, r25
     dd4:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
     dd6:	81 81       	ldd	r24, Z+1	; 0x01
     dd8:	92 81       	ldd	r25, Z+2	; 0x02
     dda:	16 96       	adiw	r26, 0x06	; 6
     ddc:	8d 93       	st	X+, r24
     dde:	9c 93       	st	X, r25
     de0:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     de2:	8c 81       	ldd	r24, Y+4	; 0x04
     de4:	9d 81       	ldd	r25, Y+5	; 0x05
     de6:	ec 01       	movw	r28, r24
     de8:	6e 83       	std	Y+6, r22	; 0x06
     dea:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     dec:	e9 01       	movw	r28, r18
     dee:	6c 83       	std	Y+4, r22	; 0x04
     df0:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     df2:	61 83       	std	Z+1, r22	; 0x01
     df4:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     df6:	1a 96       	adiw	r26, 0x0a	; 10
     df8:	ed 93       	st	X+, r30
     dfa:	fc 93       	st	X, r31
     dfc:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
     dfe:	80 81       	ld	r24, Z
     e00:	8f 5f       	subi	r24, 0xFF	; 255
     e02:	80 83       	st	Z, r24
}
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	08 95       	ret

00000e0a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     e0a:	0f 93       	push	r16
     e0c:	1f 93       	push	r17
     e0e:	cf 93       	push	r28
     e10:	df 93       	push	r29
     e12:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     e14:	08 81       	ld	r16, Y
     e16:	19 81       	ldd	r17, Y+1	; 0x01
     e18:	2a 81       	ldd	r18, Y+2	; 0x02
     e1a:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     e1c:	0f 3f       	cpi	r16, 0xFF	; 255
     e1e:	4f ef       	ldi	r20, 0xFF	; 255
     e20:	14 07       	cpc	r17, r20
     e22:	24 07       	cpc	r18, r20
     e24:	34 07       	cpc	r19, r20
     e26:	31 f4       	brne	.+12     	; 0xe34 <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     e28:	dc 01       	movw	r26, r24
     e2a:	19 96       	adiw	r26, 0x09	; 9
     e2c:	ed 91       	ld	r30, X+
     e2e:	fc 91       	ld	r31, X
     e30:	1a 97       	sbiw	r26, 0x0a	; 10
     e32:	1f c0       	rjmp	.+62     	; 0xe72 <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     e34:	fc 01       	movw	r30, r24
     e36:	33 96       	adiw	r30, 0x03	; 3
     e38:	dc 01       	movw	r26, r24
     e3a:	17 96       	adiw	r26, 0x07	; 7
     e3c:	4d 91       	ld	r20, X+
     e3e:	5c 91       	ld	r21, X
     e40:	18 97       	sbiw	r26, 0x08	; 8
     e42:	da 01       	movw	r26, r20
     e44:	4d 91       	ld	r20, X+
     e46:	5d 91       	ld	r21, X+
     e48:	6d 91       	ld	r22, X+
     e4a:	7c 91       	ld	r23, X
     e4c:	04 17       	cp	r16, r20
     e4e:	15 07       	cpc	r17, r21
     e50:	26 07       	cpc	r18, r22
     e52:	37 07       	cpc	r19, r23
     e54:	70 f0       	brcs	.+28     	; 0xe72 <vListInsert+0x68>
     e56:	04 80       	ldd	r0, Z+4	; 0x04
     e58:	f5 81       	ldd	r31, Z+5	; 0x05
     e5a:	e0 2d       	mov	r30, r0
     e5c:	a4 81       	ldd	r26, Z+4	; 0x04
     e5e:	b5 81       	ldd	r27, Z+5	; 0x05
     e60:	4d 91       	ld	r20, X+
     e62:	5d 91       	ld	r21, X+
     e64:	6d 91       	ld	r22, X+
     e66:	7c 91       	ld	r23, X
     e68:	04 17       	cp	r16, r20
     e6a:	15 07       	cpc	r17, r21
     e6c:	26 07       	cpc	r18, r22
     e6e:	37 07       	cpc	r19, r23
     e70:	90 f7       	brcc	.-28     	; 0xe56 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     e72:	a4 81       	ldd	r26, Z+4	; 0x04
     e74:	b5 81       	ldd	r27, Z+5	; 0x05
     e76:	ac 83       	std	Y+4, r26	; 0x04
     e78:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     e7a:	16 96       	adiw	r26, 0x06	; 6
     e7c:	cd 93       	st	X+, r28
     e7e:	dc 93       	st	X, r29
     e80:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
     e82:	ee 83       	std	Y+6, r30	; 0x06
     e84:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     e86:	c4 83       	std	Z+4, r28	; 0x04
     e88:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     e8a:	8a 87       	std	Y+10, r24	; 0x0a
     e8c:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
     e8e:	fc 01       	movw	r30, r24
     e90:	20 81       	ld	r18, Z
     e92:	2f 5f       	subi	r18, 0xFF	; 255
     e94:	20 83       	st	Z, r18
}
     e96:	df 91       	pop	r29
     e98:	cf 91       	pop	r28
     e9a:	1f 91       	pop	r17
     e9c:	0f 91       	pop	r16
     e9e:	08 95       	ret

00000ea0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     ea0:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     ea2:	a4 81       	ldd	r26, Z+4	; 0x04
     ea4:	b5 81       	ldd	r27, Z+5	; 0x05
     ea6:	86 81       	ldd	r24, Z+6	; 0x06
     ea8:	97 81       	ldd	r25, Z+7	; 0x07
     eaa:	16 96       	adiw	r26, 0x06	; 6
     eac:	8d 93       	st	X+, r24
     eae:	9c 93       	st	X, r25
     eb0:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     eb2:	a6 81       	ldd	r26, Z+6	; 0x06
     eb4:	b7 81       	ldd	r27, Z+7	; 0x07
     eb6:	84 81       	ldd	r24, Z+4	; 0x04
     eb8:	95 81       	ldd	r25, Z+5	; 0x05
     eba:	14 96       	adiw	r26, 0x04	; 4
     ebc:	8d 93       	st	X+, r24
     ebe:	9c 93       	st	X, r25
     ec0:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ec2:	a2 85       	ldd	r26, Z+10	; 0x0a
     ec4:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ec6:	11 96       	adiw	r26, 0x01	; 1
     ec8:	8d 91       	ld	r24, X+
     eca:	9c 91       	ld	r25, X
     ecc:	12 97       	sbiw	r26, 0x02	; 2
     ece:	e8 17       	cp	r30, r24
     ed0:	f9 07       	cpc	r31, r25
     ed2:	31 f4       	brne	.+12     	; 0xee0 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ed4:	86 81       	ldd	r24, Z+6	; 0x06
     ed6:	97 81       	ldd	r25, Z+7	; 0x07
     ed8:	11 96       	adiw	r26, 0x01	; 1
     eda:	8d 93       	st	X+, r24
     edc:	9c 93       	st	X, r25
     ede:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
     ee0:	12 86       	std	Z+10, r1	; 0x0a
     ee2:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
     ee4:	8c 91       	ld	r24, X
     ee6:	81 50       	subi	r24, 0x01	; 1
     ee8:	8c 93       	st	X, r24
     eea:	08 95       	ret

00000eec <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     eec:	80 93 6b 42 	sts	0x426B, r24	; 0x80426b <portStackTopForTask>
     ef0:	90 93 6c 42 	sts	0x426C, r25	; 0x80426c <portStackTopForTask+0x1>
     ef4:	31 e1       	ldi	r19, 0x11	; 17
     ef6:	fc 01       	movw	r30, r24
     ef8:	30 83       	st	Z, r19
     efa:	31 97       	sbiw	r30, 0x01	; 1
     efc:	22 e2       	ldi	r18, 0x22	; 34
     efe:	20 83       	st	Z, r18
     f00:	31 97       	sbiw	r30, 0x01	; 1
     f02:	a3 e3       	ldi	r26, 0x33	; 51
     f04:	a0 83       	st	Z, r26
     f06:	31 97       	sbiw	r30, 0x01	; 1
     f08:	60 83       	st	Z, r22
     f0a:	31 97       	sbiw	r30, 0x01	; 1
     f0c:	70 83       	st	Z, r23
     f0e:	31 97       	sbiw	r30, 0x01	; 1
     f10:	10 82       	st	Z, r1
     f12:	31 97       	sbiw	r30, 0x01	; 1
     f14:	10 82       	st	Z, r1
     f16:	31 97       	sbiw	r30, 0x01	; 1
     f18:	60 e8       	ldi	r22, 0x80	; 128
     f1a:	60 83       	st	Z, r22
     f1c:	31 97       	sbiw	r30, 0x01	; 1
     f1e:	10 82       	st	Z, r1
     f20:	31 97       	sbiw	r30, 0x01	; 1
     f22:	10 82       	st	Z, r1
     f24:	31 97       	sbiw	r30, 0x01	; 1
     f26:	10 82       	st	Z, r1
     f28:	31 97       	sbiw	r30, 0x01	; 1
     f2a:	62 e0       	ldi	r22, 0x02	; 2
     f2c:	60 83       	st	Z, r22
     f2e:	31 97       	sbiw	r30, 0x01	; 1
     f30:	63 e0       	ldi	r22, 0x03	; 3
     f32:	60 83       	st	Z, r22
     f34:	31 97       	sbiw	r30, 0x01	; 1
     f36:	64 e0       	ldi	r22, 0x04	; 4
     f38:	60 83       	st	Z, r22
     f3a:	31 97       	sbiw	r30, 0x01	; 1
     f3c:	65 e0       	ldi	r22, 0x05	; 5
     f3e:	60 83       	st	Z, r22
     f40:	31 97       	sbiw	r30, 0x01	; 1
     f42:	66 e0       	ldi	r22, 0x06	; 6
     f44:	60 83       	st	Z, r22
     f46:	31 97       	sbiw	r30, 0x01	; 1
     f48:	67 e0       	ldi	r22, 0x07	; 7
     f4a:	60 83       	st	Z, r22
     f4c:	31 97       	sbiw	r30, 0x01	; 1
     f4e:	68 e0       	ldi	r22, 0x08	; 8
     f50:	60 83       	st	Z, r22
     f52:	31 97       	sbiw	r30, 0x01	; 1
     f54:	69 e0       	ldi	r22, 0x09	; 9
     f56:	60 83       	st	Z, r22
     f58:	31 97       	sbiw	r30, 0x01	; 1
     f5a:	60 e1       	ldi	r22, 0x10	; 16
     f5c:	60 83       	st	Z, r22
     f5e:	31 97       	sbiw	r30, 0x01	; 1
     f60:	30 83       	st	Z, r19
     f62:	31 97       	sbiw	r30, 0x01	; 1
     f64:	32 e1       	ldi	r19, 0x12	; 18
     f66:	30 83       	st	Z, r19
     f68:	31 97       	sbiw	r30, 0x01	; 1
     f6a:	33 e1       	ldi	r19, 0x13	; 19
     f6c:	30 83       	st	Z, r19
     f6e:	31 97       	sbiw	r30, 0x01	; 1
     f70:	34 e1       	ldi	r19, 0x14	; 20
     f72:	30 83       	st	Z, r19
     f74:	31 97       	sbiw	r30, 0x01	; 1
     f76:	35 e1       	ldi	r19, 0x15	; 21
     f78:	30 83       	st	Z, r19
     f7a:	31 97       	sbiw	r30, 0x01	; 1
     f7c:	36 e1       	ldi	r19, 0x16	; 22
     f7e:	30 83       	st	Z, r19
     f80:	31 97       	sbiw	r30, 0x01	; 1
     f82:	37 e1       	ldi	r19, 0x17	; 23
     f84:	30 83       	st	Z, r19
     f86:	31 97       	sbiw	r30, 0x01	; 1
     f88:	38 e1       	ldi	r19, 0x18	; 24
     f8a:	30 83       	st	Z, r19
     f8c:	31 97       	sbiw	r30, 0x01	; 1
     f8e:	39 e1       	ldi	r19, 0x19	; 25
     f90:	30 83       	st	Z, r19
     f92:	31 97       	sbiw	r30, 0x01	; 1
     f94:	30 e2       	ldi	r19, 0x20	; 32
     f96:	30 83       	st	Z, r19
     f98:	31 97       	sbiw	r30, 0x01	; 1
     f9a:	31 e2       	ldi	r19, 0x21	; 33
     f9c:	30 83       	st	Z, r19
     f9e:	31 97       	sbiw	r30, 0x01	; 1
     fa0:	20 83       	st	Z, r18
     fa2:	31 97       	sbiw	r30, 0x01	; 1
     fa4:	23 e2       	ldi	r18, 0x23	; 35
     fa6:	20 83       	st	Z, r18
     fa8:	31 97       	sbiw	r30, 0x01	; 1
     faa:	40 83       	st	Z, r20
     fac:	31 97       	sbiw	r30, 0x01	; 1
     fae:	50 83       	st	Z, r21
     fb0:	31 97       	sbiw	r30, 0x01	; 1
     fb2:	26 e2       	ldi	r18, 0x26	; 38
     fb4:	20 83       	st	Z, r18
     fb6:	31 97       	sbiw	r30, 0x01	; 1
     fb8:	27 e2       	ldi	r18, 0x27	; 39
     fba:	20 83       	st	Z, r18
     fbc:	31 97       	sbiw	r30, 0x01	; 1
     fbe:	28 e2       	ldi	r18, 0x28	; 40
     fc0:	20 83       	st	Z, r18
     fc2:	31 97       	sbiw	r30, 0x01	; 1
     fc4:	29 e2       	ldi	r18, 0x29	; 41
     fc6:	20 83       	st	Z, r18
     fc8:	31 97       	sbiw	r30, 0x01	; 1
     fca:	20 e3       	ldi	r18, 0x30	; 48
     fcc:	20 83       	st	Z, r18
     fce:	31 97       	sbiw	r30, 0x01	; 1
     fd0:	21 e3       	ldi	r18, 0x31	; 49
     fd2:	20 83       	st	Z, r18
     fd4:	89 97       	sbiw	r24, 0x29	; 41
     fd6:	08 95       	ret

00000fd8 <xPortStartScheduler>:
     fd8:	8c e7       	ldi	r24, 0x7C	; 124
     fda:	80 93 69 0a 	sts	0x0A69, r24	; 0x800a69 <__TEXT_REGION_LENGTH__+0x700a69>
     fde:	8f ef       	ldi	r24, 0xFF	; 255
     fe0:	80 93 68 0a 	sts	0x0A68, r24	; 0x800a68 <__TEXT_REGION_LENGTH__+0x700a68>
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	80 93 40 0a 	sts	0x0A40, r24	; 0x800a40 <__TEXT_REGION_LENGTH__+0x700a40>
     fea:	81 e1       	ldi	r24, 0x11	; 17
     fec:	80 93 41 0a 	sts	0x0A41, r24	; 0x800a41 <__TEXT_REGION_LENGTH__+0x700a41>
     ff0:	83 e0       	ldi	r24, 0x03	; 3
     ff2:	80 93 47 0a 	sts	0x0A47, r24	; 0x800a47 <__TEXT_REGION_LENGTH__+0x700a47>
     ff6:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
     ffa:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
     ffe:	cd 91       	ld	r28, X+
    1000:	cd bf       	out	0x3d, r28	; 61
    1002:	dd 91       	ld	r29, X+
    1004:	de bf       	out	0x3e, r29	; 62
    1006:	ff 91       	pop	r31
    1008:	ef 91       	pop	r30
    100a:	df 91       	pop	r29
    100c:	cf 91       	pop	r28
    100e:	bf 91       	pop	r27
    1010:	af 91       	pop	r26
    1012:	9f 91       	pop	r25
    1014:	8f 91       	pop	r24
    1016:	7f 91       	pop	r23
    1018:	6f 91       	pop	r22
    101a:	5f 91       	pop	r21
    101c:	4f 91       	pop	r20
    101e:	3f 91       	pop	r19
    1020:	2f 91       	pop	r18
    1022:	1f 91       	pop	r17
    1024:	0f 91       	pop	r16
    1026:	ff 90       	pop	r15
    1028:	ef 90       	pop	r14
    102a:	df 90       	pop	r13
    102c:	cf 90       	pop	r12
    102e:	bf 90       	pop	r11
    1030:	af 90       	pop	r10
    1032:	9f 90       	pop	r9
    1034:	8f 90       	pop	r8
    1036:	7f 90       	pop	r7
    1038:	6f 90       	pop	r6
    103a:	5f 90       	pop	r5
    103c:	4f 90       	pop	r4
    103e:	3f 90       	pop	r3
    1040:	2f 90       	pop	r2
    1042:	1f 90       	pop	r1
    1044:	0f 90       	pop	r0
    1046:	0c be       	out	0x3c, r0	; 60
    1048:	0f 90       	pop	r0
    104a:	0b be       	out	0x3b, r0	; 59
    104c:	0f 90       	pop	r0
    104e:	0f be       	out	0x3f, r0	; 63
    1050:	0f 90       	pop	r0
    1052:	08 95       	ret
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	08 95       	ret

00001058 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1058:	0f 92       	push	r0
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	0f 92       	push	r0
    1060:	0b b6       	in	r0, 0x3b	; 59
    1062:	0f 92       	push	r0
    1064:	0c b6       	in	r0, 0x3c	; 60
    1066:	0f 92       	push	r0
    1068:	1f 92       	push	r1
    106a:	11 24       	eor	r1, r1
    106c:	2f 92       	push	r2
    106e:	3f 92       	push	r3
    1070:	4f 92       	push	r4
    1072:	5f 92       	push	r5
    1074:	6f 92       	push	r6
    1076:	7f 92       	push	r7
    1078:	8f 92       	push	r8
    107a:	9f 92       	push	r9
    107c:	af 92       	push	r10
    107e:	bf 92       	push	r11
    1080:	cf 92       	push	r12
    1082:	df 92       	push	r13
    1084:	ef 92       	push	r14
    1086:	ff 92       	push	r15
    1088:	0f 93       	push	r16
    108a:	1f 93       	push	r17
    108c:	2f 93       	push	r18
    108e:	3f 93       	push	r19
    1090:	4f 93       	push	r20
    1092:	5f 93       	push	r21
    1094:	6f 93       	push	r22
    1096:	7f 93       	push	r23
    1098:	8f 93       	push	r24
    109a:	9f 93       	push	r25
    109c:	af 93       	push	r26
    109e:	bf 93       	push	r27
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	ef 93       	push	r30
    10a6:	ff 93       	push	r31
    10a8:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    10ac:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    10b0:	0d b6       	in	r0, 0x3d	; 61
    10b2:	0d 92       	st	X+, r0
    10b4:	0e b6       	in	r0, 0x3e	; 62
    10b6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    10b8:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    10bc:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    10c0:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    10c4:	cd 91       	ld	r28, X+
    10c6:	cd bf       	out	0x3d, r28	; 61
    10c8:	dd 91       	ld	r29, X+
    10ca:	de bf       	out	0x3e, r29	; 62
    10cc:	ff 91       	pop	r31
    10ce:	ef 91       	pop	r30
    10d0:	df 91       	pop	r29
    10d2:	cf 91       	pop	r28
    10d4:	bf 91       	pop	r27
    10d6:	af 91       	pop	r26
    10d8:	9f 91       	pop	r25
    10da:	8f 91       	pop	r24
    10dc:	7f 91       	pop	r23
    10de:	6f 91       	pop	r22
    10e0:	5f 91       	pop	r21
    10e2:	4f 91       	pop	r20
    10e4:	3f 91       	pop	r19
    10e6:	2f 91       	pop	r18
    10e8:	1f 91       	pop	r17
    10ea:	0f 91       	pop	r16
    10ec:	ff 90       	pop	r15
    10ee:	ef 90       	pop	r14
    10f0:	df 90       	pop	r13
    10f2:	cf 90       	pop	r12
    10f4:	bf 90       	pop	r11
    10f6:	af 90       	pop	r10
    10f8:	9f 90       	pop	r9
    10fa:	8f 90       	pop	r8
    10fc:	7f 90       	pop	r7
    10fe:	6f 90       	pop	r6
    1100:	5f 90       	pop	r5
    1102:	4f 90       	pop	r4
    1104:	3f 90       	pop	r3
    1106:	2f 90       	pop	r2
    1108:	1f 90       	pop	r1
    110a:	0f 90       	pop	r0
    110c:	0c be       	out	0x3c, r0	; 60
    110e:	0f 90       	pop	r0
    1110:	0b be       	out	0x3b, r0	; 59
    1112:	0f 90       	pop	r0
    1114:	0f be       	out	0x3f, r0	; 63
    1116:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1118:	08 95       	ret

0000111a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    111a:	0f 92       	push	r0
    111c:	0f b6       	in	r0, 0x3f	; 63
    111e:	f8 94       	cli
    1120:	0f 92       	push	r0
    1122:	0b b6       	in	r0, 0x3b	; 59
    1124:	0f 92       	push	r0
    1126:	0c b6       	in	r0, 0x3c	; 60
    1128:	0f 92       	push	r0
    112a:	1f 92       	push	r1
    112c:	11 24       	eor	r1, r1
    112e:	2f 92       	push	r2
    1130:	3f 92       	push	r3
    1132:	4f 92       	push	r4
    1134:	5f 92       	push	r5
    1136:	6f 92       	push	r6
    1138:	7f 92       	push	r7
    113a:	8f 92       	push	r8
    113c:	9f 92       	push	r9
    113e:	af 92       	push	r10
    1140:	bf 92       	push	r11
    1142:	cf 92       	push	r12
    1144:	df 92       	push	r13
    1146:	ef 92       	push	r14
    1148:	ff 92       	push	r15
    114a:	0f 93       	push	r16
    114c:	1f 93       	push	r17
    114e:	2f 93       	push	r18
    1150:	3f 93       	push	r19
    1152:	4f 93       	push	r20
    1154:	5f 93       	push	r21
    1156:	6f 93       	push	r22
    1158:	7f 93       	push	r23
    115a:	8f 93       	push	r24
    115c:	9f 93       	push	r25
    115e:	af 93       	push	r26
    1160:	bf 93       	push	r27
    1162:	cf 93       	push	r28
    1164:	df 93       	push	r29
    1166:	ef 93       	push	r30
    1168:	ff 93       	push	r31
    116a:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    116e:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1172:	0d b6       	in	r0, 0x3d	; 61
    1174:	0d 92       	st	X+, r0
    1176:	0e b6       	in	r0, 0x3e	; 62
    1178:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    117a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vTaskIncrementTick>
	vTaskSwitchContext();
    117e:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1182:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    1186:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    118a:	cd 91       	ld	r28, X+
    118c:	cd bf       	out	0x3d, r28	; 61
    118e:	dd 91       	ld	r29, X+
    1190:	de bf       	out	0x3e, r29	; 62
    1192:	ff 91       	pop	r31
    1194:	ef 91       	pop	r30
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	bf 91       	pop	r27
    119c:	af 91       	pop	r26
    119e:	9f 91       	pop	r25
    11a0:	8f 91       	pop	r24
    11a2:	7f 91       	pop	r23
    11a4:	6f 91       	pop	r22
    11a6:	5f 91       	pop	r21
    11a8:	4f 91       	pop	r20
    11aa:	3f 91       	pop	r19
    11ac:	2f 91       	pop	r18
    11ae:	1f 91       	pop	r17
    11b0:	0f 91       	pop	r16
    11b2:	ff 90       	pop	r15
    11b4:	ef 90       	pop	r14
    11b6:	df 90       	pop	r13
    11b8:	cf 90       	pop	r12
    11ba:	bf 90       	pop	r11
    11bc:	af 90       	pop	r10
    11be:	9f 90       	pop	r9
    11c0:	8f 90       	pop	r8
    11c2:	7f 90       	pop	r7
    11c4:	6f 90       	pop	r6
    11c6:	5f 90       	pop	r5
    11c8:	4f 90       	pop	r4
    11ca:	3f 90       	pop	r3
    11cc:	2f 90       	pop	r2
    11ce:	1f 90       	pop	r1
    11d0:	0f 90       	pop	r0
    11d2:	0c be       	out	0x3c, r0	; 60
    11d4:	0f 90       	pop	r0
    11d6:	0b be       	out	0x3b, r0	; 59
    11d8:	0f 90       	pop	r0
    11da:	0f be       	out	0x3f, r0	; 63
    11dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    11de:	08 95       	ret

000011e0 <__vector_55>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    11e0:	0e 94 8d 08 	call	0x111a	; 0x111a <vPortYieldFromTick>
		asm volatile ( "reti" );
    11e4:	18 95       	reti

000011e6 <prvCopyDataToQueue>:
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
    11ea:	ec 01       	movw	r28, r24
    11ec:	88 a1       	ldd	r24, Y+32	; 0x20
    11ee:	81 11       	cpse	r24, r1
    11f0:	0b c0       	rjmp	.+22     	; 0x1208 <prvCopyDataToQueue+0x22>
    11f2:	88 81       	ld	r24, Y
    11f4:	99 81       	ldd	r25, Y+1	; 0x01
    11f6:	89 2b       	or	r24, r25
    11f8:	e1 f5       	brne	.+120    	; 0x1272 <prvCopyDataToQueue+0x8c>
    11fa:	8a 81       	ldd	r24, Y+2	; 0x02
    11fc:	9b 81       	ldd	r25, Y+3	; 0x03
    11fe:	0e 94 63 11 	call	0x22c6	; 0x22c6 <vTaskPriorityDisinherit>
    1202:	1a 82       	std	Y+2, r1	; 0x02
    1204:	1b 82       	std	Y+3, r1	; 0x03
    1206:	35 c0       	rjmp	.+106    	; 0x1272 <prvCopyDataToQueue+0x8c>
    1208:	41 11       	cpse	r20, r1
    120a:	17 c0       	rjmp	.+46     	; 0x123a <prvCopyDataToQueue+0x54>
    120c:	48 2f       	mov	r20, r24
    120e:	50 e0       	ldi	r21, 0x00	; 0
    1210:	8c 81       	ldd	r24, Y+4	; 0x04
    1212:	9d 81       	ldd	r25, Y+5	; 0x05
    1214:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <memcpy>
    1218:	28 a1       	ldd	r18, Y+32	; 0x20
    121a:	8c 81       	ldd	r24, Y+4	; 0x04
    121c:	9d 81       	ldd	r25, Y+5	; 0x05
    121e:	82 0f       	add	r24, r18
    1220:	91 1d       	adc	r25, r1
    1222:	8c 83       	std	Y+4, r24	; 0x04
    1224:	9d 83       	std	Y+5, r25	; 0x05
    1226:	2a 81       	ldd	r18, Y+2	; 0x02
    1228:	3b 81       	ldd	r19, Y+3	; 0x03
    122a:	82 17       	cp	r24, r18
    122c:	93 07       	cpc	r25, r19
    122e:	08 f1       	brcs	.+66     	; 0x1272 <prvCopyDataToQueue+0x8c>
    1230:	88 81       	ld	r24, Y
    1232:	99 81       	ldd	r25, Y+1	; 0x01
    1234:	8c 83       	std	Y+4, r24	; 0x04
    1236:	9d 83       	std	Y+5, r25	; 0x05
    1238:	1c c0       	rjmp	.+56     	; 0x1272 <prvCopyDataToQueue+0x8c>
    123a:	48 2f       	mov	r20, r24
    123c:	50 e0       	ldi	r21, 0x00	; 0
    123e:	8e 81       	ldd	r24, Y+6	; 0x06
    1240:	9f 81       	ldd	r25, Y+7	; 0x07
    1242:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <memcpy>
    1246:	88 a1       	ldd	r24, Y+32	; 0x20
    1248:	90 e0       	ldi	r25, 0x00	; 0
    124a:	91 95       	neg	r25
    124c:	81 95       	neg	r24
    124e:	91 09       	sbc	r25, r1
    1250:	2e 81       	ldd	r18, Y+6	; 0x06
    1252:	3f 81       	ldd	r19, Y+7	; 0x07
    1254:	28 0f       	add	r18, r24
    1256:	39 1f       	adc	r19, r25
    1258:	2e 83       	std	Y+6, r18	; 0x06
    125a:	3f 83       	std	Y+7, r19	; 0x07
    125c:	48 81       	ld	r20, Y
    125e:	59 81       	ldd	r21, Y+1	; 0x01
    1260:	24 17       	cp	r18, r20
    1262:	35 07       	cpc	r19, r21
    1264:	30 f4       	brcc	.+12     	; 0x1272 <prvCopyDataToQueue+0x8c>
    1266:	2a 81       	ldd	r18, Y+2	; 0x02
    1268:	3b 81       	ldd	r19, Y+3	; 0x03
    126a:	82 0f       	add	r24, r18
    126c:	93 1f       	adc	r25, r19
    126e:	8e 83       	std	Y+6, r24	; 0x06
    1270:	9f 83       	std	Y+7, r25	; 0x07
    1272:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1274:	8f 5f       	subi	r24, 0xFF	; 255
    1276:	8e 8f       	std	Y+30, r24	; 0x1e
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	08 95       	ret

0000127e <prvCopyDataFromQueue>:
    127e:	fc 01       	movw	r30, r24
    1280:	80 81       	ld	r24, Z
    1282:	91 81       	ldd	r25, Z+1	; 0x01
    1284:	00 97       	sbiw	r24, 0x00	; 0
    1286:	a1 f0       	breq	.+40     	; 0x12b0 <prvCopyDataFromQueue+0x32>
    1288:	40 a1       	ldd	r20, Z+32	; 0x20
    128a:	50 e0       	ldi	r21, 0x00	; 0
    128c:	26 81       	ldd	r18, Z+6	; 0x06
    128e:	37 81       	ldd	r19, Z+7	; 0x07
    1290:	24 0f       	add	r18, r20
    1292:	35 1f       	adc	r19, r21
    1294:	26 83       	std	Z+6, r18	; 0x06
    1296:	37 83       	std	Z+7, r19	; 0x07
    1298:	a2 81       	ldd	r26, Z+2	; 0x02
    129a:	b3 81       	ldd	r27, Z+3	; 0x03
    129c:	2a 17       	cp	r18, r26
    129e:	3b 07       	cpc	r19, r27
    12a0:	10 f0       	brcs	.+4      	; 0x12a6 <prvCopyDataFromQueue+0x28>
    12a2:	86 83       	std	Z+6, r24	; 0x06
    12a4:	97 83       	std	Z+7, r25	; 0x07
    12a6:	cb 01       	movw	r24, r22
    12a8:	66 81       	ldd	r22, Z+6	; 0x06
    12aa:	77 81       	ldd	r23, Z+7	; 0x07
    12ac:	0e 94 f9 24 	call	0x49f2	; 0x49f2 <memcpy>
    12b0:	08 95       	ret

000012b2 <prvUnlockQueue>:
    12b2:	0f 93       	push	r16
    12b4:	1f 93       	push	r17
    12b6:	cf 93       	push	r28
    12b8:	df 93       	push	r29
    12ba:	ec 01       	movw	r28, r24
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	f8 94       	cli
    12c0:	0f 92       	push	r0
    12c2:	8a a1       	ldd	r24, Y+34	; 0x22
    12c4:	18 16       	cp	r1, r24
    12c6:	b4 f4       	brge	.+44     	; 0x12f4 <prvUnlockQueue+0x42>
    12c8:	8b 89       	ldd	r24, Y+19	; 0x13
    12ca:	81 11       	cpse	r24, r1
    12cc:	05 c0       	rjmp	.+10     	; 0x12d8 <prvUnlockQueue+0x26>
    12ce:	12 c0       	rjmp	.+36     	; 0x12f4 <prvUnlockQueue+0x42>
    12d0:	8b 89       	ldd	r24, Y+19	; 0x13
    12d2:	81 11       	cpse	r24, r1
    12d4:	04 c0       	rjmp	.+8      	; 0x12de <prvUnlockQueue+0x2c>
    12d6:	0e c0       	rjmp	.+28     	; 0x12f4 <prvUnlockQueue+0x42>
    12d8:	8e 01       	movw	r16, r28
    12da:	0d 5e       	subi	r16, 0xED	; 237
    12dc:	1f 4f       	sbci	r17, 0xFF	; 255
    12de:	c8 01       	movw	r24, r16
    12e0:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    12e4:	81 11       	cpse	r24, r1
    12e6:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskMissedYield>
    12ea:	8a a1       	ldd	r24, Y+34	; 0x22
    12ec:	81 50       	subi	r24, 0x01	; 1
    12ee:	8a a3       	std	Y+34, r24	; 0x22
    12f0:	18 16       	cp	r1, r24
    12f2:	74 f3       	brlt	.-36     	; 0x12d0 <prvUnlockQueue+0x1e>
    12f4:	8f ef       	ldi	r24, 0xFF	; 255
    12f6:	8a a3       	std	Y+34, r24	; 0x22
    12f8:	0f 90       	pop	r0
    12fa:	0f be       	out	0x3f, r0	; 63
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	f8 94       	cli
    1300:	0f 92       	push	r0
    1302:	89 a1       	ldd	r24, Y+33	; 0x21
    1304:	18 16       	cp	r1, r24
    1306:	b4 f4       	brge	.+44     	; 0x1334 <prvUnlockQueue+0x82>
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	81 11       	cpse	r24, r1
    130c:	05 c0       	rjmp	.+10     	; 0x1318 <prvUnlockQueue+0x66>
    130e:	12 c0       	rjmp	.+36     	; 0x1334 <prvUnlockQueue+0x82>
    1310:	88 85       	ldd	r24, Y+8	; 0x08
    1312:	81 11       	cpse	r24, r1
    1314:	04 c0       	rjmp	.+8      	; 0x131e <prvUnlockQueue+0x6c>
    1316:	0e c0       	rjmp	.+28     	; 0x1334 <prvUnlockQueue+0x82>
    1318:	8e 01       	movw	r16, r28
    131a:	08 5f       	subi	r16, 0xF8	; 248
    131c:	1f 4f       	sbci	r17, 0xFF	; 255
    131e:	c8 01       	movw	r24, r16
    1320:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    1324:	81 11       	cpse	r24, r1
    1326:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vTaskMissedYield>
    132a:	89 a1       	ldd	r24, Y+33	; 0x21
    132c:	81 50       	subi	r24, 0x01	; 1
    132e:	89 a3       	std	Y+33, r24	; 0x21
    1330:	18 16       	cp	r1, r24
    1332:	74 f3       	brlt	.-36     	; 0x1310 <prvUnlockQueue+0x5e>
    1334:	8f ef       	ldi	r24, 0xFF	; 255
    1336:	89 a3       	std	Y+33, r24	; 0x21
    1338:	0f 90       	pop	r0
    133a:	0f be       	out	0x3f, r0	; 63
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	1f 91       	pop	r17
    1342:	0f 91       	pop	r16
    1344:	08 95       	ret

00001346 <xQueueGenericReset>:
    1346:	1f 93       	push	r17
    1348:	cf 93       	push	r28
    134a:	df 93       	push	r29
    134c:	61 30       	cpi	r22, 0x01	; 1
    134e:	59 f0       	breq	.+22     	; 0x1366 <xQueueGenericReset+0x20>
    1350:	fc 01       	movw	r30, r24
    1352:	23 89       	ldd	r18, Z+19	; 0x13
    1354:	30 85       	ldd	r19, Z+8	; 0x08
    1356:	31 11       	cpse	r19, r1
    1358:	2c c0       	rjmp	.+88     	; 0x13b2 <xQueueGenericReset+0x6c>
    135a:	11 e0       	ldi	r17, 0x01	; 1
    135c:	21 11       	cpse	r18, r1
    135e:	10 e0       	ldi	r17, 0x00	; 0
    1360:	21 11       	cpse	r18, r1
    1362:	28 c0       	rjmp	.+80     	; 0x13b4 <xQueueGenericReset+0x6e>
    1364:	01 c0       	rjmp	.+2      	; 0x1368 <xQueueGenericReset+0x22>
    1366:	11 e0       	ldi	r17, 0x01	; 1
    1368:	ec 01       	movw	r28, r24
    136a:	48 81       	ld	r20, Y
    136c:	59 81       	ldd	r21, Y+1	; 0x01
    136e:	28 a1       	ldd	r18, Y+32	; 0x20
    1370:	30 e0       	ldi	r19, 0x00	; 0
    1372:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1374:	62 9f       	mul	r22, r18
    1376:	c0 01       	movw	r24, r0
    1378:	63 9f       	mul	r22, r19
    137a:	90 0d       	add	r25, r0
    137c:	11 24       	eor	r1, r1
    137e:	ba 01       	movw	r22, r20
    1380:	68 0f       	add	r22, r24
    1382:	79 1f       	adc	r23, r25
    1384:	6a 83       	std	Y+2, r22	; 0x02
    1386:	7b 83       	std	Y+3, r23	; 0x03
    1388:	1e 8e       	std	Y+30, r1	; 0x1e
    138a:	4c 83       	std	Y+4, r20	; 0x04
    138c:	5d 83       	std	Y+5, r21	; 0x05
    138e:	82 1b       	sub	r24, r18
    1390:	93 0b       	sbc	r25, r19
    1392:	84 0f       	add	r24, r20
    1394:	95 1f       	adc	r25, r21
    1396:	8e 83       	std	Y+6, r24	; 0x06
    1398:	9f 83       	std	Y+7, r25	; 0x07
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	89 a3       	std	Y+33, r24	; 0x21
    139e:	8a a3       	std	Y+34, r24	; 0x22
    13a0:	ce 01       	movw	r24, r28
    13a2:	08 96       	adiw	r24, 0x08	; 8
    13a4:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    13a8:	ce 01       	movw	r24, r28
    13aa:	43 96       	adiw	r24, 0x13	; 19
    13ac:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    13b0:	01 c0       	rjmp	.+2      	; 0x13b4 <xQueueGenericReset+0x6e>
    13b2:	10 e0       	ldi	r17, 0x00	; 0
    13b4:	81 2f       	mov	r24, r17
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	08 95       	ret

000013be <xQueueGenericCreate>:
    13be:	0f 93       	push	r16
    13c0:	1f 93       	push	r17
    13c2:	cf 93       	push	r28
    13c4:	df 93       	push	r29
    13c6:	88 23       	and	r24, r24
    13c8:	01 f1       	breq	.+64     	; 0x140a <xQueueGenericCreate+0x4c>
    13ca:	06 2f       	mov	r16, r22
    13cc:	18 2f       	mov	r17, r24
    13ce:	83 e2       	ldi	r24, 0x23	; 35
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	0e 94 f7 05 	call	0xbee	; 0xbee <pvPortMalloc>
    13d6:	ec 01       	movw	r28, r24
    13d8:	89 2b       	or	r24, r25
    13da:	c9 f0       	breq	.+50     	; 0x140e <xQueueGenericCreate+0x50>
    13dc:	10 9f       	mul	r17, r16
    13de:	c0 01       	movw	r24, r0
    13e0:	11 24       	eor	r1, r1
    13e2:	01 96       	adiw	r24, 0x01	; 1
    13e4:	0e 94 f7 05 	call	0xbee	; 0xbee <pvPortMalloc>
    13e8:	88 83       	st	Y, r24
    13ea:	99 83       	std	Y+1, r25	; 0x01
    13ec:	89 2b       	or	r24, r25
    13ee:	39 f0       	breq	.+14     	; 0x13fe <xQueueGenericCreate+0x40>
    13f0:	1f 8f       	std	Y+31, r17	; 0x1f
    13f2:	08 a3       	std	Y+32, r16	; 0x20
    13f4:	61 e0       	ldi	r22, 0x01	; 1
    13f6:	ce 01       	movw	r24, r28
    13f8:	0e 94 a3 09 	call	0x1346	; 0x1346 <xQueueGenericReset>
    13fc:	08 c0       	rjmp	.+16     	; 0x140e <xQueueGenericCreate+0x50>
    13fe:	ce 01       	movw	r24, r28
    1400:	0e 94 91 06 	call	0xd22	; 0xd22 <vPortFree>
    1404:	c0 e0       	ldi	r28, 0x00	; 0
    1406:	d0 e0       	ldi	r29, 0x00	; 0
    1408:	02 c0       	rjmp	.+4      	; 0x140e <xQueueGenericCreate+0x50>
    140a:	c0 e0       	ldi	r28, 0x00	; 0
    140c:	d0 e0       	ldi	r29, 0x00	; 0
    140e:	ce 01       	movw	r24, r28
    1410:	df 91       	pop	r29
    1412:	cf 91       	pop	r28
    1414:	1f 91       	pop	r17
    1416:	0f 91       	pop	r16
    1418:	08 95       	ret

0000141a <xQueueGenericSend>:
    141a:	af 92       	push	r10
    141c:	bf 92       	push	r11
    141e:	cf 92       	push	r12
    1420:	df 92       	push	r13
    1422:	ef 92       	push	r14
    1424:	ff 92       	push	r15
    1426:	0f 93       	push	r16
    1428:	1f 93       	push	r17
    142a:	cf 93       	push	r28
    142c:	df 93       	push	r29
    142e:	cd b7       	in	r28, 0x3d	; 61
    1430:	de b7       	in	r29, 0x3e	; 62
    1432:	29 97       	sbiw	r28, 0x09	; 9
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	de bf       	out	0x3e, r29	; 62
    1438:	7c 01       	movw	r14, r24
    143a:	5b 01       	movw	r10, r22
    143c:	2e 83       	std	Y+6, r18	; 0x06
    143e:	3f 83       	std	Y+7, r19	; 0x07
    1440:	48 87       	std	Y+8, r20	; 0x08
    1442:	59 87       	std	Y+9, r21	; 0x09
    1444:	10 e0       	ldi	r17, 0x00	; 0
    1446:	6c 01       	movw	r12, r24
    1448:	88 e0       	ldi	r24, 0x08	; 8
    144a:	c8 0e       	add	r12, r24
    144c:	d1 1c       	adc	r13, r1
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	0f 92       	push	r0
    1454:	f7 01       	movw	r30, r14
    1456:	96 8d       	ldd	r25, Z+30	; 0x1e
    1458:	87 8d       	ldd	r24, Z+31	; 0x1f
    145a:	98 17       	cp	r25, r24
    145c:	a8 f4       	brcc	.+42     	; 0x1488 <xQueueGenericSend+0x6e>
    145e:	40 2f       	mov	r20, r16
    1460:	b5 01       	movw	r22, r10
    1462:	c7 01       	movw	r24, r14
    1464:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvCopyDataToQueue>
    1468:	f7 01       	movw	r30, r14
    146a:	83 89       	ldd	r24, Z+19	; 0x13
    146c:	88 23       	and	r24, r24
    146e:	41 f0       	breq	.+16     	; 0x1480 <xQueueGenericSend+0x66>
    1470:	c7 01       	movw	r24, r14
    1472:	43 96       	adiw	r24, 0x13	; 19
    1474:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    1478:	81 30       	cpi	r24, 0x01	; 1
    147a:	11 f4       	brne	.+4      	; 0x1480 <xQueueGenericSend+0x66>
    147c:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    1480:	0f 90       	pop	r0
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	56 c0       	rjmp	.+172    	; 0x1534 <xQueueGenericSend+0x11a>
    1488:	8e 81       	ldd	r24, Y+6	; 0x06
    148a:	9f 81       	ldd	r25, Y+7	; 0x07
    148c:	a8 85       	ldd	r26, Y+8	; 0x08
    148e:	b9 85       	ldd	r27, Y+9	; 0x09
    1490:	89 2b       	or	r24, r25
    1492:	8a 2b       	or	r24, r26
    1494:	8b 2b       	or	r24, r27
    1496:	21 f4       	brne	.+8      	; 0x14a0 <xQueueGenericSend+0x86>
    1498:	0f 90       	pop	r0
    149a:	0f be       	out	0x3f, r0	; 63
    149c:	80 e0       	ldi	r24, 0x00	; 0
    149e:	4a c0       	rjmp	.+148    	; 0x1534 <xQueueGenericSend+0x11a>
    14a0:	11 11       	cpse	r17, r1
    14a2:	05 c0       	rjmp	.+10     	; 0x14ae <xQueueGenericSend+0x94>
    14a4:	ce 01       	movw	r24, r28
    14a6:	01 96       	adiw	r24, 0x01	; 1
    14a8:	0e 94 6e 10 	call	0x20dc	; 0x20dc <vTaskSetTimeOutState>
    14ac:	11 e0       	ldi	r17, 0x01	; 1
    14ae:	0f 90       	pop	r0
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskSuspendAll>
    14b6:	0f b6       	in	r0, 0x3f	; 63
    14b8:	f8 94       	cli
    14ba:	0f 92       	push	r0
    14bc:	f7 01       	movw	r30, r14
    14be:	81 a1       	ldd	r24, Z+33	; 0x21
    14c0:	8f 3f       	cpi	r24, 0xFF	; 255
    14c2:	09 f4       	brne	.+2      	; 0x14c6 <xQueueGenericSend+0xac>
    14c4:	11 a2       	std	Z+33, r1	; 0x21
    14c6:	f7 01       	movw	r30, r14
    14c8:	82 a1       	ldd	r24, Z+34	; 0x22
    14ca:	8f 3f       	cpi	r24, 0xFF	; 255
    14cc:	09 f4       	brne	.+2      	; 0x14d0 <xQueueGenericSend+0xb6>
    14ce:	12 a2       	std	Z+34, r1	; 0x22
    14d0:	0f 90       	pop	r0
    14d2:	0f be       	out	0x3f, r0	; 63
    14d4:	be 01       	movw	r22, r28
    14d6:	6a 5f       	subi	r22, 0xFA	; 250
    14d8:	7f 4f       	sbci	r23, 0xFF	; 255
    14da:	ce 01       	movw	r24, r28
    14dc:	01 96       	adiw	r24, 0x01	; 1
    14de:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskCheckForTimeOut>
    14e2:	81 11       	cpse	r24, r1
    14e4:	21 c0       	rjmp	.+66     	; 0x1528 <xQueueGenericSend+0x10e>
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	0f 92       	push	r0
    14ec:	f7 01       	movw	r30, r14
    14ee:	96 8d       	ldd	r25, Z+30	; 0x1e
    14f0:	0f 90       	pop	r0
    14f2:	0f be       	out	0x3f, r0	; 63
    14f4:	87 8d       	ldd	r24, Z+31	; 0x1f
    14f6:	98 13       	cpse	r25, r24
    14f8:	11 c0       	rjmp	.+34     	; 0x151c <xQueueGenericSend+0x102>
    14fa:	4e 81       	ldd	r20, Y+6	; 0x06
    14fc:	5f 81       	ldd	r21, Y+7	; 0x07
    14fe:	68 85       	ldd	r22, Y+8	; 0x08
    1500:	79 85       	ldd	r23, Y+9	; 0x09
    1502:	c6 01       	movw	r24, r12
    1504:	0e 94 05 10 	call	0x200a	; 0x200a <vTaskPlaceOnEventList>
    1508:	c7 01       	movw	r24, r14
    150a:	0e 94 59 09 	call	0x12b2	; 0x12b2 <prvUnlockQueue>
    150e:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
    1512:	81 11       	cpse	r24, r1
    1514:	9c cf       	rjmp	.-200    	; 0x144e <xQueueGenericSend+0x34>
    1516:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    151a:	99 cf       	rjmp	.-206    	; 0x144e <xQueueGenericSend+0x34>
    151c:	c7 01       	movw	r24, r14
    151e:	0e 94 59 09 	call	0x12b2	; 0x12b2 <prvUnlockQueue>
    1522:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
    1526:	93 cf       	rjmp	.-218    	; 0x144e <xQueueGenericSend+0x34>
    1528:	c7 01       	movw	r24, r14
    152a:	0e 94 59 09 	call	0x12b2	; 0x12b2 <prvUnlockQueue>
    152e:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
    1532:	80 e0       	ldi	r24, 0x00	; 0
    1534:	29 96       	adiw	r28, 0x09	; 9
    1536:	cd bf       	out	0x3d, r28	; 61
    1538:	de bf       	out	0x3e, r29	; 62
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	df 90       	pop	r13
    1548:	cf 90       	pop	r12
    154a:	bf 90       	pop	r11
    154c:	af 90       	pop	r10
    154e:	08 95       	ret

00001550 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1550:	0f 93       	push	r16
    1552:	1f 93       	push	r17
    1554:	cf 93       	push	r28
    1556:	df 93       	push	r29
    1558:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    155a:	fc 01       	movw	r30, r24
    155c:	56 8d       	ldd	r21, Z+30	; 0x1e
    155e:	37 8d       	ldd	r19, Z+31	; 0x1f
    1560:	53 17       	cp	r21, r19
    1562:	c0 f4       	brcc	.+48     	; 0x1594 <xQueueGenericSendFromISR+0x44>
    1564:	42 2f       	mov	r20, r18
    1566:	ec 01       	movw	r28, r24
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1568:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    156c:	8a a1       	ldd	r24, Y+34	; 0x22
    156e:	8f 3f       	cpi	r24, 0xFF	; 255
    1570:	69 f4       	brne	.+26     	; 0x158c <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1572:	8b 89       	ldd	r24, Y+19	; 0x13
    1574:	88 23       	and	r24, r24
    1576:	81 f0       	breq	.+32     	; 0x1598 <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1578:	ce 01       	movw	r24, r28
    157a:	43 96       	adiw	r24, 0x13	; 19
    157c:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    1580:	88 23       	and	r24, r24
    1582:	61 f0       	breq	.+24     	; 0x159c <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1584:	81 e0       	ldi	r24, 0x01	; 1
    1586:	f8 01       	movw	r30, r16
    1588:	80 83       	st	Z, r24
    158a:	09 c0       	rjmp	.+18     	; 0x159e <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    158c:	8f 5f       	subi	r24, 0xFF	; 255
    158e:	8a a3       	std	Y+34, r24	; 0x22
			}

			xReturn = pdPASS;
    1590:	81 e0       	ldi	r24, 0x01	; 1
    1592:	05 c0       	rjmp	.+10     	; 0x159e <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1594:	80 e0       	ldi	r24, 0x00	; 0
    1596:	03 c0       	rjmp	.+6      	; 0x159e <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1598:	81 e0       	ldi	r24, 0x01	; 1
    159a:	01 c0       	rjmp	.+2      	; 0x159e <xQueueGenericSendFromISR+0x4e>
    159c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    159e:	df 91       	pop	r29
    15a0:	cf 91       	pop	r28
    15a2:	1f 91       	pop	r17
    15a4:	0f 91       	pop	r16
    15a6:	08 95       	ret

000015a8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    15a8:	af 92       	push	r10
    15aa:	bf 92       	push	r11
    15ac:	cf 92       	push	r12
    15ae:	df 92       	push	r13
    15b0:	ef 92       	push	r14
    15b2:	ff 92       	push	r15
    15b4:	0f 93       	push	r16
    15b6:	1f 93       	push	r17
    15b8:	cf 93       	push	r28
    15ba:	df 93       	push	r29
    15bc:	cd b7       	in	r28, 0x3d	; 61
    15be:	de b7       	in	r29, 0x3e	; 62
    15c0:	29 97       	sbiw	r28, 0x09	; 9
    15c2:	cd bf       	out	0x3d, r28	; 61
    15c4:	de bf       	out	0x3e, r29	; 62
    15c6:	7c 01       	movw	r14, r24
    15c8:	5b 01       	movw	r10, r22
    15ca:	2e 83       	std	Y+6, r18	; 0x06
    15cc:	3f 83       	std	Y+7, r19	; 0x07
    15ce:	48 87       	std	Y+8, r20	; 0x08
    15d0:	59 87       	std	Y+9, r21	; 0x09
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    15d2:	10 e0       	ldi	r17, 0x00	; 0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15d4:	6c 01       	movw	r12, r24
    15d6:	83 e1       	ldi	r24, 0x13	; 19
    15d8:	c8 0e       	add	r12, r24
    15da:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    15dc:	0f b6       	in	r0, 0x3f	; 63
    15de:	f8 94       	cli
    15e0:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    15e2:	f7 01       	movw	r30, r14
    15e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    15e6:	88 23       	and	r24, r24
    15e8:	99 f1       	breq	.+102    	; 0x1650 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    15ea:	c6 80       	ldd	r12, Z+6	; 0x06
    15ec:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15ee:	b5 01       	movw	r22, r10
    15f0:	c7 01       	movw	r24, r14
    15f2:	0e 94 3f 09 	call	0x127e	; 0x127e <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    15f6:	01 11       	cpse	r16, r1
    15f8:	1a c0       	rjmp	.+52     	; 0x162e <xQueueGenericReceive+0x86>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    15fa:	f7 01       	movw	r30, r14
    15fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    15fe:	81 50       	subi	r24, 0x01	; 1
    1600:	86 8f       	std	Z+30, r24	; 0x1e

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1602:	80 81       	ld	r24, Z
    1604:	91 81       	ldd	r25, Z+1	; 0x01
    1606:	89 2b       	or	r24, r25
    1608:	29 f4       	brne	.+10     	; 0x1614 <xQueueGenericReceive+0x6c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    160a:	0e 94 09 11 	call	0x2212	; 0x2212 <xTaskGetCurrentTaskHandle>
    160e:	f7 01       	movw	r30, r14
    1610:	82 83       	std	Z+2, r24	; 0x02
    1612:	93 83       	std	Z+3, r25	; 0x03
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1614:	f7 01       	movw	r30, r14
    1616:	80 85       	ldd	r24, Z+8	; 0x08
    1618:	88 23       	and	r24, r24
    161a:	b1 f0       	breq	.+44     	; 0x1648 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    161c:	c7 01       	movw	r24, r14
    161e:	08 96       	adiw	r24, 0x08	; 8
    1620:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    1624:	81 30       	cpi	r24, 0x01	; 1
    1626:	81 f4       	brne	.+32     	; 0x1648 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1628:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    162c:	0d c0       	rjmp	.+26     	; 0x1648 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    162e:	f7 01       	movw	r30, r14
    1630:	c6 82       	std	Z+6, r12	; 0x06
    1632:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1634:	83 89       	ldd	r24, Z+19	; 0x13
    1636:	88 23       	and	r24, r24
    1638:	39 f0       	breq	.+14     	; 0x1648 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    163a:	c7 01       	movw	r24, r14
    163c:	43 96       	adiw	r24, 0x13	; 19
    163e:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    1642:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1644:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1648:	0f 90       	pop	r0
    164a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	62 c0       	rjmp	.+196    	; 0x1714 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1650:	8e 81       	ldd	r24, Y+6	; 0x06
    1652:	9f 81       	ldd	r25, Y+7	; 0x07
    1654:	a8 85       	ldd	r26, Y+8	; 0x08
    1656:	b9 85       	ldd	r27, Y+9	; 0x09
    1658:	89 2b       	or	r24, r25
    165a:	8a 2b       	or	r24, r26
    165c:	8b 2b       	or	r24, r27
    165e:	21 f4       	brne	.+8      	; 0x1668 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1660:	0f 90       	pop	r0
    1662:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1664:	80 e0       	ldi	r24, 0x00	; 0
    1666:	56 c0       	rjmp	.+172    	; 0x1714 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1668:	11 11       	cpse	r17, r1
    166a:	05 c0       	rjmp	.+10     	; 0x1676 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    166c:	ce 01       	movw	r24, r28
    166e:	01 96       	adiw	r24, 0x01	; 1
    1670:	0e 94 6e 10 	call	0x20dc	; 0x20dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1674:	11 e0       	ldi	r17, 0x01	; 1
				}
			}
		}
		taskEXIT_CRITICAL();
    1676:	0f 90       	pop	r0
    1678:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    167a:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    167e:	0f b6       	in	r0, 0x3f	; 63
    1680:	f8 94       	cli
    1682:	0f 92       	push	r0
    1684:	f7 01       	movw	r30, r14
    1686:	81 a1       	ldd	r24, Z+33	; 0x21
    1688:	8f 3f       	cpi	r24, 0xFF	; 255
    168a:	09 f4       	brne	.+2      	; 0x168e <xQueueGenericReceive+0xe6>
    168c:	11 a2       	std	Z+33, r1	; 0x21
    168e:	f7 01       	movw	r30, r14
    1690:	82 a1       	ldd	r24, Z+34	; 0x22
    1692:	8f 3f       	cpi	r24, 0xFF	; 255
    1694:	09 f4       	brne	.+2      	; 0x1698 <xQueueGenericReceive+0xf0>
    1696:	12 a2       	std	Z+34, r1	; 0x22
    1698:	0f 90       	pop	r0
    169a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    169c:	be 01       	movw	r22, r28
    169e:	6a 5f       	subi	r22, 0xFA	; 250
    16a0:	7f 4f       	sbci	r23, 0xFF	; 255
    16a2:	ce 01       	movw	r24, r28
    16a4:	01 96       	adiw	r24, 0x01	; 1
    16a6:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskCheckForTimeOut>
    16aa:	81 11       	cpse	r24, r1
    16ac:	2d c0       	rjmp	.+90     	; 0x1708 <xQueueGenericReceive+0x160>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    16ae:	0f b6       	in	r0, 0x3f	; 63
    16b0:	f8 94       	cli
    16b2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    16b4:	f7 01       	movw	r30, r14
    16b6:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    16b8:	0f 90       	pop	r0
    16ba:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16bc:	81 11       	cpse	r24, r1
    16be:	1e c0       	rjmp	.+60     	; 0x16fc <xQueueGenericReceive+0x154>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    16c0:	80 81       	ld	r24, Z
    16c2:	91 81       	ldd	r25, Z+1	; 0x01
    16c4:	89 2b       	or	r24, r25
    16c6:	49 f4       	brne	.+18     	; 0x16da <xQueueGenericReceive+0x132>
					{
						portENTER_CRITICAL();
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    16ce:	82 81       	ldd	r24, Z+2	; 0x02
    16d0:	93 81       	ldd	r25, Z+3	; 0x03
    16d2:	0e 94 0e 11 	call	0x221c	; 0x221c <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    16d6:	0f 90       	pop	r0
    16d8:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16da:	4e 81       	ldd	r20, Y+6	; 0x06
    16dc:	5f 81       	ldd	r21, Y+7	; 0x07
    16de:	68 85       	ldd	r22, Y+8	; 0x08
    16e0:	79 85       	ldd	r23, Y+9	; 0x09
    16e2:	c6 01       	movw	r24, r12
    16e4:	0e 94 05 10 	call	0x200a	; 0x200a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    16e8:	c7 01       	movw	r24, r14
    16ea:	0e 94 59 09 	call	0x12b2	; 0x12b2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    16ee:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
    16f2:	81 11       	cpse	r24, r1
    16f4:	73 cf       	rjmp	.-282    	; 0x15dc <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    16f6:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    16fa:	70 cf       	rjmp	.-288    	; 0x15dc <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16fc:	c7 01       	movw	r24, r14
    16fe:	0e 94 59 09 	call	0x12b2	; 0x12b2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1702:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
    1706:	6a cf       	rjmp	.-300    	; 0x15dc <xQueueGenericReceive+0x34>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1708:	c7 01       	movw	r24, r14
    170a:	0e 94 59 09 	call	0x12b2	; 0x12b2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    170e:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1712:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1714:	29 96       	adiw	r28, 0x09	; 9
    1716:	cd bf       	out	0x3d, r28	; 61
    1718:	de bf       	out	0x3e, r29	; 62
    171a:	df 91       	pop	r29
    171c:	cf 91       	pop	r28
    171e:	1f 91       	pop	r17
    1720:	0f 91       	pop	r16
    1722:	ff 90       	pop	r15
    1724:	ef 90       	pop	r14
    1726:	df 90       	pop	r13
    1728:	cf 90       	pop	r12
    172a:	bf 90       	pop	r11
    172c:	af 90       	pop	r10
    172e:	08 95       	ret

00001730 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1730:	0f 93       	push	r16
    1732:	1f 93       	push	r17
    1734:	cf 93       	push	r28
    1736:	df 93       	push	r29
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1738:	fc 01       	movw	r30, r24
    173a:	26 8d       	ldd	r18, Z+30	; 0x1e
    173c:	22 23       	and	r18, r18
    173e:	d9 f0       	breq	.+54     	; 0x1776 <xQueueReceiveFromISR+0x46>
    1740:	8a 01       	movw	r16, r20
    1742:	ec 01       	movw	r28, r24
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1744:	0e 94 3f 09 	call	0x127e	; 0x127e <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1748:	8e 8d       	ldd	r24, Y+30	; 0x1e
    174a:	81 50       	subi	r24, 0x01	; 1
    174c:	8e 8f       	std	Y+30, r24	; 0x1e

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    174e:	89 a1       	ldd	r24, Y+33	; 0x21
    1750:	8f 3f       	cpi	r24, 0xFF	; 255
    1752:	69 f4       	brne	.+26     	; 0x176e <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1754:	88 85       	ldd	r24, Y+8	; 0x08
    1756:	88 23       	and	r24, r24
    1758:	81 f0       	breq	.+32     	; 0x177a <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    175a:	ce 01       	movw	r24, r28
    175c:	08 96       	adiw	r24, 0x08	; 8
    175e:	0e 94 2f 10 	call	0x205e	; 0x205e <xTaskRemoveFromEventList>
    1762:	88 23       	and	r24, r24
    1764:	61 f0       	breq	.+24     	; 0x177e <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1766:	81 e0       	ldi	r24, 0x01	; 1
    1768:	f8 01       	movw	r30, r16
    176a:	80 83       	st	Z, r24
    176c:	09 c0       	rjmp	.+18     	; 0x1780 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    176e:	8f 5f       	subi	r24, 0xFF	; 255
    1770:	89 a3       	std	Y+33, r24	; 0x21
			}

			xReturn = pdPASS;
    1772:	81 e0       	ldi	r24, 0x01	; 1
    1774:	05 c0       	rjmp	.+10     	; 0x1780 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1776:	80 e0       	ldi	r24, 0x00	; 0
    1778:	03 c0       	rjmp	.+6      	; 0x1780 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	01 c0       	rjmp	.+2      	; 0x1780 <xQueueReceiveFromISR+0x50>
    177e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1780:	df 91       	pop	r29
    1782:	cf 91       	pop	r28
    1784:	1f 91       	pop	r17
    1786:	0f 91       	pop	r16
    1788:	08 95       	ret

0000178a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	f8 94       	cli
    178e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1790:	fc 01       	movw	r30, r24
    1792:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    1794:	0f 90       	pop	r0
    1796:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1798:	08 95       	ret

0000179a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    179a:	fc 01       	movw	r30, r24
    179c:	86 8d       	ldd	r24, Z+30	; 0x1e

	return uxReturn;
}
    179e:	08 95       	ret

000017a0 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    17a0:	cc e1       	ldi	r28, 0x1C	; 28
    17a2:	d1 e4       	ldi	r29, 0x41	; 65
    17a4:	88 81       	ld	r24, Y
    17a6:	82 30       	cpi	r24, 0x02	; 2
    17a8:	e8 f3       	brcs	.-6      	; 0x17a4 <prvIdleTask+0x4>
    17aa:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    17ae:	fa cf       	rjmp	.-12     	; 0x17a4 <prvIdleTask+0x4>

000017b0 <prvAddCurrentTaskToDelayedList>:
    17b0:	cf 92       	push	r12
    17b2:	df 92       	push	r13
    17b4:	ef 92       	push	r14
    17b6:	ff 92       	push	r15
    17b8:	6b 01       	movw	r12, r22
    17ba:	7c 01       	movw	r14, r24
    17bc:	e0 91 48 41 	lds	r30, 0x4148	; 0x804148 <pxCurrentTCB>
    17c0:	f0 91 49 41 	lds	r31, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    17c4:	62 83       	std	Z+2, r22	; 0x02
    17c6:	73 83       	std	Z+3, r23	; 0x03
    17c8:	84 83       	std	Z+4, r24	; 0x04
    17ca:	95 83       	std	Z+5, r25	; 0x05
    17cc:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    17d0:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    17d4:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    17d8:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    17dc:	c8 16       	cp	r12, r24
    17de:	d9 06       	cpc	r13, r25
    17e0:	ea 06       	cpc	r14, r26
    17e2:	fb 06       	cpc	r15, r27
    17e4:	68 f4       	brcc	.+26     	; 0x1800 <prvAddCurrentTaskToDelayedList+0x50>
    17e6:	60 91 48 41 	lds	r22, 0x4148	; 0x804148 <pxCurrentTCB>
    17ea:	70 91 49 41 	lds	r23, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    17ee:	80 91 02 41 	lds	r24, 0x4102	; 0x804102 <pxOverflowDelayedTaskList>
    17f2:	90 91 03 41 	lds	r25, 0x4103	; 0x804103 <pxOverflowDelayedTaskList+0x1>
    17f6:	6e 5f       	subi	r22, 0xFE	; 254
    17f8:	7f 4f       	sbci	r23, 0xFF	; 255
    17fa:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsert>
    17fe:	21 c0       	rjmp	.+66     	; 0x1842 <prvAddCurrentTaskToDelayedList+0x92>
    1800:	60 91 48 41 	lds	r22, 0x4148	; 0x804148 <pxCurrentTCB>
    1804:	70 91 49 41 	lds	r23, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1808:	80 91 04 41 	lds	r24, 0x4104	; 0x804104 <pxDelayedTaskList>
    180c:	90 91 05 41 	lds	r25, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1810:	6e 5f       	subi	r22, 0xFE	; 254
    1812:	7f 4f       	sbci	r23, 0xFF	; 255
    1814:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsert>
    1818:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    181c:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1820:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1824:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1828:	c8 16       	cp	r12, r24
    182a:	d9 06       	cpc	r13, r25
    182c:	ea 06       	cpc	r14, r26
    182e:	fb 06       	cpc	r15, r27
    1830:	40 f4       	brcc	.+16     	; 0x1842 <prvAddCurrentTaskToDelayedList+0x92>
    1832:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1836:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    183a:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    183e:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    1842:	ff 90       	pop	r15
    1844:	ef 90       	pop	r14
    1846:	df 90       	pop	r13
    1848:	cf 90       	pop	r12
    184a:	08 95       	ret

0000184c <xTaskGenericCreate>:
    184c:	4f 92       	push	r4
    184e:	5f 92       	push	r5
    1850:	6f 92       	push	r6
    1852:	7f 92       	push	r7
    1854:	8f 92       	push	r8
    1856:	9f 92       	push	r9
    1858:	af 92       	push	r10
    185a:	bf 92       	push	r11
    185c:	cf 92       	push	r12
    185e:	df 92       	push	r13
    1860:	ef 92       	push	r14
    1862:	ff 92       	push	r15
    1864:	0f 93       	push	r16
    1866:	1f 93       	push	r17
    1868:	cf 93       	push	r28
    186a:	df 93       	push	r29
    186c:	5c 01       	movw	r10, r24
    186e:	4b 01       	movw	r8, r22
    1870:	3a 01       	movw	r6, r20
    1872:	29 01       	movw	r4, r18
    1874:	88 e2       	ldi	r24, 0x28	; 40
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	0e 94 f7 05 	call	0xbee	; 0xbee <pvPortMalloc>
    187c:	ec 01       	movw	r28, r24
    187e:	89 2b       	or	r24, r25
    1880:	09 f4       	brne	.+2      	; 0x1884 <xTaskGenericCreate+0x38>
    1882:	d4 c0       	rjmp	.+424    	; 0x1a2c <xTaskGenericCreate+0x1e0>
    1884:	c1 14       	cp	r12, r1
    1886:	d1 04       	cpc	r13, r1
    1888:	09 f0       	breq	.+2      	; 0x188c <xTaskGenericCreate+0x40>
    188a:	cc c0       	rjmp	.+408    	; 0x1a24 <xTaskGenericCreate+0x1d8>
    188c:	c3 01       	movw	r24, r6
    188e:	0e 94 f7 05 	call	0xbee	; 0xbee <pvPortMalloc>
    1892:	8b 8f       	std	Y+27, r24	; 0x1b
    1894:	9c 8f       	std	Y+28, r25	; 0x1c
    1896:	00 97       	sbiw	r24, 0x00	; 0
    1898:	21 f4       	brne	.+8      	; 0x18a2 <xTaskGenericCreate+0x56>
    189a:	ce 01       	movw	r24, r28
    189c:	0e 94 91 06 	call	0xd22	; 0xd22 <vPortFree>
    18a0:	c5 c0       	rjmp	.+394    	; 0x1a2c <xTaskGenericCreate+0x1e0>
    18a2:	a3 01       	movw	r20, r6
    18a4:	61 e1       	ldi	r22, 0x11	; 17
    18a6:	70 e0       	ldi	r23, 0x00	; 0
    18a8:	0e 94 02 25 	call	0x4a04	; 0x4a04 <memset>
    18ac:	93 01       	movw	r18, r6
    18ae:	21 50       	subi	r18, 0x01	; 1
    18b0:	31 09       	sbc	r19, r1
    18b2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18b4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18b6:	3c 01       	movw	r6, r24
    18b8:	62 0e       	add	r6, r18
    18ba:	73 1e       	adc	r7, r19
    18bc:	4a e0       	ldi	r20, 0x0A	; 10
    18be:	50 e0       	ldi	r21, 0x00	; 0
    18c0:	b4 01       	movw	r22, r8
    18c2:	ce 01       	movw	r24, r28
    18c4:	4d 96       	adiw	r24, 0x1d	; 29
    18c6:	0e 94 09 25 	call	0x4a12	; 0x4a12 <strncpy>
    18ca:	1e a2       	std	Y+38, r1	; 0x26
    18cc:	10 2f       	mov	r17, r16
    18ce:	04 30       	cpi	r16, 0x04	; 4
    18d0:	08 f0       	brcs	.+2      	; 0x18d4 <xTaskGenericCreate+0x88>
    18d2:	13 e0       	ldi	r17, 0x03	; 3
    18d4:	1a 8f       	std	Y+26, r17	; 0x1a
    18d6:	1f a3       	std	Y+39, r17	; 0x27
    18d8:	6e 01       	movw	r12, r28
    18da:	22 e0       	ldi	r18, 0x02	; 2
    18dc:	c2 0e       	add	r12, r18
    18de:	d1 1c       	adc	r13, r1
    18e0:	c6 01       	movw	r24, r12
    18e2:	0e 94 da 06 	call	0xdb4	; 0xdb4 <vListInitialiseItem>
    18e6:	ce 01       	movw	r24, r28
    18e8:	0e 96       	adiw	r24, 0x0e	; 14
    18ea:	0e 94 da 06 	call	0xdb4	; 0xdb4 <vListInitialiseItem>
    18ee:	ca 87       	std	Y+10, r28	; 0x0a
    18f0:	db 87       	std	Y+11, r29	; 0x0b
    18f2:	84 e0       	ldi	r24, 0x04	; 4
    18f4:	90 e0       	ldi	r25, 0x00	; 0
    18f6:	a0 e0       	ldi	r26, 0x00	; 0
    18f8:	b0 e0       	ldi	r27, 0x00	; 0
    18fa:	81 1b       	sub	r24, r17
    18fc:	91 09       	sbc	r25, r1
    18fe:	a1 09       	sbc	r26, r1
    1900:	b1 09       	sbc	r27, r1
    1902:	8e 87       	std	Y+14, r24	; 0x0e
    1904:	9f 87       	std	Y+15, r25	; 0x0f
    1906:	a8 8b       	std	Y+16, r26	; 0x10
    1908:	b9 8b       	std	Y+17, r27	; 0x11
    190a:	ce 8b       	std	Y+22, r28	; 0x16
    190c:	df 8b       	std	Y+23, r29	; 0x17
    190e:	a2 01       	movw	r20, r4
    1910:	b5 01       	movw	r22, r10
    1912:	c3 01       	movw	r24, r6
    1914:	0e 94 76 07 	call	0xeec	; 0xeec <pxPortInitialiseStack>
    1918:	88 83       	st	Y, r24
    191a:	99 83       	std	Y+1, r25	; 0x01
    191c:	e1 14       	cp	r14, r1
    191e:	f1 04       	cpc	r15, r1
    1920:	19 f0       	breq	.+6      	; 0x1928 <xTaskGenericCreate+0xdc>
    1922:	f7 01       	movw	r30, r14
    1924:	c0 83       	st	Z, r28
    1926:	d1 83       	std	Z+1, r29	; 0x01
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
    192e:	80 91 f4 40 	lds	r24, 0x40F4	; 0x8040f4 <uxCurrentNumberOfTasks>
    1932:	8f 5f       	subi	r24, 0xFF	; 255
    1934:	80 93 f4 40 	sts	0x40F4, r24	; 0x8040f4 <uxCurrentNumberOfTasks>
    1938:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    193c:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1940:	89 2b       	or	r24, r25
    1942:	89 f5       	brne	.+98     	; 0x19a6 <xTaskGenericCreate+0x15a>
    1944:	c0 93 48 41 	sts	0x4148, r28	; 0x804148 <pxCurrentTCB>
    1948:	d0 93 49 41 	sts	0x4149, r29	; 0x804149 <pxCurrentTCB+0x1>
    194c:	80 91 f4 40 	lds	r24, 0x40F4	; 0x8040f4 <uxCurrentNumberOfTasks>
    1950:	81 30       	cpi	r24, 0x01	; 1
    1952:	c1 f5       	brne	.+112    	; 0x19c4 <xTaskGenericCreate+0x178>
    1954:	8c e1       	ldi	r24, 0x1C	; 28
    1956:	91 e4       	ldi	r25, 0x41	; 65
    1958:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    195c:	87 e2       	ldi	r24, 0x27	; 39
    195e:	91 e4       	ldi	r25, 0x41	; 65
    1960:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    1964:	82 e3       	ldi	r24, 0x32	; 50
    1966:	91 e4       	ldi	r25, 0x41	; 65
    1968:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    196c:	8d e3       	ldi	r24, 0x3D	; 61
    196e:	91 e4       	ldi	r25, 0x41	; 65
    1970:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    1974:	81 e1       	ldi	r24, 0x11	; 17
    1976:	91 e4       	ldi	r25, 0x41	; 65
    1978:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    197c:	86 e0       	ldi	r24, 0x06	; 6
    197e:	91 e4       	ldi	r25, 0x41	; 65
    1980:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    1984:	87 ef       	ldi	r24, 0xF7	; 247
    1986:	90 e4       	ldi	r25, 0x40	; 64
    1988:	0e 94 c9 06 	call	0xd92	; 0xd92 <vListInitialise>
    198c:	81 e1       	ldi	r24, 0x11	; 17
    198e:	91 e4       	ldi	r25, 0x41	; 65
    1990:	80 93 04 41 	sts	0x4104, r24	; 0x804104 <pxDelayedTaskList>
    1994:	90 93 05 41 	sts	0x4105, r25	; 0x804105 <pxDelayedTaskList+0x1>
    1998:	86 e0       	ldi	r24, 0x06	; 6
    199a:	91 e4       	ldi	r25, 0x41	; 65
    199c:	80 93 02 41 	sts	0x4102, r24	; 0x804102 <pxOverflowDelayedTaskList>
    19a0:	90 93 03 41 	sts	0x4103, r25	; 0x804103 <pxOverflowDelayedTaskList+0x1>
    19a4:	0f c0       	rjmp	.+30     	; 0x19c4 <xTaskGenericCreate+0x178>
    19a6:	80 91 ed 40 	lds	r24, 0x40ED	; 0x8040ed <xSchedulerRunning>
    19aa:	81 11       	cpse	r24, r1
    19ac:	0b c0       	rjmp	.+22     	; 0x19c4 <xTaskGenericCreate+0x178>
    19ae:	e0 91 48 41 	lds	r30, 0x4148	; 0x804148 <pxCurrentTCB>
    19b2:	f0 91 49 41 	lds	r31, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    19b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    19b8:	08 17       	cp	r16, r24
    19ba:	20 f0       	brcs	.+8      	; 0x19c4 <xTaskGenericCreate+0x178>
    19bc:	c0 93 48 41 	sts	0x4148, r28	; 0x804148 <pxCurrentTCB>
    19c0:	d0 93 49 41 	sts	0x4149, r29	; 0x804149 <pxCurrentTCB+0x1>
    19c4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    19c6:	90 91 ef 40 	lds	r25, 0x40EF	; 0x8040ef <uxTopUsedPriority>
    19ca:	98 17       	cp	r25, r24
    19cc:	10 f4       	brcc	.+4      	; 0x19d2 <xTaskGenericCreate+0x186>
    19ce:	80 93 ef 40 	sts	0x40EF, r24	; 0x8040ef <uxTopUsedPriority>
    19d2:	90 91 e8 40 	lds	r25, 0x40E8	; 0x8040e8 <uxTaskNumber>
    19d6:	9f 5f       	subi	r25, 0xFF	; 255
    19d8:	90 93 e8 40 	sts	0x40E8, r25	; 0x8040e8 <uxTaskNumber>
    19dc:	90 91 ee 40 	lds	r25, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    19e0:	98 17       	cp	r25, r24
    19e2:	10 f4       	brcc	.+4      	; 0x19e8 <xTaskGenericCreate+0x19c>
    19e4:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
    19e8:	fb e0       	ldi	r31, 0x0B	; 11
    19ea:	8f 9f       	mul	r24, r31
    19ec:	c0 01       	movw	r24, r0
    19ee:	11 24       	eor	r1, r1
    19f0:	b6 01       	movw	r22, r12
    19f2:	84 5e       	subi	r24, 0xE4	; 228
    19f4:	9e 4b       	sbci	r25, 0xBE	; 190
    19f6:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>
    19fa:	0f 90       	pop	r0
    19fc:	0f be       	out	0x3f, r0	; 63
    19fe:	80 91 ed 40 	lds	r24, 0x40ED	; 0x8040ed <xSchedulerRunning>
    1a02:	88 23       	and	r24, r24
    1a04:	59 f0       	breq	.+22     	; 0x1a1c <xTaskGenericCreate+0x1d0>
    1a06:	e0 91 48 41 	lds	r30, 0x4148	; 0x804148 <pxCurrentTCB>
    1a0a:	f0 91 49 41 	lds	r31, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1a0e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a10:	80 17       	cp	r24, r16
    1a12:	30 f4       	brcc	.+12     	; 0x1a20 <xTaskGenericCreate+0x1d4>
    1a14:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	09 c0       	rjmp	.+18     	; 0x1a2e <xTaskGenericCreate+0x1e2>
    1a1c:	81 e0       	ldi	r24, 0x01	; 1
    1a1e:	07 c0       	rjmp	.+14     	; 0x1a2e <xTaskGenericCreate+0x1e2>
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	05 c0       	rjmp	.+10     	; 0x1a2e <xTaskGenericCreate+0x1e2>
    1a24:	cb 8e       	std	Y+27, r12	; 0x1b
    1a26:	dc 8e       	std	Y+28, r13	; 0x1c
    1a28:	c6 01       	movw	r24, r12
    1a2a:	3b cf       	rjmp	.-394    	; 0x18a2 <xTaskGenericCreate+0x56>
    1a2c:	8f ef       	ldi	r24, 0xFF	; 255
    1a2e:	df 91       	pop	r29
    1a30:	cf 91       	pop	r28
    1a32:	1f 91       	pop	r17
    1a34:	0f 91       	pop	r16
    1a36:	ff 90       	pop	r15
    1a38:	ef 90       	pop	r14
    1a3a:	df 90       	pop	r13
    1a3c:	cf 90       	pop	r12
    1a3e:	bf 90       	pop	r11
    1a40:	af 90       	pop	r10
    1a42:	9f 90       	pop	r9
    1a44:	8f 90       	pop	r8
    1a46:	7f 90       	pop	r7
    1a48:	6f 90       	pop	r6
    1a4a:	5f 90       	pop	r5
    1a4c:	4f 90       	pop	r4
    1a4e:	08 95       	ret

00001a50 <uxTaskPriorityGet>:
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	0f 92       	push	r0
    1a56:	00 97       	sbiw	r24, 0x00	; 0
    1a58:	21 f4       	brne	.+8      	; 0x1a62 <uxTaskPriorityGet+0x12>
    1a5a:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    1a5e:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	fc 01       	movw	r30, r24
    1a68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a6a:	08 95       	ret

00001a6c <vTaskStartScheduler>:
    1a6c:	af 92       	push	r10
    1a6e:	bf 92       	push	r11
    1a70:	cf 92       	push	r12
    1a72:	df 92       	push	r13
    1a74:	ef 92       	push	r14
    1a76:	ff 92       	push	r15
    1a78:	0f 93       	push	r16
    1a7a:	a1 2c       	mov	r10, r1
    1a7c:	b1 2c       	mov	r11, r1
    1a7e:	c1 2c       	mov	r12, r1
    1a80:	d1 2c       	mov	r13, r1
    1a82:	0f 2e       	mov	r0, r31
    1a84:	f5 ef       	ldi	r31, 0xF5	; 245
    1a86:	ef 2e       	mov	r14, r31
    1a88:	f0 e4       	ldi	r31, 0x40	; 64
    1a8a:	ff 2e       	mov	r15, r31
    1a8c:	f0 2d       	mov	r31, r0
    1a8e:	00 e0       	ldi	r16, 0x00	; 0
    1a90:	20 e0       	ldi	r18, 0x00	; 0
    1a92:	30 e0       	ldi	r19, 0x00	; 0
    1a94:	44 e6       	ldi	r20, 0x64	; 100
    1a96:	50 e0       	ldi	r21, 0x00	; 0
    1a98:	67 e2       	ldi	r22, 0x27	; 39
    1a9a:	70 e2       	ldi	r23, 0x20	; 32
    1a9c:	80 ed       	ldi	r24, 0xD0	; 208
    1a9e:	9b e0       	ldi	r25, 0x0B	; 11
    1aa0:	0e 94 26 0c 	call	0x184c	; 0x184c <xTaskGenericCreate>
    1aa4:	81 30       	cpi	r24, 0x01	; 1
    1aa6:	69 f4       	brne	.+26     	; 0x1ac2 <vTaskStartScheduler+0x56>
    1aa8:	f8 94       	cli
    1aaa:	80 93 ed 40 	sts	0x40ED, r24	; 0x8040ed <xSchedulerRunning>
    1aae:	10 92 f0 40 	sts	0x40F0, r1	; 0x8040f0 <xTickCount>
    1ab2:	10 92 f1 40 	sts	0x40F1, r1	; 0x8040f1 <xTickCount+0x1>
    1ab6:	10 92 f2 40 	sts	0x40F2, r1	; 0x8040f2 <xTickCount+0x2>
    1aba:	10 92 f3 40 	sts	0x40F3, r1	; 0x8040f3 <xTickCount+0x3>
    1abe:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <xPortStartScheduler>
    1ac2:	0f 91       	pop	r16
    1ac4:	ff 90       	pop	r15
    1ac6:	ef 90       	pop	r14
    1ac8:	df 90       	pop	r13
    1aca:	cf 90       	pop	r12
    1acc:	bf 90       	pop	r11
    1ace:	af 90       	pop	r10
    1ad0:	08 95       	ret

00001ad2 <vTaskSuspendAll>:
    1ad2:	80 91 ec 40 	lds	r24, 0x40EC	; 0x8040ec <uxSchedulerSuspended>
    1ad6:	8f 5f       	subi	r24, 0xFF	; 255
    1ad8:	80 93 ec 40 	sts	0x40EC, r24	; 0x8040ec <uxSchedulerSuspended>
    1adc:	08 95       	ret

00001ade <xTaskGetTickCount>:
    1ade:	0f b6       	in	r0, 0x3f	; 63
    1ae0:	f8 94       	cli
    1ae2:	0f 92       	push	r0
    1ae4:	60 91 f0 40 	lds	r22, 0x40F0	; 0x8040f0 <xTickCount>
    1ae8:	70 91 f1 40 	lds	r23, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1aec:	80 91 f2 40 	lds	r24, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1af0:	90 91 f3 40 	lds	r25, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1af4:	0f 90       	pop	r0
    1af6:	0f be       	out	0x3f, r0	; 63
    1af8:	08 95       	ret

00001afa <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1afa:	00 97       	sbiw	r24, 0x00	; 0
    1afc:	21 f4       	brne	.+8      	; 0x1b06 <pcTaskGetTaskName+0xc>
    1afe:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    1b02:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1b06:	4d 96       	adiw	r24, 0x1d	; 29
    1b08:	08 95       	ret

00001b0a <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1b0a:	80 91 f5 40 	lds	r24, 0x40F5	; 0x8040f5 <xIdleTaskHandle>
    1b0e:	90 91 f6 40 	lds	r25, 0x40F6	; 0x8040f6 <xIdleTaskHandle+0x1>
    1b12:	08 95       	ret

00001b14 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1b14:	ff 92       	push	r15
    1b16:	0f 93       	push	r16
    1b18:	1f 93       	push	r17
    1b1a:	cf 93       	push	r28
    1b1c:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1b1e:	80 91 ec 40 	lds	r24, 0x40EC	; 0x8040ec <uxSchedulerSuspended>
    1b22:	81 11       	cpse	r24, r1
    1b24:	ed c0       	rjmp	.+474    	; 0x1d00 <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1b26:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    1b2a:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1b2e:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1b32:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1b36:	01 96       	adiw	r24, 0x01	; 1
    1b38:	a1 1d       	adc	r26, r1
    1b3a:	b1 1d       	adc	r27, r1
    1b3c:	80 93 f0 40 	sts	0x40F0, r24	; 0x8040f0 <xTickCount>
    1b40:	90 93 f1 40 	sts	0x40F1, r25	; 0x8040f1 <xTickCount+0x1>
    1b44:	a0 93 f2 40 	sts	0x40F2, r26	; 0x8040f2 <xTickCount+0x2>
    1b48:	b0 93 f3 40 	sts	0x40F3, r27	; 0x8040f3 <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1b4c:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    1b50:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1b54:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1b58:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1b5c:	89 2b       	or	r24, r25
    1b5e:	8a 2b       	or	r24, r26
    1b60:	8b 2b       	or	r24, r27
    1b62:	f1 f5       	brne	.+124    	; 0x1be0 <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1b64:	80 91 04 41 	lds	r24, 0x4104	; 0x804104 <pxDelayedTaskList>
    1b68:	90 91 05 41 	lds	r25, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1b6c:	20 91 02 41 	lds	r18, 0x4102	; 0x804102 <pxOverflowDelayedTaskList>
    1b70:	30 91 03 41 	lds	r19, 0x4103	; 0x804103 <pxOverflowDelayedTaskList+0x1>
    1b74:	20 93 04 41 	sts	0x4104, r18	; 0x804104 <pxDelayedTaskList>
    1b78:	30 93 05 41 	sts	0x4105, r19	; 0x804105 <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1b7c:	80 93 02 41 	sts	0x4102, r24	; 0x804102 <pxOverflowDelayedTaskList>
    1b80:	90 93 03 41 	sts	0x4103, r25	; 0x804103 <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1b84:	80 91 e9 40 	lds	r24, 0x40E9	; 0x8040e9 <xNumOfOverflows>
    1b88:	8f 5f       	subi	r24, 0xFF	; 255
    1b8a:	80 93 e9 40 	sts	0x40E9, r24	; 0x8040e9 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1b8e:	e0 91 04 41 	lds	r30, 0x4104	; 0x804104 <pxDelayedTaskList>
    1b92:	f0 91 05 41 	lds	r31, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1b96:	80 81       	ld	r24, Z
    1b98:	81 11       	cpse	r24, r1
    1b9a:	0c c0       	rjmp	.+24     	; 0x1bb4 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1b9c:	8f ef       	ldi	r24, 0xFF	; 255
    1b9e:	9f ef       	ldi	r25, 0xFF	; 255
    1ba0:	dc 01       	movw	r26, r24
    1ba2:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1ba6:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1baa:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1bae:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1bb2:	16 c0       	rjmp	.+44     	; 0x1be0 <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1bb4:	e0 91 04 41 	lds	r30, 0x4104	; 0x804104 <pxDelayedTaskList>
    1bb8:	f0 91 05 41 	lds	r31, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1bbc:	07 80       	ldd	r0, Z+7	; 0x07
    1bbe:	f0 85       	ldd	r31, Z+8	; 0x08
    1bc0:	e0 2d       	mov	r30, r0
    1bc2:	00 84       	ldd	r0, Z+8	; 0x08
    1bc4:	f1 85       	ldd	r31, Z+9	; 0x09
    1bc6:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1bc8:	82 81       	ldd	r24, Z+2	; 0x02
    1bca:	93 81       	ldd	r25, Z+3	; 0x03
    1bcc:	a4 81       	ldd	r26, Z+4	; 0x04
    1bce:	b5 81       	ldd	r27, Z+5	; 0x05
    1bd0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1bd4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1bd8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1bdc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1be0:	40 91 f0 40 	lds	r20, 0x40F0	; 0x8040f0 <xTickCount>
    1be4:	50 91 f1 40 	lds	r21, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1be8:	60 91 f2 40 	lds	r22, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1bec:	70 91 f3 40 	lds	r23, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1bf0:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1bf4:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1bf8:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1bfc:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c00:	48 17       	cp	r20, r24
    1c02:	59 07       	cpc	r21, r25
    1c04:	6a 07       	cpc	r22, r26
    1c06:	7b 07       	cpc	r23, r27
    1c08:	08 f4       	brcc	.+2      	; 0x1c0c <vTaskIncrementTick+0xf8>
    1c0a:	7f c0       	rjmp	.+254    	; 0x1d0a <vTaskIncrementTick+0x1f6>
    1c0c:	e0 91 04 41 	lds	r30, 0x4104	; 0x804104 <pxDelayedTaskList>
    1c10:	f0 91 05 41 	lds	r31, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1c14:	80 81       	ld	r24, Z
    1c16:	88 23       	and	r24, r24
    1c18:	f9 f0       	breq	.+62     	; 0x1c58 <vTaskIncrementTick+0x144>
    1c1a:	e0 91 04 41 	lds	r30, 0x4104	; 0x804104 <pxDelayedTaskList>
    1c1e:	f0 91 05 41 	lds	r31, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1c22:	07 80       	ldd	r0, Z+7	; 0x07
    1c24:	f0 85       	ldd	r31, Z+8	; 0x08
    1c26:	e0 2d       	mov	r30, r0
    1c28:	c0 85       	ldd	r28, Z+8	; 0x08
    1c2a:	d1 85       	ldd	r29, Z+9	; 0x09
    1c2c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c2e:	9b 81       	ldd	r25, Y+3	; 0x03
    1c30:	ac 81       	ldd	r26, Y+4	; 0x04
    1c32:	bd 81       	ldd	r27, Y+5	; 0x05
    1c34:	40 91 f0 40 	lds	r20, 0x40F0	; 0x8040f0 <xTickCount>
    1c38:	50 91 f1 40 	lds	r21, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1c3c:	60 91 f2 40 	lds	r22, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1c40:	70 91 f3 40 	lds	r23, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1c44:	48 17       	cp	r20, r24
    1c46:	59 07       	cpc	r21, r25
    1c48:	6a 07       	cpc	r22, r26
    1c4a:	7b 07       	cpc	r23, r27
    1c4c:	58 f1       	brcs	.+86     	; 0x1ca4 <vTaskIncrementTick+0x190>
    1c4e:	0f 2e       	mov	r0, r31
    1c50:	fb e0       	ldi	r31, 0x0B	; 11
    1c52:	ff 2e       	mov	r15, r31
    1c54:	f0 2d       	mov	r31, r0
    1c56:	2f c0       	rjmp	.+94     	; 0x1cb6 <vTaskIncrementTick+0x1a2>
    1c58:	8f ef       	ldi	r24, 0xFF	; 255
    1c5a:	9f ef       	ldi	r25, 0xFF	; 255
    1c5c:	dc 01       	movw	r26, r24
    1c5e:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1c62:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1c66:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1c6a:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1c6e:	4d c0       	rjmp	.+154    	; 0x1d0a <vTaskIncrementTick+0x1f6>
    1c70:	e0 91 04 41 	lds	r30, 0x4104	; 0x804104 <pxDelayedTaskList>
    1c74:	f0 91 05 41 	lds	r31, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1c78:	07 80       	ldd	r0, Z+7	; 0x07
    1c7a:	f0 85       	ldd	r31, Z+8	; 0x08
    1c7c:	e0 2d       	mov	r30, r0
    1c7e:	c0 85       	ldd	r28, Z+8	; 0x08
    1c80:	d1 85       	ldd	r29, Z+9	; 0x09
    1c82:	8a 81       	ldd	r24, Y+2	; 0x02
    1c84:	9b 81       	ldd	r25, Y+3	; 0x03
    1c86:	ac 81       	ldd	r26, Y+4	; 0x04
    1c88:	bd 81       	ldd	r27, Y+5	; 0x05
    1c8a:	40 91 f0 40 	lds	r20, 0x40F0	; 0x8040f0 <xTickCount>
    1c8e:	50 91 f1 40 	lds	r21, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1c92:	60 91 f2 40 	lds	r22, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1c96:	70 91 f3 40 	lds	r23, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1c9a:	48 17       	cp	r20, r24
    1c9c:	59 07       	cpc	r21, r25
    1c9e:	6a 07       	cpc	r22, r26
    1ca0:	7b 07       	cpc	r23, r27
    1ca2:	48 f4       	brcc	.+18     	; 0x1cb6 <vTaskIncrementTick+0x1a2>
    1ca4:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1ca8:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cac:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1cb0:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1cb4:	2a c0       	rjmp	.+84     	; 0x1d0a <vTaskIncrementTick+0x1f6>
    1cb6:	8e 01       	movw	r16, r28
    1cb8:	0e 5f       	subi	r16, 0xFE	; 254
    1cba:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbc:	c8 01       	movw	r24, r16
    1cbe:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
    1cc2:	88 8d       	ldd	r24, Y+24	; 0x18
    1cc4:	99 8d       	ldd	r25, Y+25	; 0x19
    1cc6:	89 2b       	or	r24, r25
    1cc8:	21 f0       	breq	.+8      	; 0x1cd2 <vTaskIncrementTick+0x1be>
    1cca:	ce 01       	movw	r24, r28
    1ccc:	0e 96       	adiw	r24, 0x0e	; 14
    1cce:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
    1cd2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cd4:	90 91 ee 40 	lds	r25, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    1cd8:	98 17       	cp	r25, r24
    1cda:	10 f4       	brcc	.+4      	; 0x1ce0 <vTaskIncrementTick+0x1cc>
    1cdc:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
    1ce0:	f8 9e       	mul	r15, r24
    1ce2:	c0 01       	movw	r24, r0
    1ce4:	11 24       	eor	r1, r1
    1ce6:	b8 01       	movw	r22, r16
    1ce8:	84 5e       	subi	r24, 0xE4	; 228
    1cea:	9e 4b       	sbci	r25, 0xBE	; 190
    1cec:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>
    1cf0:	e0 91 04 41 	lds	r30, 0x4104	; 0x804104 <pxDelayedTaskList>
    1cf4:	f0 91 05 41 	lds	r31, 0x4105	; 0x804105 <pxDelayedTaskList+0x1>
    1cf8:	80 81       	ld	r24, Z
    1cfa:	81 11       	cpse	r24, r1
    1cfc:	b9 cf       	rjmp	.-142    	; 0x1c70 <vTaskIncrementTick+0x15c>
    1cfe:	ac cf       	rjmp	.-168    	; 0x1c58 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    1d00:	80 91 eb 40 	lds	r24, 0x40EB	; 0x8040eb <uxMissedTicks>
    1d04:	8f 5f       	subi	r24, 0xFF	; 255
    1d06:	80 93 eb 40 	sts	0x40EB, r24	; 0x8040eb <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1d0a:	df 91       	pop	r29
    1d0c:	cf 91       	pop	r28
    1d0e:	1f 91       	pop	r17
    1d10:	0f 91       	pop	r16
    1d12:	ff 90       	pop	r15
    1d14:	08 95       	ret

00001d16 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1d16:	cf 92       	push	r12
    1d18:	df 92       	push	r13
    1d1a:	ef 92       	push	r14
    1d1c:	ff 92       	push	r15
    1d1e:	0f 93       	push	r16
    1d20:	1f 93       	push	r17
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1d26:	0f b6       	in	r0, 0x3f	; 63
    1d28:	f8 94       	cli
    1d2a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1d2c:	80 91 ec 40 	lds	r24, 0x40EC	; 0x8040ec <uxSchedulerSuspended>
    1d30:	81 50       	subi	r24, 0x01	; 1
    1d32:	80 93 ec 40 	sts	0x40EC, r24	; 0x8040ec <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1d36:	80 91 ec 40 	lds	r24, 0x40EC	; 0x8040ec <uxSchedulerSuspended>
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	60 c0       	rjmp	.+192    	; 0x1dfe <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1d3e:	80 91 f4 40 	lds	r24, 0x40F4	; 0x8040f4 <uxCurrentNumberOfTasks>
    1d42:	81 11       	cpse	r24, r1
    1d44:	2c c0       	rjmp	.+88     	; 0x1d9e <xTaskResumeAll+0x88>
    1d46:	5e c0       	rjmp	.+188    	; 0x1e04 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1d48:	d7 01       	movw	r26, r14
    1d4a:	17 96       	adiw	r26, 0x07	; 7
    1d4c:	ed 91       	ld	r30, X+
    1d4e:	fc 91       	ld	r31, X
    1d50:	18 97       	sbiw	r26, 0x08	; 8
    1d52:	c0 85       	ldd	r28, Z+8	; 0x08
    1d54:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    1d56:	ce 01       	movw	r24, r28
    1d58:	0e 96       	adiw	r24, 0x0e	; 14
    1d5a:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1d5e:	8e 01       	movw	r16, r28
    1d60:	0e 5f       	subi	r16, 0xFE	; 254
    1d62:	1f 4f       	sbci	r17, 0xFF	; 255
    1d64:	c8 01       	movw	r24, r16
    1d66:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1d6a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d6c:	90 91 ee 40 	lds	r25, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    1d70:	98 17       	cp	r25, r24
    1d72:	10 f4       	brcc	.+4      	; 0x1d78 <xTaskResumeAll+0x62>
    1d74:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
    1d78:	d8 9e       	mul	r13, r24
    1d7a:	c0 01       	movw	r24, r0
    1d7c:	11 24       	eor	r1, r1
    1d7e:	b8 01       	movw	r22, r16
    1d80:	84 5e       	subi	r24, 0xE4	; 228
    1d82:	9e 4b       	sbci	r25, 0xBE	; 190
    1d84:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1d88:	e0 91 48 41 	lds	r30, 0x4148	; 0x804148 <pxCurrentTCB>
    1d8c:	f0 91 49 41 	lds	r31, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1d90:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1d92:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d94:	98 17       	cp	r25, r24
    1d96:	70 f0       	brcs	.+28     	; 0x1db4 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    1d98:	cc 24       	eor	r12, r12
    1d9a:	c3 94       	inc	r12
    1d9c:	0b c0       	rjmp	.+22     	; 0x1db4 <xTaskResumeAll+0x9e>
    1d9e:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1da0:	0f 2e       	mov	r0, r31
    1da2:	f7 ef       	ldi	r31, 0xF7	; 247
    1da4:	ef 2e       	mov	r14, r31
    1da6:	f0 e4       	ldi	r31, 0x40	; 64
    1da8:	ff 2e       	mov	r15, r31
    1daa:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1dac:	0f 2e       	mov	r0, r31
    1dae:	fb e0       	ldi	r31, 0x0B	; 11
    1db0:	df 2e       	mov	r13, r31
    1db2:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1db4:	f7 01       	movw	r30, r14
    1db6:	80 81       	ld	r24, Z
    1db8:	81 11       	cpse	r24, r1
    1dba:	c6 cf       	rjmp	.-116    	; 0x1d48 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1dbc:	80 91 eb 40 	lds	r24, 0x40EB	; 0x8040eb <uxMissedTicks>
    1dc0:	88 23       	and	r24, r24
    1dc2:	81 f0       	breq	.+32     	; 0x1de4 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1dc4:	80 91 eb 40 	lds	r24, 0x40EB	; 0x8040eb <uxMissedTicks>
    1dc8:	88 23       	and	r24, r24
    1dca:	99 f0       	breq	.+38     	; 0x1df2 <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    1dcc:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <vTaskIncrementTick>
						--uxMissedTicks;
    1dd0:	80 91 eb 40 	lds	r24, 0x40EB	; 0x8040eb <uxMissedTicks>
    1dd4:	81 50       	subi	r24, 0x01	; 1
    1dd6:	80 93 eb 40 	sts	0x40EB, r24	; 0x8040eb <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1dda:	80 91 eb 40 	lds	r24, 0x40EB	; 0x8040eb <uxMissedTicks>
    1dde:	81 11       	cpse	r24, r1
    1de0:	f5 cf       	rjmp	.-22     	; 0x1dcc <xTaskResumeAll+0xb6>
    1de2:	07 c0       	rjmp	.+14     	; 0x1df2 <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1de4:	f1 e0       	ldi	r31, 0x01	; 1
    1de6:	cf 16       	cp	r12, r31
    1de8:	21 f0       	breq	.+8      	; 0x1df2 <xTaskResumeAll+0xdc>
    1dea:	80 91 ea 40 	lds	r24, 0x40EA	; 0x8040ea <xMissedYield>
    1dee:	81 30       	cpi	r24, 0x01	; 1
    1df0:	41 f4       	brne	.+16     	; 0x1e02 <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1df2:	10 92 ea 40 	sts	0x40EA, r1	; 0x8040ea <xMissedYield>
					portYIELD_WITHIN_API();
    1df6:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	03 c0       	rjmp	.+6      	; 0x1e04 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1dfe:	80 e0       	ldi	r24, 0x00	; 0
    1e00:	01 c0       	rjmp	.+2      	; 0x1e04 <xTaskResumeAll+0xee>
    1e02:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1e04:	0f 90       	pop	r0
    1e06:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1e08:	df 91       	pop	r29
    1e0a:	cf 91       	pop	r28
    1e0c:	1f 91       	pop	r17
    1e0e:	0f 91       	pop	r16
    1e10:	ff 90       	pop	r15
    1e12:	ef 90       	pop	r14
    1e14:	df 90       	pop	r13
    1e16:	cf 90       	pop	r12
    1e18:	08 95       	ret

00001e1a <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1e1a:	cf 92       	push	r12
    1e1c:	df 92       	push	r13
    1e1e:	ef 92       	push	r14
    1e20:	ff 92       	push	r15
    1e22:	cf 93       	push	r28
    1e24:	df 93       	push	r29
    1e26:	ec 01       	movw	r28, r24
    1e28:	6a 01       	movw	r12, r20
    1e2a:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1e2c:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1e30:	88 81       	ld	r24, Y
    1e32:	99 81       	ldd	r25, Y+1	; 0x01
    1e34:	aa 81       	ldd	r26, Y+2	; 0x02
    1e36:	bb 81       	ldd	r27, Y+3	; 0x03
    1e38:	c8 0e       	add	r12, r24
    1e3a:	d9 1e       	adc	r13, r25
    1e3c:	ea 1e       	adc	r14, r26
    1e3e:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    1e40:	40 91 f0 40 	lds	r20, 0x40F0	; 0x8040f0 <xTickCount>
    1e44:	50 91 f1 40 	lds	r21, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1e48:	60 91 f2 40 	lds	r22, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1e4c:	70 91 f3 40 	lds	r23, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1e50:	48 17       	cp	r20, r24
    1e52:	59 07       	cpc	r21, r25
    1e54:	6a 07       	cpc	r22, r26
    1e56:	7b 07       	cpc	r23, r27
    1e58:	b8 f4       	brcc	.+46     	; 0x1e88 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1e5a:	c8 16       	cp	r12, r24
    1e5c:	d9 06       	cpc	r13, r25
    1e5e:	ea 06       	cpc	r14, r26
    1e60:	fb 06       	cpc	r15, r27
    1e62:	e0 f5       	brcc	.+120    	; 0x1edc <vTaskDelayUntil+0xc2>
    1e64:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    1e68:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1e6c:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1e70:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1e74:	c8 82       	st	Y, r12
    1e76:	d9 82       	std	Y+1, r13	; 0x01
    1e78:	ea 82       	std	Y+2, r14	; 0x02
    1e7a:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    1e7c:	8c 15       	cp	r24, r12
    1e7e:	9d 05       	cpc	r25, r13
    1e80:	ae 05       	cpc	r26, r14
    1e82:	bf 05       	cpc	r27, r15
    1e84:	f8 f4       	brcc	.+62     	; 0x1ec4 <vTaskDelayUntil+0xaa>
    1e86:	13 c0       	rjmp	.+38     	; 0x1eae <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1e88:	c8 16       	cp	r12, r24
    1e8a:	d9 06       	cpc	r13, r25
    1e8c:	ea 06       	cpc	r14, r26
    1e8e:	fb 06       	cpc	r15, r27
    1e90:	00 f1       	brcs	.+64     	; 0x1ed2 <vTaskDelayUntil+0xb8>
    1e92:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    1e96:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1e9a:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1e9e:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1ea2:	8c 15       	cp	r24, r12
    1ea4:	9d 05       	cpc	r25, r13
    1ea6:	ae 05       	cpc	r26, r14
    1ea8:	bf 05       	cpc	r27, r15
    1eaa:	98 f0       	brcs	.+38     	; 0x1ed2 <vTaskDelayUntil+0xb8>
    1eac:	17 c0       	rjmp	.+46     	; 0x1edc <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1eae:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    1eb2:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1eb6:	02 96       	adiw	r24, 0x02	; 2
    1eb8:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1ebc:	c7 01       	movw	r24, r14
    1ebe:	b6 01       	movw	r22, r12
    1ec0:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1ec4:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ec8:	81 11       	cpse	r24, r1
    1eca:	0d c0       	rjmp	.+26     	; 0x1ee6 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    1ecc:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
		}
	}
    1ed0:	0a c0       	rjmp	.+20     	; 0x1ee6 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1ed2:	c8 82       	st	Y, r12
    1ed4:	d9 82       	std	Y+1, r13	; 0x01
    1ed6:	ea 82       	std	Y+2, r14	; 0x02
    1ed8:	fb 82       	std	Y+3, r15	; 0x03
    1eda:	e9 cf       	rjmp	.-46     	; 0x1eae <vTaskDelayUntil+0x94>
    1edc:	c8 82       	st	Y, r12
    1ede:	d9 82       	std	Y+1, r13	; 0x01
    1ee0:	ea 82       	std	Y+2, r14	; 0x02
    1ee2:	fb 82       	std	Y+3, r15	; 0x03
    1ee4:	ef cf       	rjmp	.-34     	; 0x1ec4 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1ee6:	df 91       	pop	r29
    1ee8:	cf 91       	pop	r28
    1eea:	ff 90       	pop	r15
    1eec:	ef 90       	pop	r14
    1eee:	df 90       	pop	r13
    1ef0:	cf 90       	pop	r12
    1ef2:	08 95       	ret

00001ef4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1ef4:	cf 92       	push	r12
    1ef6:	df 92       	push	r13
    1ef8:	ef 92       	push	r14
    1efa:	ff 92       	push	r15
    1efc:	6b 01       	movw	r12, r22
    1efe:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1f00:	67 2b       	or	r22, r23
    1f02:	68 2b       	or	r22, r24
    1f04:	69 2b       	or	r22, r25
    1f06:	e9 f0       	breq	.+58     	; 0x1f42 <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    1f08:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1f0c:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    1f10:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    1f14:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    1f18:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    1f1c:	c8 0e       	add	r12, r24
    1f1e:	d9 1e       	adc	r13, r25
    1f20:	ea 1e       	adc	r14, r26
    1f22:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1f24:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    1f28:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    1f2c:	02 96       	adiw	r24, 0x02	; 2
    1f2e:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1f32:	c7 01       	movw	r24, r14
    1f34:	b6 01       	movw	r22, r12
    1f36:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1f3a:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1f3e:	81 11       	cpse	r24, r1
    1f40:	02 c0       	rjmp	.+4      	; 0x1f46 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    1f42:	0e 94 2c 08 	call	0x1058	; 0x1058 <vPortYield>
		}
	}
    1f46:	ff 90       	pop	r15
    1f48:	ef 90       	pop	r14
    1f4a:	df 90       	pop	r13
    1f4c:	cf 90       	pop	r12
    1f4e:	08 95       	ret

00001f50 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1f50:	80 91 ec 40 	lds	r24, 0x40EC	; 0x8040ec <uxSchedulerSuspended>
    1f54:	81 11       	cpse	r24, r1
    1f56:	0c c0       	rjmp	.+24     	; 0x1f70 <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1f58:	e0 91 ee 40 	lds	r30, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    1f5c:	4b e0       	ldi	r20, 0x0B	; 11
    1f5e:	e4 9f       	mul	r30, r20
    1f60:	f0 01       	movw	r30, r0
    1f62:	11 24       	eor	r1, r1
    1f64:	e4 5e       	subi	r30, 0xE4	; 228
    1f66:	fe 4b       	sbci	r31, 0xBE	; 190
    1f68:	80 81       	ld	r24, Z
    1f6a:	88 23       	and	r24, r24
    1f6c:	29 f0       	breq	.+10     	; 0x1f78 <vTaskSwitchContext+0x28>
    1f6e:	14 c0       	rjmp	.+40     	; 0x1f98 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1f70:	81 e0       	ldi	r24, 0x01	; 1
    1f72:	80 93 ea 40 	sts	0x40EA, r24	; 0x8040ea <xMissedYield>
    1f76:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1f78:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1f7a:	80 91 ee 40 	lds	r24, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    1f7e:	81 50       	subi	r24, 0x01	; 1
    1f80:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1f84:	e0 91 ee 40 	lds	r30, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    1f88:	9e 9f       	mul	r25, r30
    1f8a:	f0 01       	movw	r30, r0
    1f8c:	11 24       	eor	r1, r1
    1f8e:	e4 5e       	subi	r30, 0xE4	; 228
    1f90:	fe 4b       	sbci	r31, 0xBE	; 190
    1f92:	80 81       	ld	r24, Z
    1f94:	88 23       	and	r24, r24
    1f96:	89 f3       	breq	.-30     	; 0x1f7a <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1f98:	80 91 ee 40 	lds	r24, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    1f9c:	28 2f       	mov	r18, r24
    1f9e:	30 e0       	ldi	r19, 0x00	; 0
    1fa0:	4b e0       	ldi	r20, 0x0B	; 11
    1fa2:	84 9f       	mul	r24, r20
    1fa4:	c0 01       	movw	r24, r0
    1fa6:	11 24       	eor	r1, r1
    1fa8:	dc 01       	movw	r26, r24
    1faa:	a4 5e       	subi	r26, 0xE4	; 228
    1fac:	be 4b       	sbci	r27, 0xBE	; 190
    1fae:	11 96       	adiw	r26, 0x01	; 1
    1fb0:	ed 91       	ld	r30, X+
    1fb2:	fc 91       	ld	r31, X
    1fb4:	12 97       	sbiw	r26, 0x02	; 2
    1fb6:	04 80       	ldd	r0, Z+4	; 0x04
    1fb8:	f5 81       	ldd	r31, Z+5	; 0x05
    1fba:	e0 2d       	mov	r30, r0
    1fbc:	11 96       	adiw	r26, 0x01	; 1
    1fbe:	ed 93       	st	X+, r30
    1fc0:	fc 93       	st	X, r31
    1fc2:	12 97       	sbiw	r26, 0x02	; 2
    1fc4:	81 5e       	subi	r24, 0xE1	; 225
    1fc6:	9e 4b       	sbci	r25, 0xBE	; 190
    1fc8:	e8 17       	cp	r30, r24
    1fca:	f9 07       	cpc	r31, r25
    1fcc:	61 f4       	brne	.+24     	; 0x1fe6 <vTaskSwitchContext+0x96>
    1fce:	84 81       	ldd	r24, Z+4	; 0x04
    1fd0:	95 81       	ldd	r25, Z+5	; 0x05
    1fd2:	4b e0       	ldi	r20, 0x0B	; 11
    1fd4:	42 9f       	mul	r20, r18
    1fd6:	f0 01       	movw	r30, r0
    1fd8:	43 9f       	mul	r20, r19
    1fda:	f0 0d       	add	r31, r0
    1fdc:	11 24       	eor	r1, r1
    1fde:	e4 5e       	subi	r30, 0xE4	; 228
    1fe0:	fe 4b       	sbci	r31, 0xBE	; 190
    1fe2:	81 83       	std	Z+1, r24	; 0x01
    1fe4:	92 83       	std	Z+2, r25	; 0x02
    1fe6:	8b e0       	ldi	r24, 0x0B	; 11
    1fe8:	82 9f       	mul	r24, r18
    1fea:	f0 01       	movw	r30, r0
    1fec:	83 9f       	mul	r24, r19
    1fee:	f0 0d       	add	r31, r0
    1ff0:	11 24       	eor	r1, r1
    1ff2:	e4 5e       	subi	r30, 0xE4	; 228
    1ff4:	fe 4b       	sbci	r31, 0xBE	; 190
    1ff6:	01 80       	ldd	r0, Z+1	; 0x01
    1ff8:	f2 81       	ldd	r31, Z+2	; 0x02
    1ffa:	e0 2d       	mov	r30, r0
    1ffc:	80 85       	ldd	r24, Z+8	; 0x08
    1ffe:	91 85       	ldd	r25, Z+9	; 0x09
    2000:	80 93 48 41 	sts	0x4148, r24	; 0x804148 <pxCurrentTCB>
    2004:	90 93 49 41 	sts	0x4149, r25	; 0x804149 <pxCurrentTCB+0x1>
    2008:	08 95       	ret

0000200a <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    200a:	cf 92       	push	r12
    200c:	df 92       	push	r13
    200e:	ef 92       	push	r14
    2010:	ff 92       	push	r15
    2012:	6a 01       	movw	r12, r20
    2014:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2016:	60 91 48 41 	lds	r22, 0x4148	; 0x804148 <pxCurrentTCB>
    201a:	70 91 49 41 	lds	r23, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    201e:	62 5f       	subi	r22, 0xF2	; 242
    2020:	7f 4f       	sbci	r23, 0xFF	; 255
    2022:	0e 94 05 07 	call	0xe0a	; 0xe0a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2026:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    202a:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    202e:	02 96       	adiw	r24, 0x02	; 2
    2030:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2034:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    2038:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    203c:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    2040:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2044:	bc 01       	movw	r22, r24
    2046:	cd 01       	movw	r24, r26
    2048:	6c 0d       	add	r22, r12
    204a:	7d 1d       	adc	r23, r13
    204c:	8e 1d       	adc	r24, r14
    204e:	9f 1d       	adc	r25, r15
    2050:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2054:	ff 90       	pop	r15
    2056:	ef 90       	pop	r14
    2058:	df 90       	pop	r13
    205a:	cf 90       	pop	r12
    205c:	08 95       	ret

0000205e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    205e:	0f 93       	push	r16
    2060:	1f 93       	push	r17
    2062:	cf 93       	push	r28
    2064:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2066:	dc 01       	movw	r26, r24
    2068:	17 96       	adiw	r26, 0x07	; 7
    206a:	ed 91       	ld	r30, X+
    206c:	fc 91       	ld	r31, X
    206e:	18 97       	sbiw	r26, 0x08	; 8
    2070:	c0 85       	ldd	r28, Z+8	; 0x08
    2072:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2074:	8e 01       	movw	r16, r28
    2076:	02 5f       	subi	r16, 0xF2	; 242
    2078:	1f 4f       	sbci	r17, 0xFF	; 255
    207a:	c8 01       	movw	r24, r16
    207c:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2080:	80 91 ec 40 	lds	r24, 0x40EC	; 0x8040ec <uxSchedulerSuspended>
    2084:	81 11       	cpse	r24, r1
    2086:	16 c0       	rjmp	.+44     	; 0x20b4 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2088:	0c 50       	subi	r16, 0x0C	; 12
    208a:	11 09       	sbc	r17, r1
    208c:	c8 01       	movw	r24, r16
    208e:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2092:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2094:	90 91 ee 40 	lds	r25, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    2098:	98 17       	cp	r25, r24
    209a:	10 f4       	brcc	.+4      	; 0x20a0 <xTaskRemoveFromEventList+0x42>
    209c:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
    20a0:	bb e0       	ldi	r27, 0x0B	; 11
    20a2:	8b 9f       	mul	r24, r27
    20a4:	c0 01       	movw	r24, r0
    20a6:	11 24       	eor	r1, r1
    20a8:	b8 01       	movw	r22, r16
    20aa:	84 5e       	subi	r24, 0xE4	; 228
    20ac:	9e 4b       	sbci	r25, 0xBE	; 190
    20ae:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>
    20b2:	05 c0       	rjmp	.+10     	; 0x20be <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    20b4:	b8 01       	movw	r22, r16
    20b6:	87 ef       	ldi	r24, 0xF7	; 247
    20b8:	90 e4       	ldi	r25, 0x40	; 64
    20ba:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    20be:	e0 91 48 41 	lds	r30, 0x4148	; 0x804148 <pxCurrentTCB>
    20c2:	f0 91 49 41 	lds	r31, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    20c6:	81 e0       	ldi	r24, 0x01	; 1
    20c8:	2a 8d       	ldd	r18, Y+26	; 0x1a
    20ca:	92 8d       	ldd	r25, Z+26	; 0x1a
    20cc:	29 17       	cp	r18, r25
    20ce:	08 f4       	brcc	.+2      	; 0x20d2 <xTaskRemoveFromEventList+0x74>
    20d0:	80 e0       	ldi	r24, 0x00	; 0
}
    20d2:	df 91       	pop	r29
    20d4:	cf 91       	pop	r28
    20d6:	1f 91       	pop	r17
    20d8:	0f 91       	pop	r16
    20da:	08 95       	ret

000020dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    20dc:	20 91 e9 40 	lds	r18, 0x40E9	; 0x8040e9 <xNumOfOverflows>
    20e0:	fc 01       	movw	r30, r24
    20e2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    20e4:	40 91 f0 40 	lds	r20, 0x40F0	; 0x8040f0 <xTickCount>
    20e8:	50 91 f1 40 	lds	r21, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    20ec:	60 91 f2 40 	lds	r22, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    20f0:	70 91 f3 40 	lds	r23, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    20f4:	41 83       	std	Z+1, r20	; 0x01
    20f6:	52 83       	std	Z+2, r21	; 0x02
    20f8:	63 83       	std	Z+3, r22	; 0x03
    20fa:	74 83       	std	Z+4, r23	; 0x04
    20fc:	08 95       	ret

000020fe <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    20fe:	8f 92       	push	r8
    2100:	9f 92       	push	r9
    2102:	af 92       	push	r10
    2104:	bf 92       	push	r11
    2106:	cf 92       	push	r12
    2108:	df 92       	push	r13
    210a:	ef 92       	push	r14
    210c:	ff 92       	push	r15
    210e:	0f 93       	push	r16
    2110:	1f 93       	push	r17
    2112:	cf 93       	push	r28
    2114:	df 93       	push	r29
    2116:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2118:	0f b6       	in	r0, 0x3f	; 63
    211a:	f8 94       	cli
    211c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    211e:	80 91 e9 40 	lds	r24, 0x40E9	; 0x8040e9 <xNumOfOverflows>
    2122:	90 81       	ld	r25, Z
    2124:	98 17       	cp	r25, r24
    2126:	89 f0       	breq	.+34     	; 0x214a <xTaskCheckForTimeOut+0x4c>
    2128:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    212c:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    2130:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    2134:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    2138:	01 81       	ldd	r16, Z+1	; 0x01
    213a:	12 81       	ldd	r17, Z+2	; 0x02
    213c:	23 81       	ldd	r18, Z+3	; 0x03
    213e:	34 81       	ldd	r19, Z+4	; 0x04
    2140:	80 17       	cp	r24, r16
    2142:	91 07       	cpc	r25, r17
    2144:	a2 07       	cpc	r26, r18
    2146:	b3 07       	cpc	r27, r19
    2148:	a8 f5       	brcc	.+106    	; 0x21b4 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    214a:	80 91 f0 40 	lds	r24, 0x40F0	; 0x8040f0 <xTickCount>
    214e:	90 91 f1 40 	lds	r25, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    2152:	a0 91 f2 40 	lds	r26, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    2156:	b0 91 f3 40 	lds	r27, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    215a:	c1 80       	ldd	r12, Z+1	; 0x01
    215c:	d2 80       	ldd	r13, Z+2	; 0x02
    215e:	e3 80       	ldd	r14, Z+3	; 0x03
    2160:	f4 80       	ldd	r15, Z+4	; 0x04
    2162:	eb 01       	movw	r28, r22
    2164:	08 81       	ld	r16, Y
    2166:	19 81       	ldd	r17, Y+1	; 0x01
    2168:	2a 81       	ldd	r18, Y+2	; 0x02
    216a:	3b 81       	ldd	r19, Y+3	; 0x03
    216c:	8c 19       	sub	r24, r12
    216e:	9d 09       	sbc	r25, r13
    2170:	ae 09       	sbc	r26, r14
    2172:	bf 09       	sbc	r27, r15
    2174:	80 17       	cp	r24, r16
    2176:	91 07       	cpc	r25, r17
    2178:	a2 07       	cpc	r26, r18
    217a:	b3 07       	cpc	r27, r19
    217c:	e8 f4       	brcc	.+58     	; 0x21b8 <xTaskCheckForTimeOut+0xba>
    217e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2180:	80 90 f0 40 	lds	r8, 0x40F0	; 0x8040f0 <xTickCount>
    2184:	90 90 f1 40 	lds	r9, 0x40F1	; 0x8040f1 <xTickCount+0x1>
    2188:	a0 90 f2 40 	lds	r10, 0x40F2	; 0x8040f2 <xTickCount+0x2>
    218c:	b0 90 f3 40 	lds	r11, 0x40F3	; 0x8040f3 <xTickCount+0x3>
    2190:	b5 01       	movw	r22, r10
    2192:	a4 01       	movw	r20, r8
    2194:	4c 19       	sub	r20, r12
    2196:	5d 09       	sbc	r21, r13
    2198:	6e 09       	sbc	r22, r14
    219a:	7f 09       	sbc	r23, r15
    219c:	04 1b       	sub	r16, r20
    219e:	15 0b       	sbc	r17, r21
    21a0:	26 0b       	sbc	r18, r22
    21a2:	37 0b       	sbc	r19, r23
    21a4:	08 83       	st	Y, r16
    21a6:	19 83       	std	Y+1, r17	; 0x01
    21a8:	2a 83       	std	Y+2, r18	; 0x02
    21aa:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    21ac:	0e 94 6e 10 	call	0x20dc	; 0x20dc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    21b0:	80 e0       	ldi	r24, 0x00	; 0
    21b2:	03 c0       	rjmp	.+6      	; 0x21ba <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    21b4:	81 e0       	ldi	r24, 0x01	; 1
    21b6:	01 c0       	rjmp	.+2      	; 0x21ba <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    21b8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    21ba:	0f 90       	pop	r0
    21bc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    21be:	df 91       	pop	r29
    21c0:	cf 91       	pop	r28
    21c2:	1f 91       	pop	r17
    21c4:	0f 91       	pop	r16
    21c6:	ff 90       	pop	r15
    21c8:	ef 90       	pop	r14
    21ca:	df 90       	pop	r13
    21cc:	cf 90       	pop	r12
    21ce:	bf 90       	pop	r11
    21d0:	af 90       	pop	r10
    21d2:	9f 90       	pop	r9
    21d4:	8f 90       	pop	r8
    21d6:	08 95       	ret

000021d8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    21d8:	81 e0       	ldi	r24, 0x01	; 1
    21da:	80 93 ea 40 	sts	0x40EA, r24	; 0x8040ea <xMissedYield>
    21de:	08 95       	ret

000021e0 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    21e0:	00 97       	sbiw	r24, 0x00	; 0
    21e2:	21 f4       	brne	.+8      	; 0x21ec <uxTaskGetStackHighWaterMark+0xc>
    21e4:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    21e8:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    21ec:	dc 01       	movw	r26, r24
    21ee:	5b 96       	adiw	r26, 0x1b	; 27
    21f0:	ed 91       	ld	r30, X+
    21f2:	fc 91       	ld	r31, X
    21f4:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    21f6:	80 81       	ld	r24, Z
    21f8:	81 31       	cpi	r24, 0x11	; 17
    21fa:	41 f4       	brne	.+16     	; 0x220c <uxTaskGetStackHighWaterMark+0x2c>
    21fc:	31 96       	adiw	r30, 0x01	; 1
    21fe:	80 e0       	ldi	r24, 0x00	; 0
    2200:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    2202:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2204:	21 91       	ld	r18, Z+
    2206:	21 31       	cpi	r18, 0x11	; 17
    2208:	e1 f3       	breq	.-8      	; 0x2202 <uxTaskGetStackHighWaterMark+0x22>
    220a:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    220c:	80 e0       	ldi	r24, 0x00	; 0
    220e:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    2210:	08 95       	ret

00002212 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    2212:	80 91 48 41 	lds	r24, 0x4148	; 0x804148 <pxCurrentTCB>
    2216:	90 91 49 41 	lds	r25, 0x4149	; 0x804149 <pxCurrentTCB+0x1>

		return xReturn;
	}
    221a:	08 95       	ret

0000221c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    221c:	0f 93       	push	r16
    221e:	1f 93       	push	r17
    2220:	cf 93       	push	r28
    2222:	df 93       	push	r29
    2224:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2226:	22 8d       	ldd	r18, Z+26	; 0x1a
    2228:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    222c:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    2230:	5a 96       	adiw	r26, 0x1a	; 26
    2232:	8c 91       	ld	r24, X
    2234:	28 17       	cp	r18, r24
    2236:	08 f0       	brcs	.+2      	; 0x223a <vTaskPriorityInherit+0x1e>
    2238:	41 c0       	rjmp	.+130    	; 0x22bc <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    223a:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    223e:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    2242:	5a 96       	adiw	r26, 0x1a	; 26
    2244:	3c 91       	ld	r19, X
    2246:	84 e0       	ldi	r24, 0x04	; 4
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	a0 e0       	ldi	r26, 0x00	; 0
    224c:	b0 e0       	ldi	r27, 0x00	; 0
    224e:	83 1b       	sub	r24, r19
    2250:	91 09       	sbc	r25, r1
    2252:	a1 09       	sbc	r26, r1
    2254:	b1 09       	sbc	r27, r1
    2256:	86 87       	std	Z+14, r24	; 0x0e
    2258:	97 87       	std	Z+15, r25	; 0x0f
    225a:	a0 8b       	std	Z+16, r26	; 0x10
    225c:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    225e:	8b e0       	ldi	r24, 0x0B	; 11
    2260:	28 9f       	mul	r18, r24
    2262:	90 01       	movw	r18, r0
    2264:	11 24       	eor	r1, r1
    2266:	24 5e       	subi	r18, 0xE4	; 228
    2268:	3e 4b       	sbci	r19, 0xBE	; 190
    226a:	84 85       	ldd	r24, Z+12	; 0x0c
    226c:	95 85       	ldd	r25, Z+13	; 0x0d
    226e:	82 17       	cp	r24, r18
    2270:	93 07       	cpc	r25, r19
    2272:	e9 f4       	brne	.+58     	; 0x22ae <vTaskPriorityInherit+0x92>
    2274:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    2276:	ef 01       	movw	r28, r30
    2278:	22 96       	adiw	r28, 0x02	; 2
    227a:	ce 01       	movw	r24, r28
    227c:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2280:	e0 91 48 41 	lds	r30, 0x4148	; 0x804148 <pxCurrentTCB>
    2284:	f0 91 49 41 	lds	r31, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    2288:	82 8d       	ldd	r24, Z+26	; 0x1a
    228a:	f8 01       	movw	r30, r16
    228c:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    228e:	90 91 ee 40 	lds	r25, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    2292:	98 17       	cp	r25, r24
    2294:	10 f4       	brcc	.+4      	; 0x229a <vTaskPriorityInherit+0x7e>
    2296:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
    229a:	fb e0       	ldi	r31, 0x0B	; 11
    229c:	8f 9f       	mul	r24, r31
    229e:	c0 01       	movw	r24, r0
    22a0:	11 24       	eor	r1, r1
    22a2:	be 01       	movw	r22, r28
    22a4:	84 5e       	subi	r24, 0xE4	; 228
    22a6:	9e 4b       	sbci	r25, 0xBE	; 190
    22a8:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>
    22ac:	07 c0       	rjmp	.+14     	; 0x22bc <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    22ae:	a0 91 48 41 	lds	r26, 0x4148	; 0x804148 <pxCurrentTCB>
    22b2:	b0 91 49 41 	lds	r27, 0x4149	; 0x804149 <pxCurrentTCB+0x1>
    22b6:	5a 96       	adiw	r26, 0x1a	; 26
    22b8:	8c 91       	ld	r24, X
    22ba:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    22bc:	df 91       	pop	r29
    22be:	cf 91       	pop	r28
    22c0:	1f 91       	pop	r17
    22c2:	0f 91       	pop	r16
    22c4:	08 95       	ret

000022c6 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    22c6:	0f 93       	push	r16
    22c8:	1f 93       	push	r17
    22ca:	cf 93       	push	r28
    22cc:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    22ce:	00 97       	sbiw	r24, 0x00	; 0
    22d0:	49 f1       	breq	.+82     	; 0x2324 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    22d2:	fc 01       	movw	r30, r24
    22d4:	32 8d       	ldd	r19, Z+26	; 0x1a
    22d6:	27 a1       	ldd	r18, Z+39	; 0x27
    22d8:	32 17       	cp	r19, r18
    22da:	21 f1       	breq	.+72     	; 0x2324 <vTaskPriorityDisinherit+0x5e>
    22dc:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    22de:	8c 01       	movw	r16, r24
    22e0:	0e 5f       	subi	r16, 0xFE	; 254
    22e2:	1f 4f       	sbci	r17, 0xFF	; 255
    22e4:	c8 01       	movw	r24, r16
    22e6:	0e 94 50 07 	call	0xea0	; 0xea0 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    22ea:	8f a1       	ldd	r24, Y+39	; 0x27
    22ec:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    22ee:	44 e0       	ldi	r20, 0x04	; 4
    22f0:	50 e0       	ldi	r21, 0x00	; 0
    22f2:	60 e0       	ldi	r22, 0x00	; 0
    22f4:	70 e0       	ldi	r23, 0x00	; 0
    22f6:	48 1b       	sub	r20, r24
    22f8:	51 09       	sbc	r21, r1
    22fa:	61 09       	sbc	r22, r1
    22fc:	71 09       	sbc	r23, r1
    22fe:	4e 87       	std	Y+14, r20	; 0x0e
    2300:	5f 87       	std	Y+15, r21	; 0x0f
    2302:	68 8b       	std	Y+16, r22	; 0x10
    2304:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2306:	90 91 ee 40 	lds	r25, 0x40EE	; 0x8040ee <uxTopReadyPriority>
    230a:	98 17       	cp	r25, r24
    230c:	10 f4       	brcc	.+4      	; 0x2312 <vTaskPriorityDisinherit+0x4c>
    230e:	80 93 ee 40 	sts	0x40EE, r24	; 0x8040ee <uxTopReadyPriority>
    2312:	fb e0       	ldi	r31, 0x0B	; 11
    2314:	8f 9f       	mul	r24, r31
    2316:	c0 01       	movw	r24, r0
    2318:	11 24       	eor	r1, r1
    231a:	b8 01       	movw	r22, r16
    231c:	84 5e       	subi	r24, 0xE4	; 228
    231e:	9e 4b       	sbci	r25, 0xBE	; 190
    2320:	0e 94 de 06 	call	0xdbc	; 0xdbc <vListInsertEnd>
			}
		}
	}
    2324:	df 91       	pop	r29
    2326:	cf 91       	pop	r28
    2328:	1f 91       	pop	r17
    232a:	0f 91       	pop	r16
    232c:	08 95       	ret

0000232e <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    232e:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    2330:	e8 81       	ld	r30, Y
    2332:	f9 81       	ldd	r31, Y+1	; 0x01
    2334:	01 90       	ld	r0, Z+
    2336:	f0 81       	ld	r31, Z
    2338:	e0 2d       	mov	r30, r0
    233a:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    233c:	1a 82       	std	Y+2, r1	; 0x02
    233e:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    2340:	6f ef       	ldi	r22, 0xFF	; 255
    2342:	7f ef       	ldi	r23, 0xFF	; 255
    2344:	cb 01       	movw	r24, r22
    2346:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <vTaskDelay>
    234a:	fa cf       	rjmp	.-12     	; 0x2340 <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

0000234c <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    234c:	fc 01       	movw	r30, r24
    234e:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    2350:	65 87       	std	Z+13, r22	; 0x0d
    2352:	08 95       	ret

00002354 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2354:	4f 92       	push	r4
    2356:	5f 92       	push	r5
    2358:	6f 92       	push	r6
    235a:	7f 92       	push	r7
    235c:	8f 92       	push	r8
    235e:	9f 92       	push	r9
    2360:	af 92       	push	r10
    2362:	bf 92       	push	r11
    2364:	cf 92       	push	r12
    2366:	df 92       	push	r13
    2368:	ef 92       	push	r14
    236a:	ff 92       	push	r15
    236c:	0f 93       	push	r16
    236e:	1f 93       	push	r17
    2370:	cf 93       	push	r28
    2372:	df 93       	push	r29
    2374:	cd b7       	in	r28, 0x3d	; 61
    2376:	de b7       	in	r29, 0x3e	; 62
    2378:	2a 97       	sbiw	r28, 0x0a	; 10
    237a:	cd bf       	out	0x3d, r28	; 61
    237c:	de bf       	out	0x3e, r29	; 62
    237e:	4c 01       	movw	r8, r24
    2380:	29 01       	movw	r4, r18
    2382:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    2384:	80 e3       	ldi	r24, 0x30	; 48
    2386:	90 e2       	ldi	r25, 0x20	; 32
    2388:	f4 01       	movw	r30, r8
    238a:	80 83       	st	Z, r24
    238c:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    238e:	fb 01       	movw	r30, r22
    2390:	80 81       	ld	r24, Z
    2392:	88 23       	and	r24, r24
    2394:	69 f0       	breq	.+26     	; 0x23b0 <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    2396:	de 01       	movw	r26, r28
    2398:	11 96       	adiw	r26, 0x01	; 1
    239a:	31 96       	adiw	r30, 0x01	; 1
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	02 c0       	rjmp	.+4      	; 0x23a4 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    23a0:	99 30       	cpi	r25, 0x09	; 9
    23a2:	39 f0       	breq	.+14     	; 0x23b2 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    23a4:	9f 5f       	subi	r25, 0xFF	; 255
    23a6:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    23a8:	81 91       	ld	r24, Z+
    23aa:	81 11       	cpse	r24, r1
    23ac:	f9 cf       	rjmp	.-14     	; 0x23a0 <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    23ae:	01 c0       	rjmp	.+2      	; 0x23b2 <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    23b0:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    23b2:	e1 e0       	ldi	r30, 0x01	; 1
    23b4:	f0 e0       	ldi	r31, 0x00	; 0
    23b6:	ec 0f       	add	r30, r28
    23b8:	fd 1f       	adc	r31, r29
    23ba:	e9 0f       	add	r30, r25
    23bc:	f1 1d       	adc	r31, r1
    23be:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    23c0:	74 01       	movw	r14, r8
    23c2:	f2 e0       	ldi	r31, 0x02	; 2
    23c4:	ef 0e       	add	r14, r31
    23c6:	f1 1c       	adc	r15, r1
    23c8:	a1 2c       	mov	r10, r1
    23ca:	b1 2c       	mov	r11, r1
    23cc:	c1 2c       	mov	r12, r1
    23ce:	d1 2c       	mov	r13, r1
    23d0:	04 2f       	mov	r16, r20
    23d2:	94 01       	movw	r18, r8
    23d4:	a2 01       	movw	r20, r4
    23d6:	be 01       	movw	r22, r28
    23d8:	6f 5f       	subi	r22, 0xFF	; 255
    23da:	7f 4f       	sbci	r23, 0xFF	; 255
    23dc:	8d ee       	ldi	r24, 0xED	; 237
    23de:	92 e0       	ldi	r25, 0x02	; 2
    23e0:	0e 94 26 0c 	call	0x184c	; 0x184c <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    23e4:	f4 01       	movw	r30, r8
    23e6:	66 82       	std	Z+6, r6	; 0x06
    23e8:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    23ea:	40 86       	std	Z+8, r4	; 0x08
    23ec:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    23ee:	20 91 4a 41 	lds	r18, 0x414A	; 0x80414a <last_created_task_pointer>
    23f2:	30 91 4b 41 	lds	r19, 0x414B	; 0x80414b <last_created_task_pointer+0x1>
    23f6:	24 83       	std	Z+4, r18	; 0x04
    23f8:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    23fa:	80 92 4a 41 	sts	0x414A, r8	; 0x80414a <last_created_task_pointer>
    23fe:	90 92 4b 41 	sts	0x414B, r9	; 0x80414b <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    2402:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2404:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2406:	40 90 6b 42 	lds	r4, 0x426B	; 0x80426b <portStackTopForTask>
    240a:	50 90 6c 42 	lds	r5, 0x426C	; 0x80426c <portStackTopForTask+0x1>
    240e:	ff ef       	ldi	r31, 0xFF	; 255
    2410:	4f 1a       	sub	r4, r31
    2412:	5f 0a       	sbc	r5, r31
    2414:	40 92 6b 42 	sts	0x426B, r4	; 0x80426b <portStackTopForTask>
    2418:	50 92 6c 42 	sts	0x426C, r5	; 0x80426c <portStackTopForTask+0x1>
    241c:	f4 01       	movw	r30, r8
    241e:	42 86       	std	Z+10, r4	; 0x0a
    2420:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    2422:	16 86       	std	Z+14, r1	; 0x0e
    2424:	17 86       	std	Z+15, r1	; 0x0f
    2426:	10 8a       	std	Z+16, r1	; 0x10
    2428:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    242a:	61 14       	cp	r6, r1
    242c:	71 04       	cpc	r7, r1
    242e:	09 f4       	brne	.+2      	; 0x2432 <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    2430:	44 c0       	rjmp	.+136    	; 0x24ba <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    2432:	81 30       	cpi	r24, 0x01	; 1
    2434:	79 f5       	brne	.+94     	; 0x2494 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2436:	6a e0       	ldi	r22, 0x0A	; 10
    2438:	c3 01       	movw	r24, r6
    243a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    243e:	7c 01       	movw	r14, r24
    2440:	67 e2       	ldi	r22, 0x27	; 39
    2442:	75 e0       	ldi	r23, 0x05	; 5
    2444:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2448:	be 01       	movw	r22, r28
    244a:	6f 5f       	subi	r22, 0xFF	; 255
    244c:	7f 4f       	sbci	r23, 0xFF	; 255
    244e:	c7 01       	movw	r24, r14
    2450:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2454:	6a e0       	ldi	r22, 0x0A	; 10
    2456:	c7 01       	movw	r24, r14
    2458:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    245c:	7c 01       	movw	r14, r24
    245e:	6e e1       	ldi	r22, 0x1E	; 30
    2460:	75 e0       	ldi	r23, 0x05	; 5
    2462:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2466:	6a e0       	ldi	r22, 0x0A	; 10
    2468:	c7 01       	movw	r24, r14
    246a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    246e:	7c 01       	movw	r14, r24
    2470:	60 e1       	ldi	r22, 0x10	; 16
    2472:	75 e0       	ldi	r23, 0x05	; 5
    2474:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2478:	63 e0       	ldi	r22, 0x03	; 3
    247a:	c7 01       	movw	r24, r14
    247c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2480:	b2 01       	movw	r22, r4
    2482:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN8emstreamlsEj>
    2486:	62 e0       	ldi	r22, 0x02	; 2
    2488:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    248c:	66 e0       	ldi	r22, 0x06	; 6
    248e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2492:	13 c0       	rjmp	.+38     	; 0x24ba <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    2494:	6a e0       	ldi	r22, 0x0A	; 10
    2496:	c3 01       	movw	r24, r6
    2498:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    249c:	4c 01       	movw	r8, r24
    249e:	6b ef       	ldi	r22, 0xFB	; 251
    24a0:	74 e0       	ldi	r23, 0x04	; 4
    24a2:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    24a6:	be 01       	movw	r22, r28
    24a8:	6f 5f       	subi	r22, 0xFF	; 255
    24aa:	7f 4f       	sbci	r23, 0xFF	; 255
    24ac:	c4 01       	movw	r24, r8
    24ae:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    24b2:	66 e0       	ldi	r22, 0x06	; 6
    24b4:	c4 01       	movw	r24, r8
    24b6:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    24ba:	2a 96       	adiw	r28, 0x0a	; 10
    24bc:	cd bf       	out	0x3d, r28	; 61
    24be:	de bf       	out	0x3e, r29	; 62
    24c0:	df 91       	pop	r29
    24c2:	cf 91       	pop	r28
    24c4:	1f 91       	pop	r17
    24c6:	0f 91       	pop	r16
    24c8:	ff 90       	pop	r15
    24ca:	ef 90       	pop	r14
    24cc:	df 90       	pop	r13
    24ce:	cf 90       	pop	r12
    24d0:	bf 90       	pop	r11
    24d2:	af 90       	pop	r10
    24d4:	9f 90       	pop	r9
    24d6:	8f 90       	pop	r8
    24d8:	7f 90       	pop	r7
    24da:	6f 90       	pop	r6
    24dc:	5f 90       	pop	r5
    24de:	4f 90       	pop	r4
    24e0:	08 95       	ret

000024e2 <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    24e2:	cf 92       	push	r12
    24e4:	df 92       	push	r13
    24e6:	ef 92       	push	r14
    24e8:	ff 92       	push	r15
    24ea:	0f 93       	push	r16
    24ec:	1f 93       	push	r17
    24ee:	cf 93       	push	r28
    24f0:	df 93       	push	r29
    24f2:	ec 01       	movw	r28, r24
    24f4:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    24f6:	8a 81       	ldd	r24, Y+2	; 0x02
    24f8:	9b 81       	ldd	r25, Y+3	; 0x03
    24fa:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <pcTaskGetTaskName>
    24fe:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    2500:	6a e0       	ldi	r22, 0x0A	; 10
    2502:	c7 01       	movw	r24, r14
    2504:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2508:	8c 01       	movw	r16, r24
    250a:	6a e3       	ldi	r22, 0x3A	; 58
    250c:	75 e0       	ldi	r23, 0x05	; 5
    250e:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2512:	6a e0       	ldi	r22, 0x0A	; 10
    2514:	c8 01       	movw	r24, r16
    2516:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    251a:	8c 01       	movw	r16, r24
    251c:	63 e3       	ldi	r22, 0x33	; 51
    251e:	75 e0       	ldi	r23, 0x05	; 5
    2520:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2524:	b6 01       	movw	r22, r12
    2526:	c8 01       	movw	r24, r16
    2528:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    252c:	6a e0       	ldi	r22, 0x0A	; 10
    252e:	c8 01       	movw	r24, r16
    2530:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2534:	8c 01       	movw	r16, r24
    2536:	6d e2       	ldi	r22, 0x2D	; 45
    2538:	75 e0       	ldi	r23, 0x05	; 5
    253a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    253e:	66 e0       	ldi	r22, 0x06	; 6
    2540:	c8 01       	movw	r24, r16
    2542:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2546:	8a 85       	ldd	r24, Y+10	; 0x0a
    2548:	9b 85       	ldd	r25, Y+11	; 0x0b
    254a:	e8 85       	ldd	r30, Y+8	; 0x08
    254c:	f9 85       	ldd	r31, Y+9	; 0x09
    254e:	01 e1       	ldi	r16, 0x11	; 17
    2550:	21 e0       	ldi	r18, 0x01	; 1
    2552:	a7 01       	movw	r20, r14
    2554:	bc 01       	movw	r22, r24
    2556:	8e 1b       	sub	r24, r30
    2558:	9f 0b       	sbc	r25, r31
    255a:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    255e:	8c 81       	ldd	r24, Y+4	; 0x04
    2560:	9d 81       	ldd	r25, Y+5	; 0x05
    2562:	00 97       	sbiw	r24, 0x00	; 0
    2564:	19 f0       	breq	.+6      	; 0x256c <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2566:	b7 01       	movw	r22, r14
    2568:	0e 94 71 12 	call	0x24e2	; 0x24e2 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    256c:	df 91       	pop	r29
    256e:	cf 91       	pop	r28
    2570:	1f 91       	pop	r17
    2572:	0f 91       	pop	r16
    2574:	ff 90       	pop	r15
    2576:	ef 90       	pop	r14
    2578:	df 90       	pop	r13
    257a:	cf 90       	pop	r12
    257c:	08 95       	ret

0000257e <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    257e:	0f 93       	push	r16
    2580:	1f 93       	push	r17
    2582:	cf 93       	push	r28
    2584:	df 93       	push	r29
    2586:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    2588:	80 91 4a 41 	lds	r24, 0x414A	; 0x80414a <last_created_task_pointer>
    258c:	90 91 4b 41 	lds	r25, 0x414B	; 0x80414b <last_created_task_pointer+0x1>
    2590:	00 97       	sbiw	r24, 0x00	; 0
    2592:	19 f0       	breq	.+6      	; 0x259a <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    2594:	be 01       	movw	r22, r28
    2596:	0e 94 71 12 	call	0x24e2	; 0x24e2 <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    259a:	6a e0       	ldi	r22, 0x0A	; 10
    259c:	ce 01       	movw	r24, r28
    259e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    25a2:	8c 01       	movw	r16, r24
    25a4:	60 e5       	ldi	r22, 0x50	; 80
    25a6:	75 e0       	ldi	r23, 0x05	; 5
    25a8:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    25ac:	6a e0       	ldi	r22, 0x0A	; 10
    25ae:	c8 01       	movw	r24, r16
    25b0:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    25b4:	8c 01       	movw	r16, r24
    25b6:	65 e4       	ldi	r22, 0x45	; 69
    25b8:	75 e0       	ldi	r23, 0x05	; 5
    25ba:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    25be:	6a e0       	ldi	r22, 0x0A	; 10
    25c0:	c8 01       	movw	r24, r16
    25c2:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    25c6:	8c 01       	movw	r16, r24
    25c8:	6f e3       	ldi	r22, 0x3F	; 63
    25ca:	75 e0       	ldi	r23, 0x05	; 5
    25cc:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    25d0:	66 e0       	ldi	r22, 0x06	; 6
    25d2:	c8 01       	movw	r24, r16
    25d4:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    25d8:	80 91 6b 42 	lds	r24, 0x426B	; 0x80426b <portStackTopForTask>
    25dc:	90 91 6c 42 	lds	r25, 0x426C	; 0x80426c <portStackTopForTask+0x1>
    25e0:	bc 01       	movw	r22, r24
    25e2:	6f 5f       	subi	r22, 0xFF	; 255
    25e4:	7f 4f       	sbci	r23, 0xFF	; 255
    25e6:	01 e1       	ldi	r16, 0x11	; 17
    25e8:	21 e0       	ldi	r18, 0x01	; 1
    25ea:	ae 01       	movw	r20, r28
    25ec:	83 56       	subi	r24, 0x63	; 99
    25ee:	91 09       	sbc	r25, r1
    25f0:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    25f4:	df 91       	pop	r29
    25f6:	cf 91       	pop	r28
    25f8:	1f 91       	pop	r17
    25fa:	0f 91       	pop	r16
    25fc:	08 95       	ret

000025fe <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    25fe:	8f 92       	push	r8
    2600:	9f 92       	push	r9
    2602:	af 92       	push	r10
    2604:	bf 92       	push	r11
    2606:	cf 92       	push	r12
    2608:	df 92       	push	r13
    260a:	ef 92       	push	r14
    260c:	ff 92       	push	r15
    260e:	0f 93       	push	r16
    2610:	1f 93       	push	r17
    2612:	cf 93       	push	r28
    2614:	df 93       	push	r29
    2616:	ec 01       	movw	r28, r24
    2618:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    261a:	8a 81       	ldd	r24, Y+2	; 0x02
    261c:	9b 81       	ldd	r25, Y+3	; 0x03
    261e:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <pcTaskGetTaskName>
    2622:	bc 01       	movw	r22, r24
    2624:	c8 01       	movw	r24, r16
    2626:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    262a:	d8 01       	movw	r26, r16
    262c:	ed 91       	ld	r30, X+
    262e:	fc 91       	ld	r31, X
    2630:	02 80       	ldd	r0, Z+2	; 0x02
    2632:	f3 81       	ldd	r31, Z+3	; 0x03
    2634:	e0 2d       	mov	r30, r0
    2636:	69 e0       	ldi	r22, 0x09	; 9
    2638:	c8 01       	movw	r24, r16
    263a:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    263c:	8a 81       	ldd	r24, Y+2	; 0x02
    263e:	9b 81       	ldd	r25, Y+3	; 0x03
    2640:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <pcTaskGetTaskName>
    2644:	fc 01       	movw	r30, r24
    2646:	01 90       	ld	r0, Z+
    2648:	00 20       	and	r0, r0
    264a:	e9 f7       	brne	.-6      	; 0x2646 <_ZN8frt_task12print_statusER8emstream+0x48>
    264c:	31 97       	sbiw	r30, 0x01	; 1
    264e:	e8 1b       	sub	r30, r24
    2650:	f9 0b       	sbc	r31, r25
    2652:	38 97       	sbiw	r30, 0x08	; 8
    2654:	48 f4       	brcc	.+18     	; 0x2668 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2656:	d8 01       	movw	r26, r16
    2658:	ed 91       	ld	r30, X+
    265a:	fc 91       	ld	r31, X
    265c:	02 80       	ldd	r0, Z+2	; 0x02
    265e:	f3 81       	ldd	r31, Z+3	; 0x03
    2660:	e0 2d       	mov	r30, r0
    2662:	69 e0       	ldi	r22, 0x09	; 9
    2664:	c8 01       	movw	r24, r16
    2666:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2668:	ce 84       	ldd	r12, Y+14	; 0x0e
    266a:	df 84       	ldd	r13, Y+15	; 0x0f
    266c:	e8 88       	ldd	r14, Y+16	; 0x10
    266e:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    2670:	a8 84       	ldd	r10, Y+8	; 0x08
    2672:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    2674:	8a 81       	ldd	r24, Y+2	; 0x02
    2676:	9b 81       	ldd	r25, Y+3	; 0x03
    2678:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <uxTaskGetStackHighWaterMark>
    267c:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    267e:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    2680:	8a 81       	ldd	r24, Y+2	; 0x02
    2682:	9b 81       	ldd	r25, Y+3	; 0x03
    2684:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <uxTaskPriorityGet>
    2688:	68 2f       	mov	r22, r24
    268a:	c8 01       	movw	r24, r16
    268c:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2690:	6a e0       	ldi	r22, 0x0A	; 10
    2692:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2696:	ec 01       	movw	r28, r24
    2698:	65 ec       	ldi	r22, 0xC5	; 197
    269a:	75 e0       	ldi	r23, 0x05	; 5
    269c:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
			<< get_state ()
    26a0:	68 2d       	mov	r22, r8
    26a2:	ce 01       	movw	r24, r28
    26a4:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    26a8:	6a e0       	ldi	r22, 0x0A	; 10
    26aa:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    26ae:	ec 01       	movw	r28, r24
    26b0:	63 ec       	ldi	r22, 0xC3	; 195
    26b2:	75 e0       	ldi	r23, 0x05	; 5
    26b4:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    26b8:	69 2d       	mov	r22, r9
    26ba:	ce 01       	movw	r24, r28
    26bc:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    26c0:	6a e0       	ldi	r22, 0x0A	; 10
    26c2:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    26c6:	ec 01       	movw	r28, r24
    26c8:	61 ec       	ldi	r22, 0xC1	; 193
    26ca:	75 e0       	ldi	r23, 0x05	; 5
    26cc:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    26d0:	b5 01       	movw	r22, r10
    26d2:	ce 01       	movw	r24, r28
    26d4:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN8emstreamlsEj>
    26d8:	6a e0       	ldi	r22, 0x0A	; 10
    26da:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    26de:	ec 01       	movw	r28, r24
    26e0:	6f eb       	ldi	r22, 0xBF	; 191
    26e2:	75 e0       	ldi	r23, 0x05	; 5
    26e4:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    26e8:	6a e0       	ldi	r22, 0x0A	; 10
    26ea:	ce 01       	movw	r24, r28
    26ec:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    26f0:	ec 01       	movw	r28, r24
    26f2:	6d eb       	ldi	r22, 0xBD	; 189
    26f4:	75 e0       	ldi	r23, 0x05	; 5
    26f6:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    26fa:	b7 01       	movw	r22, r14
    26fc:	a6 01       	movw	r20, r12
    26fe:	ce 01       	movw	r24, r28
    2700:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <_ZN8emstreamlsEm>
}
    2704:	df 91       	pop	r29
    2706:	cf 91       	pop	r28
    2708:	1f 91       	pop	r17
    270a:	0f 91       	pop	r16
    270c:	ff 90       	pop	r15
    270e:	ef 90       	pop	r14
    2710:	df 90       	pop	r13
    2712:	cf 90       	pop	r12
    2714:	bf 90       	pop	r11
    2716:	af 90       	pop	r10
    2718:	9f 90       	pop	r9
    271a:	8f 90       	pop	r8
    271c:	08 95       	ret

0000271e <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    271e:	cf 93       	push	r28
    2720:	df 93       	push	r29
    2722:	ec 01       	movw	r28, r24
    2724:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2726:	db 01       	movw	r26, r22
    2728:	ed 91       	ld	r30, X+
    272a:	fc 91       	ld	r31, X
    272c:	02 80       	ldd	r0, Z+2	; 0x02
    272e:	f3 81       	ldd	r31, Z+3	; 0x03
    2730:	e0 2d       	mov	r30, r0
    2732:	be 01       	movw	r22, r28
    2734:	19 95       	eicall
	return (ser_dev);
}
    2736:	ce 01       	movw	r24, r28
    2738:	df 91       	pop	r29
    273a:	cf 91       	pop	r28
    273c:	08 95       	ret

0000273e <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    273e:	0f 93       	push	r16
    2740:	1f 93       	push	r17
    2742:	cf 93       	push	r28
    2744:	df 93       	push	r29
    2746:	ec 01       	movw	r28, r24
    2748:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    274a:	bc 01       	movw	r22, r24
    274c:	c8 01       	movw	r24, r16
    274e:	0e 94 8f 13 	call	0x271e	; 0x271e <_ZlsR8emstreamR8frt_task>
    2752:	66 e0       	ldi	r22, 0x06	; 6
    2754:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2758:	8c 81       	ldd	r24, Y+4	; 0x04
    275a:	9d 81       	ldd	r25, Y+5	; 0x05
    275c:	00 97       	sbiw	r24, 0x00	; 0
    275e:	19 f0       	breq	.+6      	; 0x2766 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    2760:	b8 01       	movw	r22, r16
    2762:	0e 94 9f 13 	call	0x273e	; 0x273e <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	08 95       	ret

00002770 <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    2770:	0f 93       	push	r16
    2772:	1f 93       	push	r17
    2774:	cf 93       	push	r28
    2776:	df 93       	push	r29
    2778:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    277a:	6a e0       	ldi	r22, 0x0A	; 10
    277c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2780:	8c 01       	movw	r16, r24
    2782:	62 eb       	ldi	r22, 0xB2	; 178
    2784:	75 e0       	ldi	r23, 0x05	; 5
    2786:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    278a:	6a e0       	ldi	r22, 0x0A	; 10
    278c:	c8 01       	movw	r24, r16
    278e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2792:	8c 01       	movw	r16, r24
    2794:	6b ea       	ldi	r22, 0xAB	; 171
    2796:	75 e0       	ldi	r23, 0x05	; 5
    2798:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    279c:	66 e0       	ldi	r22, 0x06	; 6
    279e:	c8 01       	movw	r24, r16
    27a0:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    27a4:	6a e0       	ldi	r22, 0x0A	; 10
    27a6:	ce 01       	movw	r24, r28
    27a8:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    27ac:	8c 01       	movw	r16, r24
    27ae:	6a e9       	ldi	r22, 0x9A	; 154
    27b0:	75 e0       	ldi	r23, 0x05	; 5
    27b2:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    27b6:	6a e0       	ldi	r22, 0x0A	; 10
    27b8:	c8 01       	movw	r24, r16
    27ba:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    27be:	8c 01       	movw	r16, r24
    27c0:	6e e8       	ldi	r22, 0x8E	; 142
    27c2:	75 e0       	ldi	r23, 0x05	; 5
    27c4:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    27c8:	6a e0       	ldi	r22, 0x0A	; 10
    27ca:	c8 01       	movw	r24, r16
    27cc:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    27d0:	8c 01       	movw	r16, r24
    27d2:	68 e8       	ldi	r22, 0x88	; 136
    27d4:	75 e0       	ldi	r23, 0x05	; 5
    27d6:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    27da:	66 e0       	ldi	r22, 0x06	; 6
    27dc:	c8 01       	movw	r24, r16
    27de:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    27e2:	6a e0       	ldi	r22, 0x0A	; 10
    27e4:	ce 01       	movw	r24, r28
    27e6:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    27ea:	8c 01       	movw	r16, r24
    27ec:	67 e7       	ldi	r22, 0x77	; 119
    27ee:	75 e0       	ldi	r23, 0x05	; 5
    27f0:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    27f4:	6a e0       	ldi	r22, 0x0A	; 10
    27f6:	c8 01       	movw	r24, r16
    27f8:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    27fc:	8c 01       	movw	r16, r24
    27fe:	6b e6       	ldi	r22, 0x6B	; 107
    2800:	75 e0       	ldi	r23, 0x05	; 5
    2802:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2806:	6a e0       	ldi	r22, 0x0A	; 10
    2808:	c8 01       	movw	r24, r16
    280a:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    280e:	8c 01       	movw	r16, r24
    2810:	65 e6       	ldi	r22, 0x65	; 101
    2812:	75 e0       	ldi	r23, 0x05	; 5
    2814:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2818:	66 e0       	ldi	r22, 0x06	; 6
    281a:	c8 01       	movw	r24, r16
    281c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    2820:	80 91 4a 41 	lds	r24, 0x414A	; 0x80414a <last_created_task_pointer>
    2824:	90 91 4b 41 	lds	r25, 0x414B	; 0x80414b <last_created_task_pointer+0x1>
    2828:	00 97       	sbiw	r24, 0x00	; 0
    282a:	19 f0       	breq	.+6      	; 0x2832 <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    282c:	be 01       	movw	r22, r28
    282e:	0e 94 9f 13 	call	0x273e	; 0x273e <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    2832:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <xTaskGetIdleTaskHandle>
    2836:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <uxTaskGetStackHighWaterMark>
    283a:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    283c:	6a e0       	ldi	r22, 0x0A	; 10
    283e:	ce 01       	movw	r24, r28
    2840:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2844:	ec 01       	movw	r28, r24
    2846:	6a e5       	ldi	r22, 0x5A	; 90
    2848:	75 e0       	ldi	r23, 0x05	; 5
    284a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    284e:	61 2f       	mov	r22, r17
    2850:	ce 01       	movw	r24, r28
    2852:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2856:	6a e0       	ldi	r22, 0x0A	; 10
    2858:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    285c:	ec 01       	movw	r28, r24
    285e:	68 e5       	ldi	r22, 0x58	; 88
    2860:	75 e0       	ldi	r23, 0x05	; 5
    2862:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2866:	64 e6       	ldi	r22, 0x64	; 100
    2868:	70 e0       	ldi	r23, 0x00	; 0
    286a:	ce 01       	movw	r24, r28
    286c:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN8emstreamlsEj>
    2870:	6a e0       	ldi	r22, 0x0A	; 10
    2872:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2876:	ec 01       	movw	r28, r24
    2878:	65 e5       	ldi	r22, 0x55	; 85
    287a:	75 e0       	ldi	r23, 0x05	; 5
    287c:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    2880:	66 e0       	ldi	r22, 0x06	; 6
    2882:	ce 01       	movw	r24, r28
    2884:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
}
    2888:	df 91       	pop	r29
    288a:	cf 91       	pop	r28
    288c:	1f 91       	pop	r17
    288e:	0f 91       	pop	r16
    2890:	08 95       	ret

00002892 <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    2892:	0f 93       	push	r16
    2894:	cf 93       	push	r28
    2896:	df 93       	push	r29
    2898:	1f 92       	push	r1
    289a:	cd b7       	in	r28, 0x3d	; 61
    289c:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    289e:	00 e0       	ldi	r16, 0x00	; 0
    28a0:	2f ef       	ldi	r18, 0xFF	; 255
    28a2:	3f ef       	ldi	r19, 0xFF	; 255
    28a4:	a9 01       	movw	r20, r18
    28a6:	be 01       	movw	r22, r28
    28a8:	6f 5f       	subi	r22, 0xFF	; 255
    28aa:	7f 4f       	sbci	r23, 0xFF	; 255
    28ac:	fc 01       	movw	r30, r24
    28ae:	80 85       	ldd	r24, Z+8	; 0x08
    28b0:	91 85       	ldd	r25, Z+9	; 0x09
    28b2:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
    28b6:	81 30       	cpi	r24, 0x01	; 1
    28b8:	19 f4       	brne	.+6      	; 0x28c0 <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    28ba:	89 81       	ldd	r24, Y+1	; 0x01
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	02 c0       	rjmp	.+4      	; 0x28c4 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    28c0:	8f ef       	ldi	r24, 0xFF	; 255
    28c2:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    28c4:	0f 90       	pop	r0
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	0f 91       	pop	r16
    28cc:	08 95       	ret

000028ce <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    28ce:	fc 01       	movw	r30, r24
    28d0:	80 85       	ldd	r24, Z+8	; 0x08
    28d2:	91 85       	ldd	r25, Z+9	; 0x09
    28d4:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
    28d8:	91 e0       	ldi	r25, 0x01	; 1
    28da:	81 11       	cpse	r24, r1
    28dc:	01 c0       	rjmp	.+2      	; 0x28e0 <_ZN14frt_text_queue14check_for_charEv+0x12>
    28de:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    28e0:	89 2f       	mov	r24, r25
    28e2:	08 95       	ret

000028e4 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    28e4:	0f 93       	push	r16
    28e6:	cf 93       	push	r28
    28e8:	df 93       	push	r29
    28ea:	1f 92       	push	r1
    28ec:	cd b7       	in	r28, 0x3d	; 61
    28ee:	de b7       	in	r29, 0x3e	; 62
    28f0:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    28f2:	fc 01       	movw	r30, r24
    28f4:	22 85       	ldd	r18, Z+10	; 0x0a
    28f6:	33 85       	ldd	r19, Z+11	; 0x0b
    28f8:	44 85       	ldd	r20, Z+12	; 0x0c
    28fa:	55 85       	ldd	r21, Z+13	; 0x0d
    28fc:	00 e0       	ldi	r16, 0x00	; 0
    28fe:	be 01       	movw	r22, r28
    2900:	6f 5f       	subi	r22, 0xFF	; 255
    2902:	7f 4f       	sbci	r23, 0xFF	; 255
    2904:	80 85       	ldd	r24, Z+8	; 0x08
    2906:	91 85       	ldd	r25, Z+9	; 0x09
    2908:	0e 94 0d 0a 	call	0x141a	; 0x141a <xQueueGenericSend>
    290c:	91 e0       	ldi	r25, 0x01	; 1
    290e:	81 11       	cpse	r24, r1
    2910:	01 c0       	rjmp	.+2      	; 0x2914 <_ZN14frt_text_queue7putcharEc+0x30>
    2912:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2914:	89 2f       	mov	r24, r25
    2916:	0f 90       	pop	r0
    2918:	df 91       	pop	r29
    291a:	cf 91       	pop	r28
    291c:	0f 91       	pop	r16
    291e:	08 95       	ret

00002920 <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2920:	8f 92       	push	r8
    2922:	9f 92       	push	r9
    2924:	bf 92       	push	r11
    2926:	cf 92       	push	r12
    2928:	df 92       	push	r13
    292a:	ef 92       	push	r14
    292c:	ff 92       	push	r15
    292e:	0f 93       	push	r16
    2930:	1f 93       	push	r17
    2932:	cf 93       	push	r28
    2934:	df 93       	push	r29
    2936:	ec 01       	movw	r28, r24
    2938:	b6 2e       	mov	r11, r22
    293a:	4a 01       	movw	r8, r20
    293c:	68 01       	movw	r12, r16
    293e:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2940:	0e 94 d7 16 	call	0x2dae	; 0x2dae <_ZN8emstreamC1Ev>
    2944:	88 e3       	ldi	r24, 0x38	; 56
    2946:	90 e2       	ldi	r25, 0x20	; 32
    2948:	88 83       	st	Y, r24
    294a:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    294c:	8e 86       	std	Y+14, r8	; 0x0e
    294e:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2950:	40 e0       	ldi	r20, 0x00	; 0
    2952:	61 e0       	ldi	r22, 0x01	; 1
    2954:	8b 2d       	mov	r24, r11
    2956:	0e 94 df 09 	call	0x13be	; 0x13be <xQueueGenericCreate>
    295a:	88 87       	std	Y+8, r24	; 0x08
    295c:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    295e:	ca 86       	std	Y+10, r12	; 0x0a
    2960:	db 86       	std	Y+11, r13	; 0x0b
    2962:	ec 86       	std	Y+12, r14	; 0x0c
    2964:	fd 86       	std	Y+13, r15	; 0x0d
}
    2966:	df 91       	pop	r29
    2968:	cf 91       	pop	r28
    296a:	1f 91       	pop	r17
    296c:	0f 91       	pop	r16
    296e:	ff 90       	pop	r15
    2970:	ef 90       	pop	r14
    2972:	df 90       	pop	r13
    2974:	cf 90       	pop	r12
    2976:	bf 90       	pop	r11
    2978:	9f 90       	pop	r9
    297a:	8f 90       	pop	r8
    297c:	08 95       	ret

0000297e <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    297e:	cf 92       	push	r12
    2980:	df 92       	push	r13
    2982:	ef 92       	push	r14
    2984:	ff 92       	push	r15
    2986:	cf 93       	push	r28
    2988:	df 93       	push	r29
    298a:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    298c:	68 81       	ld	r22, Y
    298e:	79 81       	ldd	r23, Y+1	; 0x01
    2990:	8a 81       	ldd	r24, Y+2	; 0x02
    2992:	9b 81       	ldd	r25, Y+3	; 0x03
    2994:	0f 2e       	mov	r0, r31
    2996:	f8 ee       	ldi	r31, 0xE8	; 232
    2998:	cf 2e       	mov	r12, r31
    299a:	f3 e0       	ldi	r31, 0x03	; 3
    299c:	df 2e       	mov	r13, r31
    299e:	e1 2c       	mov	r14, r1
    29a0:	f1 2c       	mov	r15, r1
    29a2:	f0 2d       	mov	r31, r0
    29a4:	a7 01       	movw	r20, r14
    29a6:	96 01       	movw	r18, r12
    29a8:	0e 94 96 24 	call	0x492c	; 0x492c <__udivmodsi4>
    29ac:	9b 01       	movw	r18, r22
    29ae:	ac 01       	movw	r20, r24
    29b0:	60 e4       	ldi	r22, 0x40	; 64
    29b2:	72 e4       	ldi	r23, 0x42	; 66
    29b4:	8f e0       	ldi	r24, 0x0F	; 15
    29b6:	90 e0       	ldi	r25, 0x00	; 0
    29b8:	0e 94 86 24 	call	0x490c	; 0x490c <__mulsi3>
    29bc:	a7 01       	movw	r20, r14
    29be:	96 01       	movw	r18, r12
    29c0:	0e 94 96 24 	call	0x492c	; 0x492c <__udivmodsi4>
    29c4:	69 01       	movw	r12, r18
    29c6:	7a 01       	movw	r14, r20
    29c8:	ac 81       	ldd	r26, Y+4	; 0x04
    29ca:	bd 81       	ldd	r27, Y+5	; 0x05
    29cc:	20 e4       	ldi	r18, 0x40	; 64
    29ce:	32 e4       	ldi	r19, 0x42	; 66
    29d0:	4f e0       	ldi	r20, 0x0F	; 15
    29d2:	50 e0       	ldi	r21, 0x00	; 0
    29d4:	0e 94 ee 24 	call	0x49dc	; 0x49dc <__muluhisi3>
    29d8:	20 e0       	ldi	r18, 0x00	; 0
    29da:	38 e4       	ldi	r19, 0x48	; 72
    29dc:	48 ee       	ldi	r20, 0xE8	; 232
    29de:	51 e0       	ldi	r21, 0x01	; 1
    29e0:	0e 94 96 24 	call	0x492c	; 0x492c <__udivmodsi4>
    29e4:	c7 01       	movw	r24, r14
    29e6:	b6 01       	movw	r22, r12
    29e8:	62 0f       	add	r22, r18
    29ea:	73 1f       	adc	r23, r19
    29ec:	84 1f       	adc	r24, r20
    29ee:	95 1f       	adc	r25, r21
}
    29f0:	df 91       	pop	r29
    29f2:	cf 91       	pop	r28
    29f4:	ff 90       	pop	r15
    29f6:	ef 90       	pop	r14
    29f8:	df 90       	pop	r13
    29fa:	cf 90       	pop	r12
    29fc:	08 95       	ret

000029fe <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    29fe:	cf 92       	push	r12
    2a00:	df 92       	push	r13
    2a02:	ef 92       	push	r14
    2a04:	ff 92       	push	r15
    2a06:	0f 93       	push	r16
    2a08:	1f 93       	push	r17
    2a0a:	cf 93       	push	r28
    2a0c:	df 93       	push	r29
    2a0e:	cd b7       	in	r28, 0x3d	; 61
    2a10:	de b7       	in	r29, 0x3e	; 62
    2a12:	2f 97       	sbiw	r28, 0x0f	; 15
    2a14:	cd bf       	out	0x3d, r28	; 61
    2a16:	de bf       	out	0x3e, r29	; 62
    2a18:	6c 01       	movw	r12, r24
    2a1a:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2a1c:	db 01       	movw	r26, r22
    2a1e:	6d 91       	ld	r22, X+
    2a20:	7d 91       	ld	r23, X+
    2a22:	8d 91       	ld	r24, X+
    2a24:	9c 91       	ld	r25, X
    2a26:	28 ee       	ldi	r18, 0xE8	; 232
    2a28:	33 e0       	ldi	r19, 0x03	; 3
    2a2a:	40 e0       	ldi	r20, 0x00	; 0
    2a2c:	50 e0       	ldi	r21, 0x00	; 0
    2a2e:	0e 94 96 24 	call	0x492c	; 0x492c <__udivmodsi4>
    2a32:	ba 01       	movw	r22, r20
    2a34:	a9 01       	movw	r20, r18
    2a36:	c6 01       	movw	r24, r12
    2a38:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2a3c:	d6 01       	movw	r26, r12
    2a3e:	ed 91       	ld	r30, X+
    2a40:	fc 91       	ld	r31, X
    2a42:	02 80       	ldd	r0, Z+2	; 0x02
    2a44:	f3 81       	ldd	r31, Z+3	; 0x03
    2a46:	e0 2d       	mov	r30, r0
    2a48:	6e e2       	ldi	r22, 0x2E	; 46
    2a4a:	c6 01       	movw	r24, r12
    2a4c:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2a4e:	c8 01       	movw	r24, r16
    2a50:	0e 94 bf 14 	call	0x297e	; 0x297e <_ZN10time_stamp12get_microsecEv>
    2a54:	8e 01       	movw	r16, r28
    2a56:	09 5f       	subi	r16, 0xF9	; 249
    2a58:	1f 4f       	sbci	r17, 0xFF	; 255
    2a5a:	fe 01       	movw	r30, r28
    2a5c:	31 96       	adiw	r30, 0x01	; 1
    2a5e:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2a60:	2a e0       	ldi	r18, 0x0A	; 10
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	40 e0       	ldi	r20, 0x00	; 0
    2a66:	50 e0       	ldi	r21, 0x00	; 0
    2a68:	0e 94 b8 24 	call	0x4970	; 0x4970 <__divmodsi4>
    2a6c:	e6 2f       	mov	r30, r22
    2a6e:	28 87       	std	Y+8, r18	; 0x08
    2a70:	39 87       	std	Y+9, r19	; 0x09
    2a72:	4a 87       	std	Y+10, r20	; 0x0a
    2a74:	5b 87       	std	Y+11, r21	; 0x0b
    2a76:	68 85       	ldd	r22, Y+8	; 0x08
    2a78:	79 85       	ldd	r23, Y+9	; 0x09
    2a7a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a7c:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2a7e:	20 e3       	ldi	r18, 0x30	; 48
    2a80:	2e 0f       	add	r18, r30
    2a82:	d8 01       	movw	r26, r16
    2a84:	2e 93       	st	-X, r18
    2a86:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2a88:	ae 15       	cp	r26, r14
    2a8a:	bf 05       	cpc	r27, r15
    2a8c:	49 f7       	brne	.-46     	; 0x2a60 <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2a8e:	1f 82       	std	Y+7, r1	; 0x07
    2a90:	be 01       	movw	r22, r28
    2a92:	6f 5f       	subi	r22, 0xFF	; 255
    2a94:	7f 4f       	sbci	r23, 0xFF	; 255
    2a96:	c6 01       	movw	r24, r12
    2a98:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2a9c:	c6 01       	movw	r24, r12
    2a9e:	2f 96       	adiw	r28, 0x0f	; 15
    2aa0:	cd bf       	out	0x3d, r28	; 61
    2aa2:	de bf       	out	0x3e, r29	; 62
    2aa4:	df 91       	pop	r29
    2aa6:	cf 91       	pop	r28
    2aa8:	1f 91       	pop	r17
    2aaa:	0f 91       	pop	r16
    2aac:	ff 90       	pop	r15
    2aae:	ef 90       	pop	r14
    2ab0:	df 90       	pop	r13
    2ab2:	cf 90       	pop	r12
    2ab4:	08 95       	ret

00002ab6 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2ab6:	cf 93       	push	r28
    2ab8:	df 93       	push	r29
    2aba:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2abc:	0f b6       	in	r0, 0x3f	; 63
    2abe:	f8 94       	cli
    2ac0:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2ac2:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2ac6:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2aca:	8c 83       	std	Y+4, r24	; 0x04
    2acc:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2ace:	0e 94 6f 0d 	call	0x1ade	; 0x1ade <xTaskGetTickCount>
    2ad2:	68 83       	st	Y, r22
    2ad4:	79 83       	std	Y+1, r23	; 0x01
    2ad6:	8a 83       	std	Y+2, r24	; 0x02
    2ad8:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2ada:	0f 90       	pop	r0
    2adc:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2ade:	ce 01       	movw	r24, r28
    2ae0:	df 91       	pop	r29
    2ae2:	cf 91       	pop	r28
    2ae4:	08 95       	ret

00002ae6 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2ae6:	5f 92       	push	r5
    2ae8:	6f 92       	push	r6
    2aea:	7f 92       	push	r7
    2aec:	8f 92       	push	r8
    2aee:	9f 92       	push	r9
    2af0:	af 92       	push	r10
    2af2:	bf 92       	push	r11
    2af4:	cf 92       	push	r12
    2af6:	df 92       	push	r13
    2af8:	ef 92       	push	r14
    2afa:	ff 92       	push	r15
    2afc:	0f 93       	push	r16
    2afe:	1f 93       	push	r17
    2b00:	cf 93       	push	r28
    2b02:	df 93       	push	r29
    2b04:	5c 01       	movw	r10, r24
    2b06:	4b 01       	movw	r8, r22
    2b08:	7a 01       	movw	r14, r20
    2b0a:	12 2f       	mov	r17, r18
    2b0c:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2b0e:	63 e0       	ldi	r22, 0x03	; 3
    2b10:	ca 01       	movw	r24, r20
    2b12:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2b16:	a8 14       	cp	r10, r8
    2b18:	b9 04       	cpc	r11, r9
    2b1a:	08 f0       	brcs	.+2      	; 0x2b1e <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2b1c:	7d c0       	rjmp	.+250    	; 0x2c18 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2b1e:	65 01       	movw	r12, r10
    2b20:	84 e1       	ldi	r24, 0x14	; 20
    2b22:	c8 0e       	add	r12, r24
    2b24:	d1 1c       	adc	r13, r1
    2b26:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2b28:	6a 2c       	mov	r6, r10
    2b2a:	5b 2c       	mov	r5, r11
    2b2c:	b5 01       	movw	r22, r10
    2b2e:	c7 01       	movw	r24, r14
    2b30:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <_ZN8emstreamlsEj>
    2b34:	6a e0       	ldi	r22, 0x0A	; 10
    2b36:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2b3a:	67 ed       	ldi	r22, 0xD7	; 215
    2b3c:	75 e0       	ldi	r23, 0x05	; 5
    2b3e:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2b42:	11 23       	and	r17, r17
    2b44:	09 f4       	brne	.+2      	; 0x2b48 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2b46:	6d c0       	rjmp	.+218    	; 0x2c22 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2b48:	00 23       	and	r16, r16
    2b4a:	09 f4       	brne	.+2      	; 0x2b4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2b4c:	6a c0       	rjmp	.+212    	; 0x2c22 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2b4e:	6a e0       	ldi	r22, 0x0A	; 10
    2b50:	c7 01       	movw	r24, r14
    2b52:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2b56:	62 ed       	ldi	r22, 0xD2	; 210
    2b58:	75 e0       	ldi	r23, 0x05	; 5
    2b5a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    2b5e:	61 c0       	rjmp	.+194    	; 0x2c22 <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2b60:	11 23       	and	r17, r17
    2b62:	71 f0       	breq	.+28     	; 0x2b80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2b64:	01 11       	cpse	r16, r1
    2b66:	0c c0       	rjmp	.+24     	; 0x2b80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2b68:	88 81       	ld	r24, Y
    2b6a:	87 15       	cp	r24, r7
    2b6c:	49 f0       	breq	.+18     	; 0x2b80 <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2b6e:	6a e0       	ldi	r22, 0x0A	; 10
    2b70:	c7 01       	movw	r24, r14
    2b72:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2b76:	6d ec       	ldi	r22, 0xCD	; 205
    2b78:	75 e0       	ldi	r23, 0x05	; 5
    2b7a:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2b7e:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2b80:	69 91       	ld	r22, Y+
    2b82:	c7 01       	movw	r24, r14
    2b84:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2b88:	dc 01       	movw	r26, r24
    2b8a:	ed 91       	ld	r30, X+
    2b8c:	fc 91       	ld	r31, X
    2b8e:	02 80       	ldd	r0, Z+2	; 0x02
    2b90:	f3 81       	ldd	r31, Z+3	; 0x03
    2b92:	e0 2d       	mov	r30, r0
    2b94:	60 e2       	ldi	r22, 0x20	; 32
    2b96:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2b98:	cc 16       	cp	r12, r28
    2b9a:	dd 06       	cpc	r13, r29
    2b9c:	09 f7       	brne	.-62     	; 0x2b60 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2b9e:	11 23       	and	r17, r17
    2ba0:	89 f0       	breq	.+34     	; 0x2bc4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2ba2:	6a e0       	ldi	r22, 0x0A	; 10
    2ba4:	c7 01       	movw	r24, r14
    2ba6:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2baa:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2bac:	67 ec       	ldi	r22, 0xC7	; 199
    2bae:	75 e0       	ldi	r23, 0x05	; 5
    2bb0:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2bb4:	e8 81       	ld	r30, Y
    2bb6:	f9 81       	ldd	r31, Y+1	; 0x01
    2bb8:	02 80       	ldd	r0, Z+2	; 0x02
    2bba:	f3 81       	ldd	r31, Z+3	; 0x03
    2bbc:	e0 2d       	mov	r30, r0
    2bbe:	60 e2       	ldi	r22, 0x20	; 32
    2bc0:	ce 01       	movw	r24, r28
    2bc2:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2bc4:	c6 2d       	mov	r28, r6
    2bc6:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2bc8:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2bca:	80 ee       	ldi	r24, 0xE0	; 224
    2bcc:	86 0f       	add	r24, r22
    2bce:	8f 35       	cpi	r24, 0x5F	; 95
    2bd0:	48 f4       	brcc	.+18     	; 0x2be4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2bd2:	d7 01       	movw	r26, r14
    2bd4:	ed 91       	ld	r30, X+
    2bd6:	fc 91       	ld	r31, X
    2bd8:	02 80       	ldd	r0, Z+2	; 0x02
    2bda:	f3 81       	ldd	r31, Z+3	; 0x03
    2bdc:	e0 2d       	mov	r30, r0
    2bde:	c7 01       	movw	r24, r14
    2be0:	19 95       	eicall
    2be2:	09 c0       	rjmp	.+18     	; 0x2bf6 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2be4:	d7 01       	movw	r26, r14
    2be6:	ed 91       	ld	r30, X+
    2be8:	fc 91       	ld	r31, X
    2bea:	02 80       	ldd	r0, Z+2	; 0x02
    2bec:	f3 81       	ldd	r31, Z+3	; 0x03
    2bee:	e0 2d       	mov	r30, r0
    2bf0:	6e e2       	ldi	r22, 0x2E	; 46
    2bf2:	c7 01       	movw	r24, r14
    2bf4:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2bf6:	cc 16       	cp	r12, r28
    2bf8:	dd 06       	cpc	r13, r29
    2bfa:	31 f7       	brne	.-52     	; 0x2bc8 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2bfc:	b4 e1       	ldi	r27, 0x14	; 20
    2bfe:	ab 0e       	add	r10, r27
    2c00:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2c02:	66 e0       	ldi	r22, 0x06	; 6
    2c04:	c7 01       	movw	r24, r14
    2c06:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    2c0a:	84 e1       	ldi	r24, 0x14	; 20
    2c0c:	c8 0e       	add	r12, r24
    2c0e:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2c10:	a8 14       	cp	r10, r8
    2c12:	b9 04       	cpc	r11, r9
    2c14:	08 f4       	brcc	.+2      	; 0x2c18 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2c16:	88 cf       	rjmp	.-240    	; 0x2b28 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2c18:	62 e0       	ldi	r22, 0x02	; 2
    2c1a:	c7 01       	movw	r24, r14
    2c1c:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
}
    2c20:	03 c0       	rjmp	.+6      	; 0x2c28 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2c22:	c6 2d       	mov	r28, r6
    2c24:	d5 2d       	mov	r29, r5
    2c26:	9c cf       	rjmp	.-200    	; 0x2b60 <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2c28:	df 91       	pop	r29
    2c2a:	cf 91       	pop	r28
    2c2c:	1f 91       	pop	r17
    2c2e:	0f 91       	pop	r16
    2c30:	ff 90       	pop	r15
    2c32:	ef 90       	pop	r14
    2c34:	df 90       	pop	r13
    2c36:	cf 90       	pop	r12
    2c38:	bf 90       	pop	r11
    2c3a:	af 90       	pop	r10
    2c3c:	9f 90       	pop	r9
    2c3e:	8f 90       	pop	r8
    2c40:	7f 90       	pop	r7
    2c42:	6f 90       	pop	r6
    2c44:	5f 90       	pop	r5
    2c46:	08 95       	ret

00002c48 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2c48:	0e 94 f7 05 	call	0xbee	; 0xbee <pvPortMalloc>
    2c4c:	08 95       	ret

00002c4e <_Znaj>:
    2c4e:	0e 94 f7 05 	call	0xbee	; 0xbee <pvPortMalloc>
    2c52:	08 95       	ret

00002c54 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2c54:	08 95       	ret

00002c56 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2c56:	cf 93       	push	r28
    2c58:	df 93       	push	r29
    2c5a:	fc 01       	movw	r30, r24
    2c5c:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2c5e:	40 3a       	cpi	r20, 0xA0	; 160
    2c60:	68 e0       	ldi	r22, 0x08	; 8
    2c62:	56 07       	cpc	r21, r22
    2c64:	49 f4       	brne	.+18     	; 0x2c78 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2c66:	80 e4       	ldi	r24, 0x40	; 64
    2c68:	96 e0       	ldi	r25, 0x06	; 6
    2c6a:	82 83       	std	Z+2, r24	; 0x02
    2c6c:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2c6e:	82 e0       	ldi	r24, 0x02	; 2
    2c70:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2c72:	83 e0       	ldi	r24, 0x03	; 3
    2c74:	85 83       	std	Z+5, r24	; 0x05
    2c76:	3f c0       	rjmp	.+126    	; 0x2cf6 <_ZN7base232C1EjP12USART_struct+0xa0>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2c78:	40 3b       	cpi	r20, 0xB0	; 176
    2c7a:	78 e0       	ldi	r23, 0x08	; 8
    2c7c:	57 07       	cpc	r21, r23
    2c7e:	49 f4       	brne	.+18     	; 0x2c92 <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2c80:	80 e4       	ldi	r24, 0x40	; 64
    2c82:	96 e0       	ldi	r25, 0x06	; 6
    2c84:	82 83       	std	Z+2, r24	; 0x02
    2c86:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2c88:	86 e0       	ldi	r24, 0x06	; 6
    2c8a:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2c8c:	87 e0       	ldi	r24, 0x07	; 7
    2c8e:	85 83       	std	Z+5, r24	; 0x05
    2c90:	32 c0       	rjmp	.+100    	; 0x2cf6 <_ZN7base232C1EjP12USART_struct+0xa0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2c92:	40 3a       	cpi	r20, 0xA0	; 160
    2c94:	89 e0       	ldi	r24, 0x09	; 9
    2c96:	58 07       	cpc	r21, r24
    2c98:	49 f4       	brne	.+18     	; 0x2cac <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2c9a:	80 e6       	ldi	r24, 0x60	; 96
    2c9c:	96 e0       	ldi	r25, 0x06	; 6
    2c9e:	82 83       	std	Z+2, r24	; 0x02
    2ca0:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2ca2:	82 e0       	ldi	r24, 0x02	; 2
    2ca4:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2ca6:	83 e0       	ldi	r24, 0x03	; 3
    2ca8:	85 83       	std	Z+5, r24	; 0x05
    2caa:	25 c0       	rjmp	.+74     	; 0x2cf6 <_ZN7base232C1EjP12USART_struct+0xa0>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2cac:	40 3b       	cpi	r20, 0xB0	; 176
    2cae:	69 e0       	ldi	r22, 0x09	; 9
    2cb0:	56 07       	cpc	r21, r22
    2cb2:	49 f4       	brne	.+18     	; 0x2cc6 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2cb4:	80 e6       	ldi	r24, 0x60	; 96
    2cb6:	96 e0       	ldi	r25, 0x06	; 6
    2cb8:	82 83       	std	Z+2, r24	; 0x02
    2cba:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2cbc:	86 e0       	ldi	r24, 0x06	; 6
    2cbe:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2cc0:	87 e0       	ldi	r24, 0x07	; 7
    2cc2:	85 83       	std	Z+5, r24	; 0x05
    2cc4:	18 c0       	rjmp	.+48     	; 0x2cf6 <_ZN7base232C1EjP12USART_struct+0xa0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2cc6:	40 3a       	cpi	r20, 0xA0	; 160
    2cc8:	7a e0       	ldi	r23, 0x0A	; 10
    2cca:	57 07       	cpc	r21, r23
    2ccc:	49 f4       	brne	.+18     	; 0x2ce0 <_ZN7base232C1EjP12USART_struct+0x8a>
	{
		p_port = &PORTE;
    2cce:	80 e8       	ldi	r24, 0x80	; 128
    2cd0:	96 e0       	ldi	r25, 0x06	; 6
    2cd2:	82 83       	std	Z+2, r24	; 0x02
    2cd4:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2cd6:	82 e0       	ldi	r24, 0x02	; 2
    2cd8:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2cda:	83 e0       	ldi	r24, 0x03	; 3
    2cdc:	85 83       	std	Z+5, r24	; 0x05
    2cde:	0b c0       	rjmp	.+22     	; 0x2cf6 <_ZN7base232C1EjP12USART_struct+0xa0>
		rxd_pin = 6;
		txd_pin = 7;
	}
#endif
#ifdef USARTF0 
	else if(p_usart == &USARTF0)
    2ce0:	40 3a       	cpi	r20, 0xA0	; 160
    2ce2:	5b 40       	sbci	r21, 0x0B	; 11
    2ce4:	41 f4       	brne	.+16     	; 0x2cf6 <_ZN7base232C1EjP12USART_struct+0xa0>
	{
		p_port = &PORTF;
    2ce6:	80 ea       	ldi	r24, 0xA0	; 160
    2ce8:	96 e0       	ldi	r25, 0x06	; 6
    2cea:	82 83       	std	Z+2, r24	; 0x02
    2cec:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2cee:	82 e0       	ldi	r24, 0x02	; 2
    2cf0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2cf2:	83 e0       	ldi	r24, 0x03	; 3
    2cf4:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2cf6:	a6 83       	std	Z+6, r26	; 0x06
    2cf8:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2cfa:	cd 01       	movw	r24, r26
    2cfc:	01 96       	adiw	r24, 0x01	; 1
    2cfe:	80 87       	std	Z+8, r24	; 0x08
    2d00:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2d02:	03 96       	adiw	r24, 0x03	; 3
    2d04:	82 87       	std	Z+10, r24	; 0x0a
    2d06:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2d08:	25 81       	ldd	r18, Z+5	; 0x05
    2d0a:	c2 81       	ldd	r28, Z+2	; 0x02
    2d0c:	d3 81       	ldd	r29, Z+3	; 0x03
    2d0e:	4c 81       	ldd	r20, Y+4	; 0x04
    2d10:	81 e0       	ldi	r24, 0x01	; 1
    2d12:	90 e0       	ldi	r25, 0x00	; 0
    2d14:	bc 01       	movw	r22, r24
    2d16:	02 c0       	rjmp	.+4      	; 0x2d1c <_ZN7base232C1EjP12USART_struct+0xc6>
    2d18:	66 0f       	add	r22, r22
    2d1a:	77 1f       	adc	r23, r23
    2d1c:	2a 95       	dec	r18
    2d1e:	e2 f7       	brpl	.-8      	; 0x2d18 <_ZN7base232C1EjP12USART_struct+0xc2>
    2d20:	9b 01       	movw	r18, r22
    2d22:	24 2b       	or	r18, r20
    2d24:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2d26:	25 81       	ldd	r18, Z+5	; 0x05
    2d28:	c2 81       	ldd	r28, Z+2	; 0x02
    2d2a:	d3 81       	ldd	r29, Z+3	; 0x03
    2d2c:	48 81       	ld	r20, Y
    2d2e:	bc 01       	movw	r22, r24
    2d30:	02 c0       	rjmp	.+4      	; 0x2d36 <_ZN7base232C1EjP12USART_struct+0xe0>
    2d32:	66 0f       	add	r22, r22
    2d34:	77 1f       	adc	r23, r23
    2d36:	2a 95       	dec	r18
    2d38:	e2 f7       	brpl	.-8      	; 0x2d32 <_ZN7base232C1EjP12USART_struct+0xdc>
    2d3a:	9b 01       	movw	r18, r22
    2d3c:	24 2b       	or	r18, r20
    2d3e:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2d40:	34 81       	ldd	r19, Z+4	; 0x04
    2d42:	c2 81       	ldd	r28, Z+2	; 0x02
    2d44:	d3 81       	ldd	r29, Z+3	; 0x03
    2d46:	28 81       	ld	r18, Y
    2d48:	02 c0       	rjmp	.+4      	; 0x2d4e <_ZN7base232C1EjP12USART_struct+0xf8>
    2d4a:	88 0f       	add	r24, r24
    2d4c:	99 1f       	adc	r25, r25
    2d4e:	3a 95       	dec	r19
    2d50:	e2 f7       	brpl	.-8      	; 0x2d4a <_ZN7base232C1EjP12USART_struct+0xf4>
    2d52:	80 95       	com	r24
    2d54:	90 95       	com	r25
    2d56:	82 23       	and	r24, r18
    2d58:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2d5a:	80 e1       	ldi	r24, 0x10	; 16
    2d5c:	13 96       	adiw	r26, 0x03	; 3
    2d5e:	8c 93       	st	X, r24
    2d60:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2d62:	83 e0       	ldi	r24, 0x03	; 3
    2d64:	15 96       	adiw	r26, 0x05	; 5
    2d66:	8c 93       	st	X, r24
    2d68:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2d6a:	80 ef       	ldi	r24, 0xF0	; 240
    2d6c:	17 96       	adiw	r26, 0x07	; 7
    2d6e:	8c 93       	st	X, r24
    2d70:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2d72:	81 e2       	ldi	r24, 0x21	; 33
    2d74:	16 96       	adiw	r26, 0x06	; 6
    2d76:	8c 93       	st	X, r24
    2d78:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2d7a:	88 e1       	ldi	r24, 0x18	; 24
    2d7c:	14 96       	adiw	r26, 0x04	; 4
    2d7e:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2d80:	80 e8       	ldi	r24, 0x80	; 128
    2d82:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2d84:	80 e4       	ldi	r24, 0x40	; 64
    2d86:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2d88:	80 e2       	ldi	r24, 0x20	; 32
    2d8a:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2d8c:	06 80       	ldd	r0, Z+6	; 0x06
    2d8e:	f7 81       	ldd	r31, Z+7	; 0x07
    2d90:	e0 2d       	mov	r30, r0
    2d92:	80 81       	ld	r24, Z
    2d94:	80 81       	ld	r24, Z
}
    2d96:	df 91       	pop	r29
    2d98:	cf 91       	pop	r28
    2d9a:	08 95       	ret

00002d9c <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2d9c:	81 e0       	ldi	r24, 0x01	; 1
    2d9e:	08 95       	ret

00002da0 <_ZN8emstream7getcharEv>:
    2da0:	80 e0       	ldi	r24, 0x00	; 0
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	08 95       	ret

00002da6 <_ZN8emstream14check_for_charEv>:
    2da6:	80 e0       	ldi	r24, 0x00	; 0
    2da8:	08 95       	ret

00002daa <_ZN8emstream12transmit_nowEv>:
    2daa:	08 95       	ret

00002dac <_ZN8emstream12clear_screenEv>:
    2dac:	08 95       	ret

00002dae <_ZN8emstreamC1Ev>:
    2dae:	fc 01       	movw	r30, r24
    2db0:	88 e4       	ldi	r24, 0x48	; 72
    2db2:	90 e2       	ldi	r25, 0x20	; 32
    2db4:	80 83       	st	Z, r24
    2db6:	91 83       	std	Z+1, r25	; 0x01
    2db8:	8a e0       	ldi	r24, 0x0A	; 10
    2dba:	82 83       	std	Z+2, r24	; 0x02
    2dbc:	13 82       	std	Z+3, r1	; 0x03
    2dbe:	83 e0       	ldi	r24, 0x03	; 3
    2dc0:	85 83       	std	Z+5, r24	; 0x05
    2dc2:	14 82       	std	Z+4, r1	; 0x04
    2dc4:	16 82       	std	Z+6, r1	; 0x06
    2dc6:	17 82       	std	Z+7, r1	; 0x07
    2dc8:	08 95       	ret

00002dca <_ZN8emstream4putsEPKc>:
    2dca:	0f 93       	push	r16
    2dcc:	1f 93       	push	r17
    2dce:	cf 93       	push	r28
    2dd0:	df 93       	push	r29
    2dd2:	8c 01       	movw	r16, r24
    2dd4:	fb 01       	movw	r30, r22
    2dd6:	dc 01       	movw	r26, r24
    2dd8:	14 96       	adiw	r26, 0x04	; 4
    2dda:	8c 91       	ld	r24, X
    2ddc:	81 11       	cpse	r24, r1
    2dde:	04 c0       	rjmp	.+8      	; 0x2de8 <_ZN8emstream4putsEPKc+0x1e>
    2de0:	60 81       	ld	r22, Z
    2de2:	61 11       	cpse	r22, r1
    2de4:	17 c0       	rjmp	.+46     	; 0x2e14 <_ZN8emstream4putsEPKc+0x4a>
    2de6:	23 c0       	rjmp	.+70     	; 0x2e2e <_ZN8emstream4putsEPKc+0x64>
    2de8:	d8 01       	movw	r26, r16
    2dea:	14 96       	adiw	r26, 0x04	; 4
    2dec:	1c 92       	st	X, r1
    2dee:	eb 01       	movw	r28, r22
    2df0:	21 96       	adiw	r28, 0x01	; 1
    2df2:	64 91       	lpm	r22, Z
    2df4:	66 23       	and	r22, r22
    2df6:	d9 f0       	breq	.+54     	; 0x2e2e <_ZN8emstream4putsEPKc+0x64>
    2df8:	d8 01       	movw	r26, r16
    2dfa:	ed 91       	ld	r30, X+
    2dfc:	fc 91       	ld	r31, X
    2dfe:	02 80       	ldd	r0, Z+2	; 0x02
    2e00:	f3 81       	ldd	r31, Z+3	; 0x03
    2e02:	e0 2d       	mov	r30, r0
    2e04:	c8 01       	movw	r24, r16
    2e06:	19 95       	eicall
    2e08:	fe 01       	movw	r30, r28
    2e0a:	64 91       	lpm	r22, Z
    2e0c:	21 96       	adiw	r28, 0x01	; 1
    2e0e:	61 11       	cpse	r22, r1
    2e10:	f3 cf       	rjmp	.-26     	; 0x2df8 <_ZN8emstream4putsEPKc+0x2e>
    2e12:	0d c0       	rjmp	.+26     	; 0x2e2e <_ZN8emstream4putsEPKc+0x64>
    2e14:	ef 01       	movw	r28, r30
    2e16:	21 96       	adiw	r28, 0x01	; 1
    2e18:	d8 01       	movw	r26, r16
    2e1a:	ed 91       	ld	r30, X+
    2e1c:	fc 91       	ld	r31, X
    2e1e:	02 80       	ldd	r0, Z+2	; 0x02
    2e20:	f3 81       	ldd	r31, Z+3	; 0x03
    2e22:	e0 2d       	mov	r30, r0
    2e24:	c8 01       	movw	r24, r16
    2e26:	19 95       	eicall
    2e28:	69 91       	ld	r22, Y+
    2e2a:	61 11       	cpse	r22, r1
    2e2c:	f5 cf       	rjmp	.-22     	; 0x2e18 <_ZN8emstream4putsEPKc+0x4e>
    2e2e:	df 91       	pop	r29
    2e30:	cf 91       	pop	r28
    2e32:	1f 91       	pop	r17
    2e34:	0f 91       	pop	r16
    2e36:	08 95       	ret

00002e38 <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2e38:	cf 93       	push	r28
    2e3a:	df 93       	push	r29
    2e3c:	ec 01       	movw	r28, r24
	switch (new_manip)
    2e3e:	86 2f       	mov	r24, r22
    2e40:	90 e0       	ldi	r25, 0x00	; 0
    2e42:	8b 30       	cpi	r24, 0x0B	; 11
    2e44:	91 05       	cpc	r25, r1
    2e46:	d8 f5       	brcc	.+118    	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
    2e48:	fc 01       	movw	r30, r24
    2e4a:	88 27       	eor	r24, r24
    2e4c:	e2 50       	subi	r30, 0x02	; 2
    2e4e:	ff 4f       	sbci	r31, 0xFF	; 255
    2e50:	8f 4f       	sbci	r24, 0xFF	; 255
    2e52:	0c 94 d7 24 	jmp	0x49ae	; 0x49ae <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2e56:	82 e0       	ldi	r24, 0x02	; 2
    2e58:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2e5a:	31 c0       	rjmp	.+98     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2e5c:	88 e0       	ldi	r24, 0x08	; 8
    2e5e:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2e60:	2e c0       	rjmp	.+92     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2e62:	8a e0       	ldi	r24, 0x0A	; 10
    2e64:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2e66:	2b c0       	rjmp	.+86     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2e68:	80 e1       	ldi	r24, 0x10	; 16
    2e6a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2e6c:	28 c0       	rjmp	.+80     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2e6e:	81 e0       	ldi	r24, 0x01	; 1
    2e70:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2e72:	25 c0       	rjmp	.+74     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2e74:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2e76:	23 c0       	rjmp	.+70     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2e78:	e8 81       	ld	r30, Y
    2e7a:	f9 81       	ldd	r31, Y+1	; 0x01
    2e7c:	02 80       	ldd	r0, Z+2	; 0x02
    2e7e:	f3 81       	ldd	r31, Z+3	; 0x03
    2e80:	e0 2d       	mov	r30, r0
    2e82:	6d e0       	ldi	r22, 0x0D	; 13
    2e84:	ce 01       	movw	r24, r28
    2e86:	19 95       	eicall
    2e88:	e8 81       	ld	r30, Y
    2e8a:	f9 81       	ldd	r31, Y+1	; 0x01
    2e8c:	02 80       	ldd	r0, Z+2	; 0x02
    2e8e:	f3 81       	ldd	r31, Z+3	; 0x03
    2e90:	e0 2d       	mov	r30, r0
    2e92:	6a e0       	ldi	r22, 0x0A	; 10
    2e94:	ce 01       	movw	r24, r28
    2e96:	19 95       	eicall
			break;
    2e98:	12 c0       	rjmp	.+36     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2e9a:	e8 81       	ld	r30, Y
    2e9c:	f9 81       	ldd	r31, Y+1	; 0x01
    2e9e:	02 84       	ldd	r0, Z+10	; 0x0a
    2ea0:	f3 85       	ldd	r31, Z+11	; 0x0b
    2ea2:	e0 2d       	mov	r30, r0
    2ea4:	ce 01       	movw	r24, r28
    2ea6:	19 95       	eicall
			break;
    2ea8:	0a c0       	rjmp	.+20     	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2eaa:	e8 81       	ld	r30, Y
    2eac:	f9 81       	ldd	r31, Y+1	; 0x01
    2eae:	00 84       	ldd	r0, Z+8	; 0x08
    2eb0:	f1 85       	ldd	r31, Z+9	; 0x09
    2eb2:	e0 2d       	mov	r30, r0
    2eb4:	ce 01       	movw	r24, r28
    2eb6:	19 95       	eicall
			break;
    2eb8:	02 c0       	rjmp	.+4      	; 0x2ebe <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    2eba:	81 e0       	ldi	r24, 0x01	; 1
    2ebc:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    2ebe:	ce 01       	movw	r24, r28
    2ec0:	df 91       	pop	r29
    2ec2:	cf 91       	pop	r28
    2ec4:	08 95       	ret

00002ec6 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    2ec6:	ff 92       	push	r15
    2ec8:	0f 93       	push	r16
    2eca:	1f 93       	push	r17
    2ecc:	cf 93       	push	r28
    2ece:	df 93       	push	r29
    2ed0:	cd b7       	in	r28, 0x3d	; 61
    2ed2:	de b7       	in	r29, 0x3e	; 62
    2ed4:	61 97       	sbiw	r28, 0x11	; 17
    2ed6:	cd bf       	out	0x3d, r28	; 61
    2ed8:	de bf       	out	0x3e, r29	; 62
    2eda:	8c 01       	movw	r16, r24
    2edc:	f6 2e       	mov	r15, r22
    2ede:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2ee0:	f8 01       	movw	r30, r16
    2ee2:	42 81       	ldd	r20, Z+2	; 0x02
    2ee4:	40 31       	cpi	r20, 0x10	; 16
    2ee6:	21 f0       	breq	.+8      	; 0x2ef0 <_ZN8emstreamlsEj+0x2a>
    2ee8:	48 30       	cpi	r20, 0x08	; 8
    2eea:	11 f0       	breq	.+4      	; 0x2ef0 <_ZN8emstreamlsEj+0x2a>
    2eec:	42 30       	cpi	r20, 0x02	; 2
    2eee:	41 f4       	brne	.+16     	; 0x2f00 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    2ef0:	69 2f       	mov	r22, r25
    2ef2:	c8 01       	movw	r24, r16
    2ef4:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2ef8:	6f 2d       	mov	r22, r15
    2efa:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2efe:	0d c0       	rjmp	.+26     	; 0x2f1a <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    2f00:	50 e0       	ldi	r21, 0x00	; 0
    2f02:	be 01       	movw	r22, r28
    2f04:	6f 5f       	subi	r22, 0xFF	; 255
    2f06:	7f 4f       	sbci	r23, 0xFF	; 255
    2f08:	8f 2d       	mov	r24, r15
    2f0a:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    2f0e:	be 01       	movw	r22, r28
    2f10:	6f 5f       	subi	r22, 0xFF	; 255
    2f12:	7f 4f       	sbci	r23, 0xFF	; 255
    2f14:	c8 01       	movw	r24, r16
    2f16:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2f1a:	c8 01       	movw	r24, r16
    2f1c:	61 96       	adiw	r28, 0x11	; 17
    2f1e:	cd bf       	out	0x3d, r28	; 61
    2f20:	de bf       	out	0x3e, r29	; 62
    2f22:	df 91       	pop	r29
    2f24:	cf 91       	pop	r28
    2f26:	1f 91       	pop	r17
    2f28:	0f 91       	pop	r16
    2f2a:	ff 90       	pop	r15
    2f2c:	08 95       	ret

00002f2e <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    2f2e:	df 92       	push	r13
    2f30:	ef 92       	push	r14
    2f32:	ff 92       	push	r15
    2f34:	0f 93       	push	r16
    2f36:	1f 93       	push	r17
    2f38:	cf 93       	push	r28
    2f3a:	df 93       	push	r29
    2f3c:	cd b7       	in	r28, 0x3d	; 61
    2f3e:	de b7       	in	r29, 0x3e	; 62
    2f40:	a1 97       	sbiw	r28, 0x21	; 33
    2f42:	cd bf       	out	0x3d, r28	; 61
    2f44:	de bf       	out	0x3e, r29	; 62
    2f46:	8c 01       	movw	r16, r24
    2f48:	d4 2e       	mov	r13, r20
    2f4a:	e5 2e       	mov	r14, r21
    2f4c:	f6 2e       	mov	r15, r22
    2f4e:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2f50:	f8 01       	movw	r30, r16
    2f52:	22 81       	ldd	r18, Z+2	; 0x02
    2f54:	20 31       	cpi	r18, 0x10	; 16
    2f56:	21 f0       	breq	.+8      	; 0x2f60 <_ZN8emstreamlsEm+0x32>
    2f58:	28 30       	cpi	r18, 0x08	; 8
    2f5a:	11 f0       	breq	.+4      	; 0x2f60 <_ZN8emstreamlsEm+0x32>
    2f5c:	22 30       	cpi	r18, 0x02	; 2
    2f5e:	71 f4       	brne	.+28     	; 0x2f7c <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    2f60:	69 2f       	mov	r22, r25
    2f62:	c8 01       	movw	r24, r16
    2f64:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2f68:	6f 2d       	mov	r22, r15
    2f6a:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2f6e:	6e 2d       	mov	r22, r14
    2f70:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2f74:	6d 2d       	mov	r22, r13
    2f76:	0e 94 d9 17 	call	0x2fb2	; 0x2fb2 <_ZN8emstreamlsEh>
    2f7a:	0f c0       	rjmp	.+30     	; 0x2f9a <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    2f7c:	30 e0       	ldi	r19, 0x00	; 0
    2f7e:	ae 01       	movw	r20, r28
    2f80:	4f 5f       	subi	r20, 0xFF	; 255
    2f82:	5f 4f       	sbci	r21, 0xFF	; 255
    2f84:	6d 2d       	mov	r22, r13
    2f86:	7e 2d       	mov	r23, r14
    2f88:	8f 2d       	mov	r24, r15
    2f8a:	0e 94 18 25 	call	0x4a30	; 0x4a30 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    2f8e:	be 01       	movw	r22, r28
    2f90:	6f 5f       	subi	r22, 0xFF	; 255
    2f92:	7f 4f       	sbci	r23, 0xFF	; 255
    2f94:	c8 01       	movw	r24, r16
    2f96:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    2f9a:	c8 01       	movw	r24, r16
    2f9c:	a1 96       	adiw	r28, 0x21	; 33
    2f9e:	cd bf       	out	0x3d, r28	; 61
    2fa0:	de bf       	out	0x3e, r29	; 62
    2fa2:	df 91       	pop	r29
    2fa4:	cf 91       	pop	r28
    2fa6:	1f 91       	pop	r17
    2fa8:	0f 91       	pop	r16
    2faa:	ff 90       	pop	r15
    2fac:	ef 90       	pop	r14
    2fae:	df 90       	pop	r13
    2fb0:	08 95       	ret

00002fb2 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    2fb2:	cf 92       	push	r12
    2fb4:	df 92       	push	r13
    2fb6:	ef 92       	push	r14
    2fb8:	ff 92       	push	r15
    2fba:	0f 93       	push	r16
    2fbc:	1f 93       	push	r17
    2fbe:	cf 93       	push	r28
    2fc0:	df 93       	push	r29
    2fc2:	cd b7       	in	r28, 0x3d	; 61
    2fc4:	de b7       	in	r29, 0x3e	; 62
    2fc6:	29 97       	sbiw	r28, 0x09	; 9
    2fc8:	cd bf       	out	0x3d, r28	; 61
    2fca:	de bf       	out	0x3e, r29	; 62
    2fcc:	8c 01       	movw	r16, r24
    2fce:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    2fd0:	dc 01       	movw	r26, r24
    2fd2:	13 96       	adiw	r26, 0x03	; 3
    2fd4:	8c 91       	ld	r24, X
    2fd6:	13 97       	sbiw	r26, 0x03	; 3
    2fd8:	88 23       	and	r24, r24
    2fda:	41 f0       	breq	.+16     	; 0x2fec <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    2fdc:	ed 91       	ld	r30, X+
    2fde:	fc 91       	ld	r31, X
    2fe0:	02 80       	ldd	r0, Z+2	; 0x02
    2fe2:	f3 81       	ldd	r31, Z+3	; 0x03
    2fe4:	e0 2d       	mov	r30, r0
    2fe6:	c8 01       	movw	r24, r16
    2fe8:	19 95       	eicall
    2fea:	56 c0       	rjmp	.+172    	; 0x3098 <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    2fec:	f8 01       	movw	r30, r16
    2fee:	42 81       	ldd	r20, Z+2	; 0x02
    2ff0:	42 30       	cpi	r20, 0x02	; 2
    2ff2:	19 f5       	brne	.+70     	; 0x303a <_ZN8emstreamlsEh+0x88>
    2ff4:	68 94       	set
    2ff6:	cc 24       	eor	r12, r12
    2ff8:	c3 f8       	bld	r12, 3
    2ffa:	d1 2c       	mov	r13, r1
    2ffc:	68 94       	set
    2ffe:	ff 24       	eor	r15, r15
    3000:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3002:	8e 2d       	mov	r24, r14
    3004:	8f 21       	and	r24, r15
    3006:	51 f0       	breq	.+20     	; 0x301c <_ZN8emstreamlsEh+0x6a>
    3008:	d8 01       	movw	r26, r16
    300a:	ed 91       	ld	r30, X+
    300c:	fc 91       	ld	r31, X
    300e:	02 80       	ldd	r0, Z+2	; 0x02
    3010:	f3 81       	ldd	r31, Z+3	; 0x03
    3012:	e0 2d       	mov	r30, r0
    3014:	61 e3       	ldi	r22, 0x31	; 49
    3016:	c8 01       	movw	r24, r16
    3018:	19 95       	eicall
    301a:	09 c0       	rjmp	.+18     	; 0x302e <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    301c:	d8 01       	movw	r26, r16
    301e:	ed 91       	ld	r30, X+
    3020:	fc 91       	ld	r31, X
    3022:	02 80       	ldd	r0, Z+2	; 0x02
    3024:	f3 81       	ldd	r31, Z+3	; 0x03
    3026:	e0 2d       	mov	r30, r0
    3028:	60 e3       	ldi	r22, 0x30	; 48
    302a:	c8 01       	movw	r24, r16
    302c:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    302e:	f6 94       	lsr	r15
    3030:	b1 e0       	ldi	r27, 0x01	; 1
    3032:	cb 1a       	sub	r12, r27
    3034:	d1 08       	sbc	r13, r1
    3036:	29 f7       	brne	.-54     	; 0x3002 <_ZN8emstreamlsEh+0x50>
    3038:	2f c0       	rjmp	.+94     	; 0x3098 <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    303a:	40 31       	cpi	r20, 0x10	; 16
    303c:	f9 f4       	brne	.+62     	; 0x307c <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    303e:	62 95       	swap	r22
    3040:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3042:	01 90       	ld	r0, Z+
    3044:	f0 81       	ld	r31, Z
    3046:	e0 2d       	mov	r30, r0
    3048:	02 80       	ldd	r0, Z+2	; 0x02
    304a:	f3 81       	ldd	r31, Z+3	; 0x03
    304c:	e0 2d       	mov	r30, r0
    304e:	6a 30       	cpi	r22, 0x0A	; 10
    3050:	10 f0       	brcs	.+4      	; 0x3056 <_ZN8emstreamlsEh+0xa4>
    3052:	69 5c       	subi	r22, 0xC9	; 201
    3054:	01 c0       	rjmp	.+2      	; 0x3058 <_ZN8emstreamlsEh+0xa6>
    3056:	60 5d       	subi	r22, 0xD0	; 208
    3058:	c8 01       	movw	r24, r16
    305a:	19 95       	eicall
		temp_char = num & 0x0F;
    305c:	6e 2d       	mov	r22, r14
    305e:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3060:	d8 01       	movw	r26, r16
    3062:	ed 91       	ld	r30, X+
    3064:	fc 91       	ld	r31, X
    3066:	02 80       	ldd	r0, Z+2	; 0x02
    3068:	f3 81       	ldd	r31, Z+3	; 0x03
    306a:	e0 2d       	mov	r30, r0
    306c:	6a 30       	cpi	r22, 0x0A	; 10
    306e:	10 f0       	brcs	.+4      	; 0x3074 <_ZN8emstreamlsEh+0xc2>
    3070:	69 5c       	subi	r22, 0xC9	; 201
    3072:	01 c0       	rjmp	.+2      	; 0x3076 <_ZN8emstreamlsEh+0xc4>
    3074:	60 5d       	subi	r22, 0xD0	; 208
    3076:	c8 01       	movw	r24, r16
    3078:	19 95       	eicall
    307a:	0e c0       	rjmp	.+28     	; 0x3098 <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    307c:	50 e0       	ldi	r21, 0x00	; 0
    307e:	be 01       	movw	r22, r28
    3080:	6f 5f       	subi	r22, 0xFF	; 255
    3082:	7f 4f       	sbci	r23, 0xFF	; 255
    3084:	8e 2d       	mov	r24, r14
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    308c:	be 01       	movw	r22, r28
    308e:	6f 5f       	subi	r22, 0xFF	; 255
    3090:	7f 4f       	sbci	r23, 0xFF	; 255
    3092:	c8 01       	movw	r24, r16
    3094:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    3098:	c8 01       	movw	r24, r16
    309a:	29 96       	adiw	r28, 0x09	; 9
    309c:	cd bf       	out	0x3d, r28	; 61
    309e:	de bf       	out	0x3e, r29	; 62
    30a0:	df 91       	pop	r29
    30a2:	cf 91       	pop	r28
    30a4:	1f 91       	pop	r17
    30a6:	0f 91       	pop	r16
    30a8:	ff 90       	pop	r15
    30aa:	ef 90       	pop	r14
    30ac:	df 90       	pop	r13
    30ae:	cf 90       	pop	r12
    30b0:	08 95       	ret

000030b2 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    30b2:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    30b4:	50 96       	adiw	r26, 0x10	; 16
    30b6:	ed 91       	ld	r30, X+
    30b8:	fc 91       	ld	r31, X
    30ba:	51 97       	sbiw	r26, 0x11	; 17
    30bc:	80 81       	ld	r24, Z
    30be:	54 96       	adiw	r26, 0x14	; 20
    30c0:	4c 91       	ld	r20, X
    30c2:	54 97       	sbiw	r26, 0x14	; 20
    30c4:	84 23       	and	r24, r20
    30c6:	29 f0       	breq	.+10     	; 0x30d2 <_ZN5rs2327putcharEc+0x20>
    30c8:	09 c0       	rjmp	.+18     	; 0x30dc <_ZN5rs2327putcharEc+0x2a>
    30ca:	21 50       	subi	r18, 0x01	; 1
    30cc:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    30ce:	19 f4       	brne	.+6      	; 0x30d6 <_ZN5rs2327putcharEc+0x24>
    30d0:	12 c0       	rjmp	.+36     	; 0x30f6 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    30d2:	21 e2       	ldi	r18, 0x21	; 33
    30d4:	3e e4       	ldi	r19, 0x4E	; 78
    30d6:	90 81       	ld	r25, Z
    30d8:	94 23       	and	r25, r20
    30da:	b9 f3       	breq	.-18     	; 0x30ca <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    30dc:	90 81       	ld	r25, Z
    30de:	56 96       	adiw	r26, 0x16	; 22
    30e0:	8c 91       	ld	r24, X
    30e2:	56 97       	sbiw	r26, 0x16	; 22
    30e4:	89 2b       	or	r24, r25
    30e6:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    30e8:	1e 96       	adiw	r26, 0x0e	; 14
    30ea:	ed 91       	ld	r30, X+
    30ec:	fc 91       	ld	r31, X
    30ee:	1f 97       	sbiw	r26, 0x0f	; 15
    30f0:	60 83       	st	Z, r22
	return (true);
    30f2:	81 e0       	ldi	r24, 0x01	; 1
    30f4:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    30f6:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    30f8:	08 95       	ret

000030fa <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    30fa:	cf 93       	push	r28
    30fc:	df 93       	push	r29
    30fe:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3100:	c1 8d       	ldd	r28, Z+25	; 0x19
    3102:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3104:	28 81       	ld	r18, Y
    3106:	39 81       	ldd	r19, Y+1	; 0x01
    3108:	a3 8d       	ldd	r26, Z+27	; 0x1b
    310a:	b4 8d       	ldd	r27, Z+28	; 0x1c
    310c:	4d 91       	ld	r20, X+
    310e:	5c 91       	ld	r21, X
    3110:	24 17       	cp	r18, r20
    3112:	35 07       	cpc	r19, r21
    3114:	e9 f3       	breq	.-6      	; 0x3110 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3116:	a7 89       	ldd	r26, Z+23	; 0x17
    3118:	b0 8d       	ldd	r27, Z+24	; 0x18
    311a:	0d 90       	ld	r0, X+
    311c:	bc 91       	ld	r27, X
    311e:	a0 2d       	mov	r26, r0
    3120:	a2 0f       	add	r26, r18
    3122:	b3 1f       	adc	r27, r19
    3124:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3126:	2f 5f       	subi	r18, 0xFF	; 255
    3128:	3f 4f       	sbci	r19, 0xFF	; 255
    312a:	28 83       	st	Y, r18
    312c:	39 83       	std	Y+1, r19	; 0x01
    312e:	24 36       	cpi	r18, 0x64	; 100
    3130:	31 05       	cpc	r19, r1
    3132:	28 f0       	brcs	.+10     	; 0x313e <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3134:	01 8c       	ldd	r0, Z+25	; 0x19
    3136:	f2 8d       	ldd	r31, Z+26	; 0x1a
    3138:	e0 2d       	mov	r30, r0
    313a:	10 82       	st	Z, r1
    313c:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    313e:	90 e0       	ldi	r25, 0x00	; 0
    3140:	df 91       	pop	r29
    3142:	cf 91       	pop	r28
    3144:	08 95       	ret

00003146 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3146:	cf 93       	push	r28
    3148:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    314a:	ec 01       	movw	r28, r24
    314c:	a9 8d       	ldd	r26, Y+25	; 0x19
    314e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3150:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3152:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3154:	81 e0       	ldi	r24, 0x01	; 1
    3156:	4d 91       	ld	r20, X+
    3158:	5c 91       	ld	r21, X
    315a:	20 81       	ld	r18, Z
    315c:	31 81       	ldd	r19, Z+1	; 0x01
    315e:	42 17       	cp	r20, r18
    3160:	53 07       	cpc	r21, r19
    3162:	09 f4       	brne	.+2      	; 0x3166 <_ZN5rs23214check_for_charEv+0x20>
    3164:	80 e0       	ldi	r24, 0x00	; 0
}
    3166:	df 91       	pop	r29
    3168:	cf 91       	pop	r28
    316a:	08 95       	ret

0000316c <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    316c:	dc 01       	movw	r26, r24
    316e:	ed 91       	ld	r30, X+
    3170:	fc 91       	ld	r31, X
    3172:	02 80       	ldd	r0, Z+2	; 0x02
    3174:	f3 81       	ldd	r31, Z+3	; 0x03
    3176:	e0 2d       	mov	r30, r0
    3178:	6c e0       	ldi	r22, 0x0C	; 12
    317a:	19 95       	eicall
    317c:	08 95       	ret

0000317e <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    317e:	ef 92       	push	r14
    3180:	ff 92       	push	r15
    3182:	0f 93       	push	r16
    3184:	1f 93       	push	r17
    3186:	cf 93       	push	r28
    3188:	df 93       	push	r29
    318a:	ec 01       	movw	r28, r24
    318c:	7b 01       	movw	r14, r22
    318e:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    3190:	0e 94 d7 16 	call	0x2dae	; 0x2dae <_ZN8emstreamC1Ev>
    3194:	a8 01       	movw	r20, r16
    3196:	b7 01       	movw	r22, r14
    3198:	ce 01       	movw	r24, r28
    319a:	08 96       	adiw	r24, 0x08	; 8
    319c:	0e 94 2b 16 	call	0x2c56	; 0x2c56 <_ZN7base232C1EjP12USART_struct>
    31a0:	88 e5       	ldi	r24, 0x58	; 88
    31a2:	90 e2       	ldi	r25, 0x20	; 32
    31a4:	88 83       	st	Y, r24
    31a6:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    31a8:	00 3a       	cpi	r16, 0xA0	; 160
    31aa:	88 e0       	ldi	r24, 0x08	; 8
    31ac:	18 07       	cpc	r17, r24
    31ae:	69 f4       	brne	.+26     	; 0x31ca <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    31b0:	8e e6       	ldi	r24, 0x6E	; 110
    31b2:	91 e4       	ldi	r25, 0x41	; 65
    31b4:	8f 8b       	std	Y+23, r24	; 0x17
    31b6:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    31b8:	82 e6       	ldi	r24, 0x62	; 98
    31ba:	91 e4       	ldi	r25, 0x41	; 65
    31bc:	89 8f       	std	Y+25, r24	; 0x19
    31be:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    31c0:	86 e5       	ldi	r24, 0x56	; 86
    31c2:	91 e4       	ldi	r25, 0x41	; 65
    31c4:	8b 8f       	std	Y+27, r24	; 0x1b
    31c6:	9c 8f       	std	Y+28, r25	; 0x1c
    31c8:	53 c0       	rjmp	.+166    	; 0x3270 <_ZN5rs232C1EjP12USART_struct+0xf2>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    31ca:	00 3b       	cpi	r16, 0xB0	; 176
    31cc:	e8 e0       	ldi	r30, 0x08	; 8
    31ce:	1e 07       	cpc	r17, r30
    31d0:	69 f4       	brne	.+26     	; 0x31ec <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    31d2:	8c e6       	ldi	r24, 0x6C	; 108
    31d4:	91 e4       	ldi	r25, 0x41	; 65
    31d6:	8f 8b       	std	Y+23, r24	; 0x17
    31d8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    31da:	80 e6       	ldi	r24, 0x60	; 96
    31dc:	91 e4       	ldi	r25, 0x41	; 65
    31de:	89 8f       	std	Y+25, r24	; 0x19
    31e0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    31e2:	84 e5       	ldi	r24, 0x54	; 84
    31e4:	91 e4       	ldi	r25, 0x41	; 65
    31e6:	8b 8f       	std	Y+27, r24	; 0x1b
    31e8:	9c 8f       	std	Y+28, r25	; 0x1c
    31ea:	42 c0       	rjmp	.+132    	; 0x3270 <_ZN5rs232C1EjP12USART_struct+0xf2>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    31ec:	00 3a       	cpi	r16, 0xA0	; 160
    31ee:	f9 e0       	ldi	r31, 0x09	; 9
    31f0:	1f 07       	cpc	r17, r31
    31f2:	69 f4       	brne	.+26     	; 0x320e <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    31f4:	8a e6       	ldi	r24, 0x6A	; 106
    31f6:	91 e4       	ldi	r25, 0x41	; 65
    31f8:	8f 8b       	std	Y+23, r24	; 0x17
    31fa:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    31fc:	8e e5       	ldi	r24, 0x5E	; 94
    31fe:	91 e4       	ldi	r25, 0x41	; 65
    3200:	89 8f       	std	Y+25, r24	; 0x19
    3202:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3204:	82 e5       	ldi	r24, 0x52	; 82
    3206:	91 e4       	ldi	r25, 0x41	; 65
    3208:	8b 8f       	std	Y+27, r24	; 0x1b
    320a:	9c 8f       	std	Y+28, r25	; 0x1c
    320c:	31 c0       	rjmp	.+98     	; 0x3270 <_ZN5rs232C1EjP12USART_struct+0xf2>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    320e:	00 3b       	cpi	r16, 0xB0	; 176
    3210:	89 e0       	ldi	r24, 0x09	; 9
    3212:	18 07       	cpc	r17, r24
    3214:	69 f4       	brne	.+26     	; 0x3230 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3216:	88 e6       	ldi	r24, 0x68	; 104
    3218:	91 e4       	ldi	r25, 0x41	; 65
    321a:	8f 8b       	std	Y+23, r24	; 0x17
    321c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    321e:	8c e5       	ldi	r24, 0x5C	; 92
    3220:	91 e4       	ldi	r25, 0x41	; 65
    3222:	89 8f       	std	Y+25, r24	; 0x19
    3224:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3226:	80 e5       	ldi	r24, 0x50	; 80
    3228:	91 e4       	ldi	r25, 0x41	; 65
    322a:	8b 8f       	std	Y+27, r24	; 0x1b
    322c:	9c 8f       	std	Y+28, r25	; 0x1c
    322e:	20 c0       	rjmp	.+64     	; 0x3270 <_ZN5rs232C1EjP12USART_struct+0xf2>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3230:	00 3a       	cpi	r16, 0xA0	; 160
    3232:	ea e0       	ldi	r30, 0x0A	; 10
    3234:	1e 07       	cpc	r17, r30
    3236:	69 f4       	brne	.+26     	; 0x3252 <_ZN5rs232C1EjP12USART_struct+0xd4>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3238:	86 e6       	ldi	r24, 0x66	; 102
    323a:	91 e4       	ldi	r25, 0x41	; 65
    323c:	8f 8b       	std	Y+23, r24	; 0x17
    323e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3240:	8a e5       	ldi	r24, 0x5A	; 90
    3242:	91 e4       	ldi	r25, 0x41	; 65
    3244:	89 8f       	std	Y+25, r24	; 0x19
    3246:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3248:	8e e4       	ldi	r24, 0x4E	; 78
    324a:	91 e4       	ldi	r25, 0x41	; 65
    324c:	8b 8f       	std	Y+27, r24	; 0x1b
    324e:	9c 8f       	std	Y+28, r25	; 0x1c
    3250:	0f c0       	rjmp	.+30     	; 0x3270 <_ZN5rs232C1EjP12USART_struct+0xf2>
		p_rcv_read_index	= &rcvE1_read_index;
		p_rcv_write_index	= &rcvE1_write_index;
	}
#endif
#ifdef USARTF0
	else if(p_usart == &USARTF0)
    3252:	00 3a       	cpi	r16, 0xA0	; 160
    3254:	1b 40       	sbci	r17, 0x0B	; 11
    3256:	61 f4       	brne	.+24     	; 0x3270 <_ZN5rs232C1EjP12USART_struct+0xf2>
	{
		p_rcv_buffer		= &rcvF0_buffer;
    3258:	84 e6       	ldi	r24, 0x64	; 100
    325a:	91 e4       	ldi	r25, 0x41	; 65
    325c:	8f 8b       	std	Y+23, r24	; 0x17
    325e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvF0_read_index;
    3260:	88 e5       	ldi	r24, 0x58	; 88
    3262:	91 e4       	ldi	r25, 0x41	; 65
    3264:	89 8f       	std	Y+25, r24	; 0x19
    3266:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvF0_write_index;
    3268:	8c e4       	ldi	r24, 0x4C	; 76
    326a:	91 e4       	ldi	r25, 0x41	; 65
    326c:	8b 8f       	std	Y+27, r24	; 0x1b
    326e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3270:	0f 89       	ldd	r16, Y+23	; 0x17
    3272:	18 8d       	ldd	r17, Y+24	; 0x18
    3274:	84 e6       	ldi	r24, 0x64	; 100
    3276:	90 e0       	ldi	r25, 0x00	; 0
    3278:	0e 94 27 16 	call	0x2c4e	; 0x2c4e <_Znaj>
    327c:	f8 01       	movw	r30, r16
    327e:	80 83       	st	Z, r24
    3280:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3282:	e9 8d       	ldd	r30, Y+25	; 0x19
    3284:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3286:	10 82       	st	Z, r1
    3288:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    328a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    328c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    328e:	10 82       	st	Z, r1
    3290:	11 82       	std	Z+1, r1	; 0x01
}
    3292:	df 91       	pop	r29
    3294:	cf 91       	pop	r28
    3296:	1f 91       	pop	r17
    3298:	0f 91       	pop	r16
    329a:	ff 90       	pop	r15
    329c:	ef 90       	pop	r14
    329e:	08 95       	ret

000032a0 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    32a0:	1f 92       	push	r1
    32a2:	0f 92       	push	r0
    32a4:	0f b6       	in	r0, 0x3f	; 63
    32a6:	0f 92       	push	r0
    32a8:	11 24       	eor	r1, r1
    32aa:	0b b6       	in	r0, 0x3b	; 59
    32ac:	0f 92       	push	r0
    32ae:	2f 93       	push	r18
    32b0:	3f 93       	push	r19
    32b2:	8f 93       	push	r24
    32b4:	9f 93       	push	r25
    32b6:	ef 93       	push	r30
    32b8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    32ba:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    32be:	e0 91 6e 41 	lds	r30, 0x416E	; 0x80416e <rcvC0_buffer>
    32c2:	f0 91 6f 41 	lds	r31, 0x416F	; 0x80416f <rcvC0_buffer+0x1>
    32c6:	80 91 56 41 	lds	r24, 0x4156	; 0x804156 <rcvC0_write_index>
    32ca:	90 91 57 41 	lds	r25, 0x4157	; 0x804157 <rcvC0_write_index+0x1>
    32ce:	e8 0f       	add	r30, r24
    32d0:	f9 1f       	adc	r31, r25
    32d2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    32d4:	80 91 56 41 	lds	r24, 0x4156	; 0x804156 <rcvC0_write_index>
    32d8:	90 91 57 41 	lds	r25, 0x4157	; 0x804157 <rcvC0_write_index+0x1>
    32dc:	01 96       	adiw	r24, 0x01	; 1
    32de:	84 36       	cpi	r24, 0x64	; 100
    32e0:	91 05       	cpc	r25, r1
    32e2:	60 f4       	brcc	.+24     	; 0x32fc <__vector_25+0x5c>
    32e4:	80 93 56 41 	sts	0x4156, r24	; 0x804156 <rcvC0_write_index>
    32e8:	90 93 57 41 	sts	0x4157, r25	; 0x804157 <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    32ec:	20 91 62 41 	lds	r18, 0x4162	; 0x804162 <rcvC0_read_index>
    32f0:	30 91 63 41 	lds	r19, 0x4163	; 0x804163 <rcvC0_read_index+0x1>
    32f4:	82 17       	cp	r24, r18
    32f6:	93 07       	cpc	r25, r19
    32f8:	f1 f4       	brne	.+60     	; 0x3336 <__vector_25+0x96>
    32fa:	0c c0       	rjmp	.+24     	; 0x3314 <__vector_25+0x74>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    32fc:	10 92 56 41 	sts	0x4156, r1	; 0x804156 <rcvC0_write_index>
    3300:	10 92 57 41 	sts	0x4157, r1	; 0x804157 <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    3304:	80 91 62 41 	lds	r24, 0x4162	; 0x804162 <rcvC0_read_index>
    3308:	90 91 63 41 	lds	r25, 0x4163	; 0x804163 <rcvC0_read_index+0x1>
    330c:	18 16       	cp	r1, r24
    330e:	19 06       	cpc	r1, r25
    3310:	91 f4       	brne	.+36     	; 0x3336 <__vector_25+0x96>
    3312:	0e c0       	rjmp	.+28     	; 0x3330 <__vector_25+0x90>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3314:	01 96       	adiw	r24, 0x01	; 1
    3316:	84 36       	cpi	r24, 0x64	; 100
    3318:	91 05       	cpc	r25, r1
    331a:	28 f4       	brcc	.+10     	; 0x3326 <__vector_25+0x86>
    331c:	80 93 62 41 	sts	0x4162, r24	; 0x804162 <rcvC0_read_index>
    3320:	90 93 63 41 	sts	0x4163, r25	; 0x804163 <rcvC0_read_index+0x1>
    3324:	08 c0       	rjmp	.+16     	; 0x3336 <__vector_25+0x96>
			rcvC0_read_index = 0;
    3326:	10 92 62 41 	sts	0x4162, r1	; 0x804162 <rcvC0_read_index>
    332a:	10 92 63 41 	sts	0x4163, r1	; 0x804163 <rcvC0_read_index+0x1>
}
    332e:	03 c0       	rjmp	.+6      	; 0x3336 <__vector_25+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3330:	81 e0       	ldi	r24, 0x01	; 1
    3332:	90 e0       	ldi	r25, 0x00	; 0
    3334:	f3 cf       	rjmp	.-26     	; 0x331c <__vector_25+0x7c>
			rcvC0_read_index = 0;
}
    3336:	ff 91       	pop	r31
    3338:	ef 91       	pop	r30
    333a:	9f 91       	pop	r25
    333c:	8f 91       	pop	r24
    333e:	3f 91       	pop	r19
    3340:	2f 91       	pop	r18
    3342:	0f 90       	pop	r0
    3344:	0b be       	out	0x3b, r0	; 59
    3346:	0f 90       	pop	r0
    3348:	0f be       	out	0x3f, r0	; 63
    334a:	0f 90       	pop	r0
    334c:	1f 90       	pop	r1
    334e:	18 95       	reti

00003350 <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    3350:	1f 92       	push	r1
    3352:	0f 92       	push	r0
    3354:	0f b6       	in	r0, 0x3f	; 63
    3356:	0f 92       	push	r0
    3358:	11 24       	eor	r1, r1
    335a:	0b b6       	in	r0, 0x3b	; 59
    335c:	0f 92       	push	r0
    335e:	2f 93       	push	r18
    3360:	3f 93       	push	r19
    3362:	8f 93       	push	r24
    3364:	9f 93       	push	r25
    3366:	ef 93       	push	r30
    3368:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    336a:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    336e:	e0 91 6c 41 	lds	r30, 0x416C	; 0x80416c <rcvC1_buffer>
    3372:	f0 91 6d 41 	lds	r31, 0x416D	; 0x80416d <rcvC1_buffer+0x1>
    3376:	80 91 54 41 	lds	r24, 0x4154	; 0x804154 <rcvC1_write_index>
    337a:	90 91 55 41 	lds	r25, 0x4155	; 0x804155 <rcvC1_write_index+0x1>
    337e:	e8 0f       	add	r30, r24
    3380:	f9 1f       	adc	r31, r25
    3382:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3384:	80 91 54 41 	lds	r24, 0x4154	; 0x804154 <rcvC1_write_index>
    3388:	90 91 55 41 	lds	r25, 0x4155	; 0x804155 <rcvC1_write_index+0x1>
    338c:	01 96       	adiw	r24, 0x01	; 1
    338e:	84 36       	cpi	r24, 0x64	; 100
    3390:	91 05       	cpc	r25, r1
    3392:	60 f4       	brcc	.+24     	; 0x33ac <__vector_28+0x5c>
    3394:	80 93 54 41 	sts	0x4154, r24	; 0x804154 <rcvC1_write_index>
    3398:	90 93 55 41 	sts	0x4155, r25	; 0x804155 <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    339c:	20 91 60 41 	lds	r18, 0x4160	; 0x804160 <rcvC1_read_index>
    33a0:	30 91 61 41 	lds	r19, 0x4161	; 0x804161 <rcvC1_read_index+0x1>
    33a4:	82 17       	cp	r24, r18
    33a6:	93 07       	cpc	r25, r19
    33a8:	f1 f4       	brne	.+60     	; 0x33e6 <__vector_28+0x96>
    33aa:	0c c0       	rjmp	.+24     	; 0x33c4 <__vector_28+0x74>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    33ac:	10 92 54 41 	sts	0x4154, r1	; 0x804154 <rcvC1_write_index>
    33b0:	10 92 55 41 	sts	0x4155, r1	; 0x804155 <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    33b4:	80 91 60 41 	lds	r24, 0x4160	; 0x804160 <rcvC1_read_index>
    33b8:	90 91 61 41 	lds	r25, 0x4161	; 0x804161 <rcvC1_read_index+0x1>
    33bc:	18 16       	cp	r1, r24
    33be:	19 06       	cpc	r1, r25
    33c0:	91 f4       	brne	.+36     	; 0x33e6 <__vector_28+0x96>
    33c2:	0e c0       	rjmp	.+28     	; 0x33e0 <__vector_28+0x90>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    33c4:	01 96       	adiw	r24, 0x01	; 1
    33c6:	84 36       	cpi	r24, 0x64	; 100
    33c8:	91 05       	cpc	r25, r1
    33ca:	28 f4       	brcc	.+10     	; 0x33d6 <__vector_28+0x86>
    33cc:	80 93 60 41 	sts	0x4160, r24	; 0x804160 <rcvC1_read_index>
    33d0:	90 93 61 41 	sts	0x4161, r25	; 0x804161 <rcvC1_read_index+0x1>
    33d4:	08 c0       	rjmp	.+16     	; 0x33e6 <__vector_28+0x96>
	rcvC1_read_index = 0;
    33d6:	10 92 60 41 	sts	0x4160, r1	; 0x804160 <rcvC1_read_index>
    33da:	10 92 61 41 	sts	0x4161, r1	; 0x804161 <rcvC1_read_index+0x1>
}
    33de:	03 c0       	rjmp	.+6      	; 0x33e6 <__vector_28+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    33e0:	81 e0       	ldi	r24, 0x01	; 1
    33e2:	90 e0       	ldi	r25, 0x00	; 0
    33e4:	f3 cf       	rjmp	.-26     	; 0x33cc <__vector_28+0x7c>
	rcvC1_read_index = 0;
}
    33e6:	ff 91       	pop	r31
    33e8:	ef 91       	pop	r30
    33ea:	9f 91       	pop	r25
    33ec:	8f 91       	pop	r24
    33ee:	3f 91       	pop	r19
    33f0:	2f 91       	pop	r18
    33f2:	0f 90       	pop	r0
    33f4:	0b be       	out	0x3b, r0	; 59
    33f6:	0f 90       	pop	r0
    33f8:	0f be       	out	0x3f, r0	; 63
    33fa:	0f 90       	pop	r0
    33fc:	1f 90       	pop	r1
    33fe:	18 95       	reti

00003400 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3400:	1f 92       	push	r1
    3402:	0f 92       	push	r0
    3404:	0f b6       	in	r0, 0x3f	; 63
    3406:	0f 92       	push	r0
    3408:	11 24       	eor	r1, r1
    340a:	0b b6       	in	r0, 0x3b	; 59
    340c:	0f 92       	push	r0
    340e:	2f 93       	push	r18
    3410:	3f 93       	push	r19
    3412:	8f 93       	push	r24
    3414:	9f 93       	push	r25
    3416:	ef 93       	push	r30
    3418:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    341a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    341e:	e0 91 6a 41 	lds	r30, 0x416A	; 0x80416a <rcvD0_buffer>
    3422:	f0 91 6b 41 	lds	r31, 0x416B	; 0x80416b <rcvD0_buffer+0x1>
    3426:	80 91 56 41 	lds	r24, 0x4156	; 0x804156 <rcvC0_write_index>
    342a:	90 91 57 41 	lds	r25, 0x4157	; 0x804157 <rcvC0_write_index+0x1>
    342e:	e8 0f       	add	r30, r24
    3430:	f9 1f       	adc	r31, r25
    3432:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3434:	80 91 52 41 	lds	r24, 0x4152	; 0x804152 <rcvD0_write_index>
    3438:	90 91 53 41 	lds	r25, 0x4153	; 0x804153 <rcvD0_write_index+0x1>
    343c:	01 96       	adiw	r24, 0x01	; 1
    343e:	84 36       	cpi	r24, 0x64	; 100
    3440:	91 05       	cpc	r25, r1
    3442:	60 f4       	brcc	.+24     	; 0x345c <__vector_88+0x5c>
    3444:	80 93 52 41 	sts	0x4152, r24	; 0x804152 <rcvD0_write_index>
    3448:	90 93 53 41 	sts	0x4153, r25	; 0x804153 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    344c:	20 91 5e 41 	lds	r18, 0x415E	; 0x80415e <rcvD0_read_index>
    3450:	30 91 5f 41 	lds	r19, 0x415F	; 0x80415f <rcvD0_read_index+0x1>
    3454:	82 17       	cp	r24, r18
    3456:	93 07       	cpc	r25, r19
    3458:	f1 f4       	brne	.+60     	; 0x3496 <__vector_88+0x96>
    345a:	0c c0       	rjmp	.+24     	; 0x3474 <__vector_88+0x74>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    345c:	10 92 52 41 	sts	0x4152, r1	; 0x804152 <rcvD0_write_index>
    3460:	10 92 53 41 	sts	0x4153, r1	; 0x804153 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3464:	80 91 5e 41 	lds	r24, 0x415E	; 0x80415e <rcvD0_read_index>
    3468:	90 91 5f 41 	lds	r25, 0x415F	; 0x80415f <rcvD0_read_index+0x1>
    346c:	18 16       	cp	r1, r24
    346e:	19 06       	cpc	r1, r25
    3470:	91 f4       	brne	.+36     	; 0x3496 <__vector_88+0x96>
    3472:	0e c0       	rjmp	.+28     	; 0x3490 <__vector_88+0x90>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3474:	01 96       	adiw	r24, 0x01	; 1
    3476:	84 36       	cpi	r24, 0x64	; 100
    3478:	91 05       	cpc	r25, r1
    347a:	28 f4       	brcc	.+10     	; 0x3486 <__vector_88+0x86>
    347c:	80 93 5e 41 	sts	0x415E, r24	; 0x80415e <rcvD0_read_index>
    3480:	90 93 5f 41 	sts	0x415F, r25	; 0x80415f <rcvD0_read_index+0x1>
    3484:	08 c0       	rjmp	.+16     	; 0x3496 <__vector_88+0x96>
	rcvD0_read_index = 0;
    3486:	10 92 5e 41 	sts	0x415E, r1	; 0x80415e <rcvD0_read_index>
    348a:	10 92 5f 41 	sts	0x415F, r1	; 0x80415f <rcvD0_read_index+0x1>
}
    348e:	03 c0       	rjmp	.+6      	; 0x3496 <__vector_88+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3490:	81 e0       	ldi	r24, 0x01	; 1
    3492:	90 e0       	ldi	r25, 0x00	; 0
    3494:	f3 cf       	rjmp	.-26     	; 0x347c <__vector_88+0x7c>
	rcvD0_read_index = 0;
}
    3496:	ff 91       	pop	r31
    3498:	ef 91       	pop	r30
    349a:	9f 91       	pop	r25
    349c:	8f 91       	pop	r24
    349e:	3f 91       	pop	r19
    34a0:	2f 91       	pop	r18
    34a2:	0f 90       	pop	r0
    34a4:	0b be       	out	0x3b, r0	; 59
    34a6:	0f 90       	pop	r0
    34a8:	0f be       	out	0x3f, r0	; 63
    34aa:	0f 90       	pop	r0
    34ac:	1f 90       	pop	r1
    34ae:	18 95       	reti

000034b0 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    34b0:	1f 92       	push	r1
    34b2:	0f 92       	push	r0
    34b4:	0f b6       	in	r0, 0x3f	; 63
    34b6:	0f 92       	push	r0
    34b8:	11 24       	eor	r1, r1
    34ba:	0b b6       	in	r0, 0x3b	; 59
    34bc:	0f 92       	push	r0
    34be:	2f 93       	push	r18
    34c0:	3f 93       	push	r19
    34c2:	8f 93       	push	r24
    34c4:	9f 93       	push	r25
    34c6:	ef 93       	push	r30
    34c8:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    34ca:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    34ce:	e0 91 68 41 	lds	r30, 0x4168	; 0x804168 <rcvD1_buffer>
    34d2:	f0 91 69 41 	lds	r31, 0x4169	; 0x804169 <rcvD1_buffer+0x1>
    34d6:	80 91 50 41 	lds	r24, 0x4150	; 0x804150 <rcvD1_write_index>
    34da:	90 91 51 41 	lds	r25, 0x4151	; 0x804151 <rcvD1_write_index+0x1>
    34de:	e8 0f       	add	r30, r24
    34e0:	f9 1f       	adc	r31, r25
    34e2:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    34e4:	80 91 50 41 	lds	r24, 0x4150	; 0x804150 <rcvD1_write_index>
    34e8:	90 91 51 41 	lds	r25, 0x4151	; 0x804151 <rcvD1_write_index+0x1>
    34ec:	01 96       	adiw	r24, 0x01	; 1
    34ee:	84 36       	cpi	r24, 0x64	; 100
    34f0:	91 05       	cpc	r25, r1
    34f2:	60 f4       	brcc	.+24     	; 0x350c <__vector_91+0x5c>
    34f4:	80 93 50 41 	sts	0x4150, r24	; 0x804150 <rcvD1_write_index>
    34f8:	90 93 51 41 	sts	0x4151, r25	; 0x804151 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    34fc:	20 91 5c 41 	lds	r18, 0x415C	; 0x80415c <rcvD1_read_index>
    3500:	30 91 5d 41 	lds	r19, 0x415D	; 0x80415d <rcvD1_read_index+0x1>
    3504:	82 17       	cp	r24, r18
    3506:	93 07       	cpc	r25, r19
    3508:	f1 f4       	brne	.+60     	; 0x3546 <__vector_91+0x96>
    350a:	0c c0       	rjmp	.+24     	; 0x3524 <__vector_91+0x74>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    350c:	10 92 50 41 	sts	0x4150, r1	; 0x804150 <rcvD1_write_index>
    3510:	10 92 51 41 	sts	0x4151, r1	; 0x804151 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3514:	80 91 5c 41 	lds	r24, 0x415C	; 0x80415c <rcvD1_read_index>
    3518:	90 91 5d 41 	lds	r25, 0x415D	; 0x80415d <rcvD1_read_index+0x1>
    351c:	18 16       	cp	r1, r24
    351e:	19 06       	cpc	r1, r25
    3520:	91 f4       	brne	.+36     	; 0x3546 <__vector_91+0x96>
    3522:	0e c0       	rjmp	.+28     	; 0x3540 <__vector_91+0x90>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3524:	01 96       	adiw	r24, 0x01	; 1
    3526:	84 36       	cpi	r24, 0x64	; 100
    3528:	91 05       	cpc	r25, r1
    352a:	28 f4       	brcc	.+10     	; 0x3536 <__vector_91+0x86>
    352c:	80 93 5c 41 	sts	0x415C, r24	; 0x80415c <rcvD1_read_index>
    3530:	90 93 5d 41 	sts	0x415D, r25	; 0x80415d <rcvD1_read_index+0x1>
    3534:	08 c0       	rjmp	.+16     	; 0x3546 <__vector_91+0x96>
	rcvD1_read_index = 0;
    3536:	10 92 5c 41 	sts	0x415C, r1	; 0x80415c <rcvD1_read_index>
    353a:	10 92 5d 41 	sts	0x415D, r1	; 0x80415d <rcvD1_read_index+0x1>
}
    353e:	03 c0       	rjmp	.+6      	; 0x3546 <__vector_91+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3540:	81 e0       	ldi	r24, 0x01	; 1
    3542:	90 e0       	ldi	r25, 0x00	; 0
    3544:	f3 cf       	rjmp	.-26     	; 0x352c <__vector_91+0x7c>
	rcvD1_read_index = 0;
}
    3546:	ff 91       	pop	r31
    3548:	ef 91       	pop	r30
    354a:	9f 91       	pop	r25
    354c:	8f 91       	pop	r24
    354e:	3f 91       	pop	r19
    3550:	2f 91       	pop	r18
    3552:	0f 90       	pop	r0
    3554:	0b be       	out	0x3b, r0	; 59
    3556:	0f 90       	pop	r0
    3558:	0f be       	out	0x3f, r0	; 63
    355a:	0f 90       	pop	r0
    355c:	1f 90       	pop	r1
    355e:	18 95       	reti

00003560 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3560:	1f 92       	push	r1
    3562:	0f 92       	push	r0
    3564:	0f b6       	in	r0, 0x3f	; 63
    3566:	0f 92       	push	r0
    3568:	11 24       	eor	r1, r1
    356a:	0b b6       	in	r0, 0x3b	; 59
    356c:	0f 92       	push	r0
    356e:	2f 93       	push	r18
    3570:	3f 93       	push	r19
    3572:	8f 93       	push	r24
    3574:	9f 93       	push	r25
    3576:	ef 93       	push	r30
    3578:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    357a:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    357e:	e0 91 66 41 	lds	r30, 0x4166	; 0x804166 <rcvE0_buffer>
    3582:	f0 91 67 41 	lds	r31, 0x4167	; 0x804167 <rcvE0_buffer+0x1>
    3586:	80 91 4e 41 	lds	r24, 0x414E	; 0x80414e <rcvE0_write_index>
    358a:	90 91 4f 41 	lds	r25, 0x414F	; 0x80414f <rcvE0_write_index+0x1>
    358e:	e8 0f       	add	r30, r24
    3590:	f9 1f       	adc	r31, r25
    3592:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    3594:	80 91 4e 41 	lds	r24, 0x414E	; 0x80414e <rcvE0_write_index>
    3598:	90 91 4f 41 	lds	r25, 0x414F	; 0x80414f <rcvE0_write_index+0x1>
    359c:	01 96       	adiw	r24, 0x01	; 1
    359e:	84 36       	cpi	r24, 0x64	; 100
    35a0:	91 05       	cpc	r25, r1
    35a2:	60 f4       	brcc	.+24     	; 0x35bc <__vector_58+0x5c>
    35a4:	80 93 4e 41 	sts	0x414E, r24	; 0x80414e <rcvE0_write_index>
    35a8:	90 93 4f 41 	sts	0x414F, r25	; 0x80414f <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    35ac:	20 91 5a 41 	lds	r18, 0x415A	; 0x80415a <rcvE0_read_index>
    35b0:	30 91 5b 41 	lds	r19, 0x415B	; 0x80415b <rcvE0_read_index+0x1>
    35b4:	82 17       	cp	r24, r18
    35b6:	93 07       	cpc	r25, r19
    35b8:	f1 f4       	brne	.+60     	; 0x35f6 <__vector_58+0x96>
    35ba:	0c c0       	rjmp	.+24     	; 0x35d4 <__vector_58+0x74>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    35bc:	10 92 4e 41 	sts	0x414E, r1	; 0x80414e <rcvE0_write_index>
    35c0:	10 92 4f 41 	sts	0x414F, r1	; 0x80414f <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    35c4:	80 91 5a 41 	lds	r24, 0x415A	; 0x80415a <rcvE0_read_index>
    35c8:	90 91 5b 41 	lds	r25, 0x415B	; 0x80415b <rcvE0_read_index+0x1>
    35cc:	18 16       	cp	r1, r24
    35ce:	19 06       	cpc	r1, r25
    35d0:	91 f4       	brne	.+36     	; 0x35f6 <__vector_58+0x96>
    35d2:	0e c0       	rjmp	.+28     	; 0x35f0 <__vector_58+0x90>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    35d4:	01 96       	adiw	r24, 0x01	; 1
    35d6:	84 36       	cpi	r24, 0x64	; 100
    35d8:	91 05       	cpc	r25, r1
    35da:	28 f4       	brcc	.+10     	; 0x35e6 <__vector_58+0x86>
    35dc:	80 93 5a 41 	sts	0x415A, r24	; 0x80415a <rcvE0_read_index>
    35e0:	90 93 5b 41 	sts	0x415B, r25	; 0x80415b <rcvE0_read_index+0x1>
    35e4:	08 c0       	rjmp	.+16     	; 0x35f6 <__vector_58+0x96>
	rcvE0_read_index = 0;
    35e6:	10 92 5a 41 	sts	0x415A, r1	; 0x80415a <rcvE0_read_index>
    35ea:	10 92 5b 41 	sts	0x415B, r1	; 0x80415b <rcvE0_read_index+0x1>
}
    35ee:	03 c0       	rjmp	.+6      	; 0x35f6 <__vector_58+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    35f0:	81 e0       	ldi	r24, 0x01	; 1
    35f2:	90 e0       	ldi	r25, 0x00	; 0
    35f4:	f3 cf       	rjmp	.-26     	; 0x35dc <__vector_58+0x7c>
	rcvE0_read_index = 0;
}
    35f6:	ff 91       	pop	r31
    35f8:	ef 91       	pop	r30
    35fa:	9f 91       	pop	r25
    35fc:	8f 91       	pop	r24
    35fe:	3f 91       	pop	r19
    3600:	2f 91       	pop	r18
    3602:	0f 90       	pop	r0
    3604:	0b be       	out	0x3b, r0	; 59
    3606:	0f 90       	pop	r0
    3608:	0f be       	out	0x3f, r0	; 63
    360a:	0f 90       	pop	r0
    360c:	1f 90       	pop	r1
    360e:	18 95       	reti

00003610 <__vector_119>:
}
#endif

#ifdef USARTF0_RXC_vect
ISR (USARTF0_RXC_vect)
{
    3610:	1f 92       	push	r1
    3612:	0f 92       	push	r0
    3614:	0f b6       	in	r0, 0x3f	; 63
    3616:	0f 92       	push	r0
    3618:	11 24       	eor	r1, r1
    361a:	0b b6       	in	r0, 0x3b	; 59
    361c:	0f 92       	push	r0
    361e:	2f 93       	push	r18
    3620:	3f 93       	push	r19
    3622:	8f 93       	push	r24
    3624:	9f 93       	push	r25
    3626:	ef 93       	push	r30
    3628:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;
    362a:	20 91 a0 0b 	lds	r18, 0x0BA0	; 0x800ba0 <__TEXT_REGION_LENGTH__+0x700ba0>
    362e:	e0 91 64 41 	lds	r30, 0x4164	; 0x804164 <rcvF0_buffer>
    3632:	f0 91 65 41 	lds	r31, 0x4165	; 0x804165 <rcvF0_buffer+0x1>
    3636:	80 91 4c 41 	lds	r24, 0x414C	; 0x80414c <rcvF0_write_index>
    363a:	90 91 4d 41 	lds	r25, 0x414D	; 0x80414d <rcvF0_write_index+0x1>
    363e:	e8 0f       	add	r30, r24
    3640:	f9 1f       	adc	r31, r25
    3642:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
    3644:	80 91 4c 41 	lds	r24, 0x414C	; 0x80414c <rcvF0_write_index>
    3648:	90 91 4d 41 	lds	r25, 0x414D	; 0x80414d <rcvF0_write_index+0x1>
    364c:	01 96       	adiw	r24, 0x01	; 1
    364e:	84 36       	cpi	r24, 0x64	; 100
    3650:	91 05       	cpc	r25, r1
    3652:	60 f4       	brcc	.+24     	; 0x366c <__vector_119+0x5c>
    3654:	80 93 4c 41 	sts	0x414C, r24	; 0x80414c <rcvF0_write_index>
    3658:	90 93 4d 41 	sts	0x414D, r25	; 0x80414d <rcvF0_write_index+0x1>
	rcvF0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    365c:	20 91 58 41 	lds	r18, 0x4158	; 0x804158 <rcvF0_read_index>
    3660:	30 91 59 41 	lds	r19, 0x4159	; 0x804159 <rcvF0_read_index+0x1>
    3664:	82 17       	cp	r24, r18
    3666:	93 07       	cpc	r25, r19
    3668:	f1 f4       	brne	.+60     	; 0x36a6 <__vector_119+0x96>
    366a:	0c c0       	rjmp	.+24     	; 0x3684 <__vector_119+0x74>

	rcvF0_buffer[rcvF0_write_index] = USARTF0.DATA;

	// Increment the write pointer
	if (++rcvF0_write_index >= RSINT_BUF_SIZE)
	rcvF0_write_index = 0;
    366c:	10 92 4c 41 	sts	0x414C, r1	; 0x80414c <rcvF0_write_index>
    3670:	10 92 4d 41 	sts	0x414D, r1	; 0x80414d <rcvF0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
    3674:	80 91 58 41 	lds	r24, 0x4158	; 0x804158 <rcvF0_read_index>
    3678:	90 91 59 41 	lds	r25, 0x4159	; 0x804159 <rcvF0_read_index+0x1>
    367c:	18 16       	cp	r1, r24
    367e:	19 06       	cpc	r1, r25
    3680:	91 f4       	brne	.+36     	; 0x36a6 <__vector_119+0x96>
    3682:	0e c0       	rjmp	.+28     	; 0x36a0 <__vector_119+0x90>
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    3684:	01 96       	adiw	r24, 0x01	; 1
    3686:	84 36       	cpi	r24, 0x64	; 100
    3688:	91 05       	cpc	r25, r1
    368a:	28 f4       	brcc	.+10     	; 0x3696 <__vector_119+0x86>
    368c:	80 93 58 41 	sts	0x4158, r24	; 0x804158 <rcvF0_read_index>
    3690:	90 93 59 41 	sts	0x4159, r25	; 0x804159 <rcvF0_read_index+0x1>
    3694:	08 c0       	rjmp	.+16     	; 0x36a6 <__vector_119+0x96>
	rcvF0_read_index = 0;
    3696:	10 92 58 41 	sts	0x4158, r1	; 0x804158 <rcvF0_read_index>
    369a:	10 92 59 41 	sts	0x4159, r1	; 0x804159 <rcvF0_read_index+0x1>
}
    369e:	03 c0       	rjmp	.+6      	; 0x36a6 <__vector_119+0x96>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvF0_write_index == rcvF0_read_index)
	if (++rcvF0_read_index >= RSINT_BUF_SIZE)
    36a0:	81 e0       	ldi	r24, 0x01	; 1
    36a2:	90 e0       	ldi	r25, 0x00	; 0
    36a4:	f3 cf       	rjmp	.-26     	; 0x368c <__vector_119+0x7c>
	rcvF0_read_index = 0;
}
    36a6:	ff 91       	pop	r31
    36a8:	ef 91       	pop	r30
    36aa:	9f 91       	pop	r25
    36ac:	8f 91       	pop	r24
    36ae:	3f 91       	pop	r19
    36b0:	2f 91       	pop	r18
    36b2:	0f 90       	pop	r0
    36b4:	0b be       	out	0x3b, r0	; 59
    36b6:	0f 90       	pop	r0
    36b8:	0f be       	out	0x3f, r0	; 63
    36ba:	0f 90       	pop	r0
    36bc:	1f 90       	pop	r1
    36be:	18 95       	reti

000036c0 <_ZN9frt_queueIjE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    36c0:	fc 01       	movw	r30, r24
    36c2:	84 81       	ldd	r24, Z+4	; 0x04
    36c4:	95 81       	ldd	r25, Z+5	; 0x05
    36c6:	0e 94 cd 0b 	call	0x179a	; 0x179a <uxQueueMessagesWaitingFromISR>
		}
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	08 95       	ret

000036ce <_ZN9frt_queueIjE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    36ce:	fc 01       	movw	r30, r24
    36d0:	84 81       	ldd	r24, Z+4	; 0x04
    36d2:	95 81       	ldd	r25, Z+5	; 0x05
    36d4:	0e 94 cd 0b 	call	0x179a	; 0x179a <uxQueueMessagesWaitingFromISR>
    36d8:	91 e0       	ldi	r25, 0x01	; 1
    36da:	81 11       	cpse	r24, r1
    36dc:	01 c0       	rjmp	.+2      	; 0x36e0 <_ZN9frt_queueIjE13ISR_not_emptyEv+0x12>
    36de:	90 e0       	ldi	r25, 0x00	; 0
		}
    36e0:	89 2f       	mov	r24, r25
    36e2:	08 95       	ret

000036e4 <_ZN9frt_queueIjE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    36e4:	fc 01       	movw	r30, r24
    36e6:	84 81       	ldd	r24, Z+4	; 0x04
    36e8:	95 81       	ldd	r25, Z+5	; 0x05
    36ea:	0e 94 cd 0b 	call	0x179a	; 0x179a <uxQueueMessagesWaitingFromISR>
    36ee:	91 e0       	ldi	r25, 0x01	; 1
    36f0:	81 11       	cpse	r24, r1
    36f2:	90 e0       	ldi	r25, 0x00	; 0
		}
    36f4:	89 2f       	mov	r24, r25
    36f6:	08 95       	ret

000036f8 <_ZN9frt_queueIiE16ISR_num_items_inEv>:
		 *  called only from within an interrupt service routine.
		 *  @return The number of items in the queue
		 */
		size_t ISR_num_items_in (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle));
    36f8:	fc 01       	movw	r30, r24
    36fa:	84 81       	ldd	r24, Z+4	; 0x04
    36fc:	95 81       	ldd	r25, Z+5	; 0x05
    36fe:	0e 94 cd 0b 	call	0x179a	; 0x179a <uxQueueMessagesWaitingFromISR>
		}
    3702:	90 e0       	ldi	r25, 0x00	; 0
    3704:	08 95       	ret

00003706 <_ZN9frt_queueIiE13ISR_not_emptyEv>:
		 *  an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool ISR_not_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) != 0);
    3706:	fc 01       	movw	r30, r24
    3708:	84 81       	ldd	r24, Z+4	; 0x04
    370a:	95 81       	ldd	r25, Z+5	; 0x05
    370c:	0e 94 cd 0b 	call	0x179a	; 0x179a <uxQueueMessagesWaitingFromISR>
    3710:	91 e0       	ldi	r25, 0x01	; 1
    3712:	81 11       	cpse	r24, r1
    3714:	01 c0       	rjmp	.+2      	; 0x3718 <_ZN9frt_queueIiE13ISR_not_emptyEv+0x12>
    3716:	90 e0       	ldi	r25, 0x00	; 0
		}
    3718:	89 2f       	mov	r24, r25
    371a:	08 95       	ret

0000371c <_ZN9frt_queueIiE12ISR_is_emptyEv>:
		 *  routine. It must not be used in normal non-ISR code. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool ISR_is_empty (void)
		{
			return (uxQueueMessagesWaitingFromISR (handle) == 0);
    371c:	fc 01       	movw	r30, r24
    371e:	84 81       	ldd	r24, Z+4	; 0x04
    3720:	95 81       	ldd	r25, Z+5	; 0x05
    3722:	0e 94 cd 0b 	call	0x179a	; 0x179a <uxQueueMessagesWaitingFromISR>
    3726:	91 e0       	ldi	r25, 0x01	; 1
    3728:	81 11       	cpse	r24, r1
    372a:	90 e0       	ldi	r25, 0x00	; 0
		}
    372c:	89 2f       	mov	r24, r25
    372e:	08 95       	ret

00003730 <_ZN9frt_queueIjE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3730:	fc 01       	movw	r30, r24
    3732:	84 81       	ldd	r24, Z+4	; 0x04
    3734:	95 81       	ldd	r25, Z+5	; 0x05
    3736:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
		}
    373a:	90 e0       	ldi	r25, 0x00	; 0
    373c:	08 95       	ret

0000373e <_ZN9frt_queueIjE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    373e:	fc 01       	movw	r30, r24
    3740:	84 81       	ldd	r24, Z+4	; 0x04
    3742:	95 81       	ldd	r25, Z+5	; 0x05
    3744:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
    3748:	91 e0       	ldi	r25, 0x01	; 1
    374a:	81 11       	cpse	r24, r1
    374c:	01 c0       	rjmp	.+2      	; 0x3750 <_ZN9frt_queueIjE9not_emptyEv+0x12>
    374e:	90 e0       	ldi	r25, 0x00	; 0
		}
    3750:	89 2f       	mov	r24, r25
    3752:	08 95       	ret

00003754 <_ZN9frt_queueIjE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    3754:	fc 01       	movw	r30, r24
    3756:	84 81       	ldd	r24, Z+4	; 0x04
    3758:	95 81       	ldd	r25, Z+5	; 0x05
    375a:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
    375e:	91 e0       	ldi	r25, 0x01	; 1
    3760:	81 11       	cpse	r24, r1
    3762:	90 e0       	ldi	r25, 0x00	; 0
		}
    3764:	89 2f       	mov	r24, r25
    3766:	08 95       	ret

00003768 <_ZN9frt_queueIiE12num_items_inEv>:
		 *  ISR_num_items_in() can be called from within an ISR. 
		 *  @return The number of items in the queue
		 */
		size_t num_items_in (void)
		{
			return (uxQueueMessagesWaiting (handle));
    3768:	fc 01       	movw	r30, r24
    376a:	84 81       	ldd	r24, Z+4	; 0x04
    376c:	95 81       	ldd	r25, Z+5	; 0x05
    376e:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
		}
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	08 95       	ret

00003776 <_ZN9frt_queueIiE9not_emptyEv>:
		 *  \b not be called from within an interrupt service routine. 
		 *  @return True if there's something in the queue, false if not
		 */
		bool not_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) != 0);
    3776:	fc 01       	movw	r30, r24
    3778:	84 81       	ldd	r24, Z+4	; 0x04
    377a:	95 81       	ldd	r25, Z+5	; 0x05
    377c:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
    3780:	91 e0       	ldi	r25, 0x01	; 1
    3782:	81 11       	cpse	r24, r1
    3784:	01 c0       	rjmp	.+2      	; 0x3788 <_ZN9frt_queueIiE9not_emptyEv+0x12>
    3786:	90 e0       	ldi	r25, 0x00	; 0
		}
    3788:	89 2f       	mov	r24, r25
    378a:	08 95       	ret

0000378c <_ZN9frt_queueIiE8is_emptyEv>:
		/** This method checks if the queue is empty. 
		*  @return true if the queue is empty, false if there's something in it
		*/
		bool is_empty (void)
		{
			return (uxQueueMessagesWaiting (handle) == 0);
    378c:	fc 01       	movw	r30, r24
    378e:	84 81       	ldd	r24, Z+4	; 0x04
    3790:	95 81       	ldd	r25, Z+5	; 0x05
    3792:	0e 94 c5 0b 	call	0x178a	; 0x178a <uxQueueMessagesWaiting>
    3796:	91 e0       	ldi	r25, 0x01	; 1
    3798:	81 11       	cpse	r24, r1
    379a:	90 e0       	ldi	r25, 0x00	; 0
		}
    379c:	89 2f       	mov	r24, r25
    379e:	08 95       	ret

000037a0 <_ZN9frt_queueIjE10get_a_copyERj>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    37a0:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    37a2:	01 e0       	ldi	r16, 0x01	; 1
    37a4:	2f ef       	ldi	r18, 0xFF	; 255
    37a6:	3f ef       	ldi	r19, 0xFF	; 255
    37a8:	a9 01       	movw	r20, r18
    37aa:	fc 01       	movw	r30, r24
    37ac:	84 81       	ldd	r24, Z+4	; 0x04
    37ae:	95 81       	ldd	r25, Z+5	; 0x05
    37b0:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
}
    37b4:	0f 91       	pop	r16
    37b6:	08 95       	ret

000037b8 <_ZN9frt_queueIjE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    37b8:	0f 93       	push	r16
    37ba:	cf 93       	push	r28
    37bc:	df 93       	push	r29
    37be:	1f 92       	push	r1
    37c0:	1f 92       	push	r1
    37c2:	cd b7       	in	r28, 0x3d	; 61
    37c4:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    37c6:	01 e0       	ldi	r16, 0x01	; 1
    37c8:	2f ef       	ldi	r18, 0xFF	; 255
    37ca:	3f ef       	ldi	r19, 0xFF	; 255
    37cc:	a9 01       	movw	r20, r18
    37ce:	be 01       	movw	r22, r28
    37d0:	6f 5f       	subi	r22, 0xFF	; 255
    37d2:	7f 4f       	sbci	r23, 0xFF	; 255
    37d4:	fc 01       	movw	r30, r24
    37d6:	84 81       	ldd	r24, Z+4	; 0x04
    37d8:	95 81       	ldd	r25, Z+5	; 0x05
    37da:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
	return (recv_item);
}
    37de:	89 81       	ldd	r24, Y+1	; 0x01
    37e0:	9a 81       	ldd	r25, Y+2	; 0x02
    37e2:	0f 90       	pop	r0
    37e4:	0f 90       	pop	r0
    37e6:	df 91       	pop	r29
    37e8:	cf 91       	pop	r28
    37ea:	0f 91       	pop	r16
    37ec:	08 95       	ret

000037ee <_ZN9frt_queueIjE3getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    37ee:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    37f0:	00 e0       	ldi	r16, 0x00	; 0
    37f2:	2f ef       	ldi	r18, 0xFF	; 255
    37f4:	3f ef       	ldi	r19, 0xFF	; 255
    37f6:	a9 01       	movw	r20, r18
    37f8:	fc 01       	movw	r30, r24
    37fa:	84 81       	ldd	r24, Z+4	; 0x04
    37fc:	95 81       	ldd	r25, Z+5	; 0x05
    37fe:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
}
    3802:	0f 91       	pop	r16
    3804:	08 95       	ret

00003806 <_ZN9frt_queueIjE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    3806:	0f 93       	push	r16
    3808:	cf 93       	push	r28
    380a:	df 93       	push	r29
    380c:	1f 92       	push	r1
    380e:	1f 92       	push	r1
    3810:	cd b7       	in	r28, 0x3d	; 61
    3812:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    3814:	00 e0       	ldi	r16, 0x00	; 0
    3816:	2f ef       	ldi	r18, 0xFF	; 255
    3818:	3f ef       	ldi	r19, 0xFF	; 255
    381a:	a9 01       	movw	r20, r18
    381c:	be 01       	movw	r22, r28
    381e:	6f 5f       	subi	r22, 0xFF	; 255
    3820:	7f 4f       	sbci	r23, 0xFF	; 255
    3822:	fc 01       	movw	r30, r24
    3824:	84 81       	ldd	r24, Z+4	; 0x04
    3826:	95 81       	ldd	r25, Z+5	; 0x05
    3828:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
	return (recv_item);
}
    382c:	89 81       	ldd	r24, Y+1	; 0x01
    382e:	9a 81       	ldd	r25, Y+2	; 0x02
    3830:	0f 90       	pop	r0
    3832:	0f 90       	pop	r0
    3834:	df 91       	pop	r29
    3836:	cf 91       	pop	r28
    3838:	0f 91       	pop	r16
    383a:	08 95       	ret

0000383c <_ZN9frt_queueIiE10get_a_copyERi>:
 *  \c xQueuePeekFromISR() which would allow copying items from a queue in an ISR. 
 *  @param item A reference to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get_a_copy (data_type& item)
    383c:	0f 93       	push	r16
{
	xQueuePeek (handle, &item, portMAX_DELAY);
    383e:	01 e0       	ldi	r16, 0x01	; 1
    3840:	2f ef       	ldi	r18, 0xFF	; 255
    3842:	3f ef       	ldi	r19, 0xFF	; 255
    3844:	a9 01       	movw	r20, r18
    3846:	fc 01       	movw	r30, r24
    3848:	84 81       	ldd	r24, Z+4	; 0x04
    384a:	95 81       	ldd	r25, Z+5	; 0x05
    384c:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
}
    3850:	0f 91       	pop	r16
    3852:	08 95       	ret

00003854 <_ZN9frt_queueIiE10get_a_copyEv>:
 *          data type if we couldn't get any data from the queue and the attempt
 *          timed out
 */

template <class data_type>
inline data_type frt_queue<data_type>::get_a_copy (void)
    3854:	0f 93       	push	r16
    3856:	cf 93       	push	r28
    3858:	df 93       	push	r29
    385a:	1f 92       	push	r1
    385c:	1f 92       	push	r1
    385e:	cd b7       	in	r28, 0x3d	; 61
    3860:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueuePeek (handle, &recv_item, portMAX_DELAY);
    3862:	01 e0       	ldi	r16, 0x01	; 1
    3864:	2f ef       	ldi	r18, 0xFF	; 255
    3866:	3f ef       	ldi	r19, 0xFF	; 255
    3868:	a9 01       	movw	r20, r18
    386a:	be 01       	movw	r22, r28
    386c:	6f 5f       	subi	r22, 0xFF	; 255
    386e:	7f 4f       	sbci	r23, 0xFF	; 255
    3870:	fc 01       	movw	r30, r24
    3872:	84 81       	ldd	r24, Z+4	; 0x04
    3874:	95 81       	ldd	r25, Z+5	; 0x05
    3876:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
	return (recv_item);
}
    387a:	89 81       	ldd	r24, Y+1	; 0x01
    387c:	9a 81       	ldd	r25, Y+2	; 0x02
    387e:	0f 90       	pop	r0
    3880:	0f 90       	pop	r0
    3882:	df 91       	pop	r29
    3884:	cf 91       	pop	r28
    3886:	0f 91       	pop	r16
    3888:	08 95       	ret

0000388a <_ZN9frt_queueIiE3getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::get (data_type* p_item)
    388a:	0f 93       	push	r16
{
	xQueueReceive (handle, p_item, portMAX_DELAY);
    388c:	00 e0       	ldi	r16, 0x00	; 0
    388e:	2f ef       	ldi	r18, 0xFF	; 255
    3890:	3f ef       	ldi	r19, 0xFF	; 255
    3892:	a9 01       	movw	r20, r18
    3894:	fc 01       	movw	r30, r24
    3896:	84 81       	ldd	r24, Z+4	; 0x04
    3898:	95 81       	ldd	r25, Z+5	; 0x05
    389a:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
}
    389e:	0f 91       	pop	r16
    38a0:	08 95       	ret

000038a2 <_ZN9frt_queueIiE3getEv>:
 *  up. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::get (void)
    38a2:	0f 93       	push	r16
    38a4:	cf 93       	push	r28
    38a6:	df 93       	push	r29
    38a8:	1f 92       	push	r1
    38aa:	1f 92       	push	r1
    38ac:	cd b7       	in	r28, 0x3d	; 61
    38ae:	de b7       	in	r29, 0x3e	; 62
{
	data_type recv_item;                    // Data item read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceive (handle, &recv_item, portMAX_DELAY);
    38b0:	00 e0       	ldi	r16, 0x00	; 0
    38b2:	2f ef       	ldi	r18, 0xFF	; 255
    38b4:	3f ef       	ldi	r19, 0xFF	; 255
    38b6:	a9 01       	movw	r20, r18
    38b8:	be 01       	movw	r22, r28
    38ba:	6f 5f       	subi	r22, 0xFF	; 255
    38bc:	7f 4f       	sbci	r23, 0xFF	; 255
    38be:	fc 01       	movw	r30, r24
    38c0:	84 81       	ldd	r24, Z+4	; 0x04
    38c2:	95 81       	ldd	r25, Z+5	; 0x05
    38c4:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xQueueGenericReceive>
	return (recv_item);
}
    38c8:	89 81       	ldd	r24, Y+1	; 0x01
    38ca:	9a 81       	ldd	r25, Y+2	; 0x02
    38cc:	0f 90       	pop	r0
    38ce:	0f 90       	pop	r0
    38d0:	df 91       	pop	r29
    38d2:	cf 91       	pop	r28
    38d4:	0f 91       	pop	r16
    38d6:	08 95       	ret

000038d8 <_ZN9frt_queueIjE7ISR_getEPj>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    38d8:	cf 93       	push	r28
    38da:	df 93       	push	r29
    38dc:	1f 92       	push	r1
    38de:	cd b7       	in	r28, 0x3d	; 61
    38e0:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    38e2:	ae 01       	movw	r20, r28
    38e4:	4f 5f       	subi	r20, 0xFF	; 255
    38e6:	5f 4f       	sbci	r21, 0xFF	; 255
    38e8:	fc 01       	movw	r30, r24
    38ea:	84 81       	ldd	r24, Z+4	; 0x04
    38ec:	95 81       	ldd	r25, Z+5	; 0x05
    38ee:	0e 94 98 0b 	call	0x1730	; 0x1730 <xQueueReceiveFromISR>
}
    38f2:	0f 90       	pop	r0
    38f4:	df 91       	pop	r29
    38f6:	cf 91       	pop	r28
    38f8:	08 95       	ret

000038fa <_ZN9frt_queueIjE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    38fa:	cf 93       	push	r28
    38fc:	df 93       	push	r29
    38fe:	00 d0       	rcall	.+0      	; 0x3900 <_ZN9frt_queueIjE7ISR_getEv+0x6>
    3900:	cd b7       	in	r28, 0x3d	; 61
    3902:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3904:	ae 01       	movw	r20, r28
    3906:	4d 5f       	subi	r20, 0xFD	; 253
    3908:	5f 4f       	sbci	r21, 0xFF	; 255
    390a:	be 01       	movw	r22, r28
    390c:	6f 5f       	subi	r22, 0xFF	; 255
    390e:	7f 4f       	sbci	r23, 0xFF	; 255
    3910:	fc 01       	movw	r30, r24
    3912:	84 81       	ldd	r24, Z+4	; 0x04
    3914:	95 81       	ldd	r25, Z+5	; 0x05
    3916:	0e 94 98 0b 	call	0x1730	; 0x1730 <xQueueReceiveFromISR>
	return (recv_item);
}
    391a:	89 81       	ldd	r24, Y+1	; 0x01
    391c:	9a 81       	ldd	r25, Y+2	; 0x02
    391e:	23 96       	adiw	r28, 0x03	; 3
    3920:	cd bf       	out	0x3d, r28	; 61
    3922:	de bf       	out	0x3e, r29	; 62
    3924:	df 91       	pop	r29
    3926:	cf 91       	pop	r28
    3928:	08 95       	ret

0000392a <_ZN9frt_queueIiE7ISR_getEPi>:
 *  service routine. 
 *  @param p_item A pointer to the data item into which received data will go
 */

template <class data_type>
inline void frt_queue<data_type>::ISR_get (data_type* p_item)
    392a:	cf 93       	push	r28
    392c:	df 93       	push	r29
    392e:	1f 92       	push	r1
    3930:	cd b7       	in	r28, 0x3d	; 61
    3932:	de b7       	in	r29, 0x3e	; 62
{
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, and
	// nothing will actually be copied
	xQueueReceiveFromISR (handle, p_item, &task_awakened);
    3934:	ae 01       	movw	r20, r28
    3936:	4f 5f       	subi	r20, 0xFF	; 255
    3938:	5f 4f       	sbci	r21, 0xFF	; 255
    393a:	fc 01       	movw	r30, r24
    393c:	84 81       	ldd	r24, Z+4	; 0x04
    393e:	95 81       	ldd	r25, Z+5	; 0x05
    3940:	0e 94 98 0b 	call	0x1730	; 0x1730 <xQueueReceiveFromISR>
}
    3944:	0f 90       	pop	r0
    3946:	df 91       	pop	r29
    3948:	cf 91       	pop	r28
    394a:	08 95       	ret

0000394c <_ZN9frt_queueIiE7ISR_getEv>:
 *  service routine. This method must not be called from within normal non-ISR code. 
 *  @return The data retrieved from the queue
 */

template <class data_type>
inline data_type frt_queue<data_type>::ISR_get (void)
    394c:	cf 93       	push	r28
    394e:	df 93       	push	r29
    3950:	00 d0       	rcall	.+0      	; 0x3952 <_ZN9frt_queueIiE7ISR_getEv+0x6>
    3952:	cd b7       	in	r28, 0x3d	; 61
    3954:	de b7       	in	r29, 0x3e	; 62
	data_type recv_item;                    // Data item read from the queue
	signed portBASE_TYPE task_awakened;     // Checks if a task will wake up

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue, so
	// we'll return the item as created by its default constructor
	xQueueReceiveFromISR (handle, &recv_item, &task_awakened);
    3956:	ae 01       	movw	r20, r28
    3958:	4d 5f       	subi	r20, 0xFD	; 253
    395a:	5f 4f       	sbci	r21, 0xFF	; 255
    395c:	be 01       	movw	r22, r28
    395e:	6f 5f       	subi	r22, 0xFF	; 255
    3960:	7f 4f       	sbci	r23, 0xFF	; 255
    3962:	fc 01       	movw	r30, r24
    3964:	84 81       	ldd	r24, Z+4	; 0x04
    3966:	95 81       	ldd	r25, Z+5	; 0x05
    3968:	0e 94 98 0b 	call	0x1730	; 0x1730 <xQueueReceiveFromISR>
	return (recv_item);
}
    396c:	89 81       	ldd	r24, Y+1	; 0x01
    396e:	9a 81       	ldd	r25, Y+2	; 0x02
    3970:	23 96       	adiw	r28, 0x03	; 3
    3972:	cd bf       	out	0x3d, r28	; 61
    3974:	de bf       	out	0x3e, r29	; 62
    3976:	df 91       	pop	r29
    3978:	cf 91       	pop	r28
    397a:	08 95       	ret

0000397c <_ZN9frt_queueIjE11ISR_butt_inERKj>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    397c:	cf 93       	push	r28
    397e:	df 93       	push	r29
    3980:	1f 92       	push	r1
    3982:	cd b7       	in	r28, 0x3d	; 61
    3984:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3986:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    3988:	21 e0       	ldi	r18, 0x01	; 1
    398a:	ae 01       	movw	r20, r28
    398c:	4f 5f       	subi	r20, 0xFF	; 255
    398e:	5f 4f       	sbci	r21, 0xFF	; 255
    3990:	fc 01       	movw	r30, r24
    3992:	84 81       	ldd	r24, Z+4	; 0x04
    3994:	95 81       	ldd	r25, Z+5	; 0x05
    3996:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    399a:	91 e0       	ldi	r25, 0x01	; 1
    399c:	81 11       	cpse	r24, r1
    399e:	01 c0       	rjmp	.+2      	; 0x39a2 <_ZN9frt_queueIjE11ISR_butt_inERKj+0x26>
    39a0:	90 e0       	ldi	r25, 0x00	; 0
}
    39a2:	89 2f       	mov	r24, r25
    39a4:	0f 90       	pop	r0
    39a6:	df 91       	pop	r29
    39a8:	cf 91       	pop	r28
    39aa:	08 95       	ret

000039ac <_ZN9frt_queueIjE7ISR_putERKj>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    39ac:	cf 93       	push	r28
    39ae:	df 93       	push	r29
    39b0:	1f 92       	push	r1
    39b2:	cd b7       	in	r28, 0x3d	; 61
    39b4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    39b6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    39b8:	20 e0       	ldi	r18, 0x00	; 0
    39ba:	ae 01       	movw	r20, r28
    39bc:	4f 5f       	subi	r20, 0xFF	; 255
    39be:	5f 4f       	sbci	r21, 0xFF	; 255
    39c0:	fc 01       	movw	r30, r24
    39c2:	84 81       	ldd	r24, Z+4	; 0x04
    39c4:	95 81       	ldd	r25, Z+5	; 0x05
    39c6:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    39ca:	91 e0       	ldi	r25, 0x01	; 1
    39cc:	81 11       	cpse	r24, r1
    39ce:	01 c0       	rjmp	.+2      	; 0x39d2 <_ZN9frt_queueIjE7ISR_putERKj+0x26>
    39d0:	90 e0       	ldi	r25, 0x00	; 0
}
    39d2:	89 2f       	mov	r24, r25
    39d4:	0f 90       	pop	r0
    39d6:	df 91       	pop	r29
    39d8:	cf 91       	pop	r28
    39da:	08 95       	ret

000039dc <_ZN9frt_queueIiE11ISR_butt_inERKi>:
 *              the front of the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
bool frt_queue<data_type>::ISR_butt_in (const data_type& item)
    39dc:	cf 93       	push	r28
    39de:	df 93       	push	r29
    39e0:	1f 92       	push	r1
    39e2:	cd b7       	in	r28, 0x3d	; 61
    39e4:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    39e6:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;                      // Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToFrontFromISR (handle, &item, &shouldSwitch));
    39e8:	21 e0       	ldi	r18, 0x01	; 1
    39ea:	ae 01       	movw	r20, r28
    39ec:	4f 5f       	subi	r20, 0xFF	; 255
    39ee:	5f 4f       	sbci	r21, 0xFF	; 255
    39f0:	fc 01       	movw	r30, r24
    39f2:	84 81       	ldd	r24, Z+4	; 0x04
    39f4:	95 81       	ldd	r25, Z+5	; 0x05
    39f6:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    39fa:	91 e0       	ldi	r25, 0x01	; 1
    39fc:	81 11       	cpse	r24, r1
    39fe:	01 c0       	rjmp	.+2      	; 0x3a02 <_ZN9frt_queueIiE11ISR_butt_inERKi+0x26>
    3a00:	90 e0       	ldi	r25, 0x00	; 0
}
    3a02:	89 2f       	mov	r24, r25
    3a04:	0f 90       	pop	r0
    3a06:	df 91       	pop	r29
    3a08:	cf 91       	pop	r28
    3a0a:	08 95       	ret

00003a0c <_ZN9frt_queueIiE7ISR_putERKi>:
 *  @param item Reference to the item which is going to be put into the queue
 *  @return True if the item was successfully queued, false if not
 */

template <class data_type>
inline bool frt_queue<data_type>::ISR_put (const data_type& item)
    3a0c:	cf 93       	push	r28
    3a0e:	df 93       	push	r29
    3a10:	1f 92       	push	r1
    3a12:	cd b7       	in	r28, 0x3d	; 61
    3a14:	de b7       	in	r29, 0x3e	; 62
{
	// This value is set to true if a context switch should occur due to this data
	signed portBASE_TYPE shouldSwitch = pdFALSE;
    3a16:	19 82       	std	Y+1, r1	; 0x01

	bool return_value;						// Value returned from this method

	// Call the FreeRTOS function and save its return value
	return_value = (bool)(xQueueSendToBackFromISR (handle, &item, &shouldSwitch));
    3a18:	20 e0       	ldi	r18, 0x00	; 0
    3a1a:	ae 01       	movw	r20, r28
    3a1c:	4f 5f       	subi	r20, 0xFF	; 255
    3a1e:	5f 4f       	sbci	r21, 0xFF	; 255
    3a20:	fc 01       	movw	r30, r24
    3a22:	84 81       	ldd	r24, Z+4	; 0x04
    3a24:	95 81       	ldd	r25, Z+5	; 0x05
    3a26:	0e 94 a8 0a 	call	0x1550	; 0x1550 <xQueueGenericSendFromISR>
// 	{
// 		taskYIELD_FROM_ISR ();
// 	}

	// Return the return value saved from the call to xQueueSendToBackFromISR()
	return (return_value);
    3a2a:	91 e0       	ldi	r25, 0x01	; 1
    3a2c:	81 11       	cpse	r24, r1
    3a2e:	01 c0       	rjmp	.+2      	; 0x3a32 <_ZN9frt_queueIiE7ISR_putERKi+0x26>
    3a30:	90 e0       	ldi	r25, 0x00	; 0
}
    3a32:	89 2f       	mov	r24, r25
    3a34:	0f 90       	pop	r0
    3a36:	df 91       	pop	r29
    3a38:	cf 91       	pop	r28
    3a3a:	08 95       	ret

00003a3c <_ZN9frt_queueIjE7butt_inERKj>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3a3c:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3a3e:	fc 01       	movw	r30, r24
    3a40:	26 81       	ldd	r18, Z+6	; 0x06
    3a42:	37 81       	ldd	r19, Z+7	; 0x07
    3a44:	40 85       	ldd	r20, Z+8	; 0x08
    3a46:	51 85       	ldd	r21, Z+9	; 0x09
    3a48:	01 e0       	ldi	r16, 0x01	; 1
    3a4a:	84 81       	ldd	r24, Z+4	; 0x04
    3a4c:	95 81       	ldd	r25, Z+5	; 0x05
    3a4e:	0e 94 0d 0a 	call	0x141a	; 0x141a <xQueueGenericSend>
    3a52:	91 e0       	ldi	r25, 0x01	; 1
    3a54:	81 11       	cpse	r24, r1
    3a56:	01 c0       	rjmp	.+2      	; 0x3a5a <_ZN9frt_queueIjE7butt_inERKj+0x1e>
    3a58:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a5a:	89 2f       	mov	r24, r25
    3a5c:	0f 91       	pop	r16
    3a5e:	08 95       	ret

00003a60 <_ZN9frt_queueIjE3putERKj>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3a60:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3a62:	fc 01       	movw	r30, r24
    3a64:	26 81       	ldd	r18, Z+6	; 0x06
    3a66:	37 81       	ldd	r19, Z+7	; 0x07
    3a68:	40 85       	ldd	r20, Z+8	; 0x08
    3a6a:	51 85       	ldd	r21, Z+9	; 0x09
    3a6c:	00 e0       	ldi	r16, 0x00	; 0
    3a6e:	84 81       	ldd	r24, Z+4	; 0x04
    3a70:	95 81       	ldd	r25, Z+5	; 0x05
    3a72:	0e 94 0d 0a 	call	0x141a	; 0x141a <xQueueGenericSend>
    3a76:	91 e0       	ldi	r25, 0x01	; 1
    3a78:	81 11       	cpse	r24, r1
    3a7a:	01 c0       	rjmp	.+2      	; 0x3a7e <_ZN9frt_queueIjE3putERKj+0x1e>
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
		}
    3a7e:	89 2f       	mov	r24, r25
    3a80:	0f 91       	pop	r16
    3a82:	08 95       	ret

00003a84 <_ZN9frt_queueIiE7butt_inERKi>:
		 *  \b not be used within an interrupt service routine. 
		 *  @param item Reference to the item which is going to be (rudely) put into 
		 *              the front of the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool butt_in (const data_type& item)
    3a84:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToFront (handle, &item, ticks_to_wait)));
    3a86:	fc 01       	movw	r30, r24
    3a88:	26 81       	ldd	r18, Z+6	; 0x06
    3a8a:	37 81       	ldd	r19, Z+7	; 0x07
    3a8c:	40 85       	ldd	r20, Z+8	; 0x08
    3a8e:	51 85       	ldd	r21, Z+9	; 0x09
    3a90:	01 e0       	ldi	r16, 0x01	; 1
    3a92:	84 81       	ldd	r24, Z+4	; 0x04
    3a94:	95 81       	ldd	r25, Z+5	; 0x05
    3a96:	0e 94 0d 0a 	call	0x141a	; 0x141a <xQueueGenericSend>
    3a9a:	91 e0       	ldi	r25, 0x01	; 1
    3a9c:	81 11       	cpse	r24, r1
    3a9e:	01 c0       	rjmp	.+2      	; 0x3aa2 <_ZN9frt_queueIiE7butt_inERKi+0x1e>
    3aa0:	90 e0       	ldi	r25, 0x00	; 0
		}
    3aa2:	89 2f       	mov	r24, r25
    3aa4:	0f 91       	pop	r16
    3aa6:	08 95       	ret

00003aa8 <_ZN9frt_queueIiE3putERKi>:
		 *  an item into the front of the queue so it will be retreived first, use 
		 *  \c butt_in() instead. This method must \b not be used within an ISR.
		 *  @param item Reference to the item which is going to be put into the queue
		 *  @return True if the item was successfully queued, false if not
		 */
		bool put (const data_type& item)
    3aa8:	0f 93       	push	r16
		{
			return ((bool)(xQueueSendToBack (handle, &item, ticks_to_wait)));
    3aaa:	fc 01       	movw	r30, r24
    3aac:	26 81       	ldd	r18, Z+6	; 0x06
    3aae:	37 81       	ldd	r19, Z+7	; 0x07
    3ab0:	40 85       	ldd	r20, Z+8	; 0x08
    3ab2:	51 85       	ldd	r21, Z+9	; 0x09
    3ab4:	00 e0       	ldi	r16, 0x00	; 0
    3ab6:	84 81       	ldd	r24, Z+4	; 0x04
    3ab8:	95 81       	ldd	r25, Z+5	; 0x05
    3aba:	0e 94 0d 0a 	call	0x141a	; 0x141a <xQueueGenericSend>
    3abe:	91 e0       	ldi	r25, 0x01	; 1
    3ac0:	81 11       	cpse	r24, r1
    3ac2:	01 c0       	rjmp	.+2      	; 0x3ac6 <_ZN9frt_queueIiE3putERKi+0x1e>
    3ac4:	90 e0       	ldi	r25, 0x00	; 0
		}
    3ac6:	89 2f       	mov	r24, r25
    3ac8:	0f 91       	pop	r16
    3aca:	08 95       	ret

00003acc <_Z8CCPWritePVhh>:
 *
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */
void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    3acc:	0f 93       	push	r16
    3ace:	cf 93       	push	r28
    3ad0:	df 93       	push	r29
    3ad2:	1f 92       	push	r1
    3ad4:	cd b7       	in	r28, 0x3d	; 61
    3ad6:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3ad8:	2f b7       	in	r18, 0x3f	; 63
    3ada:	29 83       	std	Y+1, r18	; 0x01
	cli();
    3adc:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    3ade:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3ae0:	fc 01       	movw	r30, r24
    3ae2:	08 ed       	ldi	r16, 0xD8	; 216
    3ae4:	04 bf       	out	0x34, r16	; 52
    3ae6:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3ae8:	89 81       	ldd	r24, Y+1	; 0x01
    3aea:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    3aec:	0f 90       	pop	r0
    3aee:	df 91       	pop	r29
    3af0:	cf 91       	pop	r28
    3af2:	0f 91       	pop	r16
    3af4:	08 95       	ret

00003af6 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3af6:	2f 92       	push	r2
    3af8:	3f 92       	push	r3
    3afa:	4f 92       	push	r4
    3afc:	5f 92       	push	r5
    3afe:	6f 92       	push	r6
    3b00:	7f 92       	push	r7
    3b02:	8f 92       	push	r8
    3b04:	9f 92       	push	r9
    3b06:	af 92       	push	r10
    3b08:	bf 92       	push	r11
    3b0a:	cf 92       	push	r12
    3b0c:	df 92       	push	r13
    3b0e:	ef 92       	push	r14
    3b10:	ff 92       	push	r15
    3b12:	0f 93       	push	r16
    3b14:	1f 93       	push	r17
    3b16:	cf 93       	push	r28
    3b18:	df 93       	push	r29
    3b1a:	cd b7       	in	r28, 0x3d	; 61
    3b1c:	de b7       	in	r29, 0x3e	; 62
    3b1e:	6d 97       	sbiw	r28, 0x1d	; 29
    3b20:	cd bf       	out	0x3d, r28	; 61
    3b22:	de bf       	out	0x3e, r29	; 62
	cli();
    3b24:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3b26:	e0 e5       	ldi	r30, 0x50	; 80
    3b28:	f0 e0       	ldi	r31, 0x00	; 0
    3b2a:	80 81       	ld	r24, Z
    3b2c:	82 60       	ori	r24, 0x02	; 2
    3b2e:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    3b30:	81 81       	ldd	r24, Z+1	; 0x01
    3b32:	81 ff       	sbrs	r24, 1
    3b34:	fd cf       	rjmp	.-6      	; 0x3b30 <main+0x3a>
		// Enable the DFLL auto-calibration
//		DFLLRC32M.CTRL = (1 << DFLL_ENABLE_bp);
//		DFLLRC2M.CTRL = (1 << DFLL_ENABLE_bp);

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3b36:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3b3a:	68 7f       	andi	r22, 0xF8	; 248
    3b3c:	61 60       	ori	r22, 0x01	; 1
    3b3e:	80 e4       	ldi	r24, 0x40	; 64
    3b40:	90 e0       	ldi	r25, 0x00	; 0
    3b42:	0e 94 66 1d 	call	0x3acc	; 0x3acc <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    3b46:	e0 e5       	ldi	r30, 0x50	; 80
    3b48:	f0 e0       	ldi	r31, 0x00	; 0
    3b4a:	80 81       	ld	r24, Z
    3b4c:	8e 7f       	andi	r24, 0xFE	; 254
    3b4e:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    3b50:	9d ef       	ldi	r25, 0xFD	; 253
    3b52:	88 ed       	ldi	r24, 0xD8	; 216
    3b54:	08 b6       	in	r0, 0x38	; 56
    3b56:	18 be       	out	0x38, r1	; 56
    3b58:	84 bf       	out	0x34, r24	; 52
    3b5a:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    3b5e:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0,&USARTE0); // Create a serial device on USART E0
    3b60:	40 ea       	ldi	r20, 0xA0	; 160
    3b62:	5a e0       	ldi	r21, 0x0A	; 10
    3b64:	60 e0       	ldi	r22, 0x00	; 0
    3b66:	70 e0       	ldi	r23, 0x00	; 0
    3b68:	ce 01       	movw	r24, r28
    3b6a:	01 96       	adiw	r24, 0x01	; 1
    3b6c:	0e 94 bf 18 	call	0x317e	; 0x317e <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    3b70:	67 e0       	ldi	r22, 0x07	; 7
    3b72:	ce 01       	movw	r24, r28
    3b74:	01 96       	adiw	r24, 0x01	; 1
    3b76:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    3b7a:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    3b7c:	64 e6       	ldi	r22, 0x64	; 100
    3b7e:	70 e2       	ldi	r23, 0x20	; 32
    3b80:	0e 94 e5 16 	call	0x2dca	; 0x2dca <_ZN8emstream4putsEPKc>
    3b84:	66 e0       	ldi	r22, 0x06	; 6
    3b86:	c8 01       	movw	r24, r16
    3b88:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
    3b8c:	66 e0       	ldi	r22, 0x06	; 6
    3b8e:	0e 94 1c 17 	call	0x2e38	; 0x2e38 <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    3b92:	82 e1       	ldi	r24, 0x12	; 18
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	0e 94 24 16 	call	0x2c48	; 0x2c48 <_Znwj>
    3b9a:	8e 01       	movw	r16, r28
    3b9c:	0f 5f       	subi	r16, 0xFF	; 255
    3b9e:	1f 4f       	sbci	r17, 0xFF	; 255
    3ba0:	24 e0       	ldi	r18, 0x04	; 4
    3ba2:	31 e0       	ldi	r19, 0x01	; 1
    3ba4:	40 e0       	ldi	r20, 0x00	; 0
    3ba6:	63 e8       	ldi	r22, 0x83	; 131
    3ba8:	70 e2       	ldi	r23, 0x20	; 32
    3baa:	0e 94 87 03 	call	0x70e	; 0x70e <_ZN9task_userC1EPKchjP8emstream>
	
	// The LED blinking task is also low priority and is used to test the timing accuracy
	// of the task transitions.
	new task_LED ("LED BLINKER", task_priority (1), 260, &ser_dev);
    3bae:	82 e1       	ldi	r24, 0x12	; 18
    3bb0:	90 e0       	ldi	r25, 0x00	; 0
    3bb2:	0e 94 24 16 	call	0x2c48	; 0x2c48 <_Znwj>
    3bb6:	24 e0       	ldi	r18, 0x04	; 4
    3bb8:	31 e0       	ldi	r19, 0x01	; 1
    3bba:	41 e0       	ldi	r20, 0x01	; 1
    3bbc:	6b e8       	ldi	r22, 0x8B	; 139
    3bbe:	70 e2       	ldi	r23, 0x20	; 32
    3bc0:	0e 94 77 03 	call	0x6ee	; 0x6ee <_ZN8task_LEDC1EPKchjP8emstream>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3bc4:	87 e0       	ldi	r24, 0x07	; 7
    3bc6:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3bca:	78 94       	sei
    3bcc:	0f 2e       	mov	r0, r31
    3bce:	fc ee       	ldi	r31, 0xEC	; 236
    3bd0:	cf 2e       	mov	r12, r31
    3bd2:	f1 e4       	ldi	r31, 0x41	; 65
    3bd4:	df 2e       	mov	r13, r31
    3bd6:	f0 2d       	mov	r31, r0
    3bd8:	0f 2e       	mov	r0, r31
    3bda:	f9 e2       	ldi	r31, 0x29	; 41
    3bdc:	ef 2e       	mov	r14, r31
    3bde:	f2 e4       	ldi	r31, 0x42	; 66
    3be0:	ff 2e       	mov	r15, r31
    3be2:	f0 2d       	mov	r31, r0
    3be4:	86 01       	movw	r16, r12
	// Build over-modulated lookup table to be used for PWM generation.
	{
		// 0 < theta < 60
		for(uint8_t i=0;i<=60;i++)
		{
			overmod_lut[i]=(uint8_t) ( 255 * (sin(i / 180.0 * 3.14159265358979323846)) / (sin((120.0 - i) / 180.0 *  3.14159265358979323846)));
    3be6:	b8 01       	movw	r22, r16
    3be8:	6c 19       	sub	r22, r12
    3bea:	7d 09       	sbc	r23, r13
    3bec:	07 2e       	mov	r0, r23
    3bee:	00 0c       	add	r0, r0
    3bf0:	88 0b       	sbc	r24, r24
    3bf2:	99 0b       	sbc	r25, r25
    3bf4:	0e 94 fd 22 	call	0x45fa	; 0x45fa <__floatsisf>
    3bf8:	4b 01       	movw	r8, r22
    3bfa:	5c 01       	movw	r10, r24
    3bfc:	20 e0       	ldi	r18, 0x00	; 0
    3bfe:	30 e0       	ldi	r19, 0x00	; 0
    3c00:	44 e3       	ldi	r20, 0x34	; 52
    3c02:	53 e4       	ldi	r21, 0x43	; 67
    3c04:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <__divsf3>
    3c08:	2b ed       	ldi	r18, 0xDB	; 219
    3c0a:	3f e0       	ldi	r19, 0x0F	; 15
    3c0c:	49 e4       	ldi	r20, 0x49	; 73
    3c0e:	50 e4       	ldi	r21, 0x40	; 64
    3c10:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3c14:	0e 94 35 24 	call	0x486a	; 0x486a <sin>
    3c18:	2b 01       	movw	r4, r22
    3c1a:	3c 01       	movw	r6, r24
    3c1c:	a5 01       	movw	r20, r10
    3c1e:	94 01       	movw	r18, r8
    3c20:	60 e0       	ldi	r22, 0x00	; 0
    3c22:	70 e0       	ldi	r23, 0x00	; 0
    3c24:	80 ef       	ldi	r24, 0xF0	; 240
    3c26:	92 e4       	ldi	r25, 0x42	; 66
    3c28:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__subsf3>
    3c2c:	20 e0       	ldi	r18, 0x00	; 0
    3c2e:	30 e0       	ldi	r19, 0x00	; 0
    3c30:	44 e3       	ldi	r20, 0x34	; 52
    3c32:	53 e4       	ldi	r21, 0x43	; 67
    3c34:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <__divsf3>
    3c38:	2b ed       	ldi	r18, 0xDB	; 219
    3c3a:	3f e0       	ldi	r19, 0x0F	; 15
    3c3c:	49 e4       	ldi	r20, 0x49	; 73
    3c3e:	50 e4       	ldi	r21, 0x40	; 64
    3c40:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3c44:	0e 94 35 24 	call	0x486a	; 0x486a <sin>
    3c48:	4b 01       	movw	r8, r22
    3c4a:	5c 01       	movw	r10, r24
    3c4c:	20 e0       	ldi	r18, 0x00	; 0
    3c4e:	30 e0       	ldi	r19, 0x00	; 0
    3c50:	4f e7       	ldi	r20, 0x7F	; 127
    3c52:	53 e4       	ldi	r21, 0x43	; 67
    3c54:	c3 01       	movw	r24, r6
    3c56:	b2 01       	movw	r22, r4
    3c58:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3c5c:	a5 01       	movw	r20, r10
    3c5e:	94 01       	movw	r18, r8
    3c60:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <__divsf3>
    3c64:	0e 94 cc 22 	call	0x4598	; 0x4598 <__fixunssfsi>
    3c68:	f8 01       	movw	r30, r16
    3c6a:	61 93       	st	Z+, r22
    3c6c:	8f 01       	movw	r16, r30
	sei();
	
	// Build over-modulated lookup table to be used for PWM generation.
	{
		// 0 < theta < 60
		for(uint8_t i=0;i<=60;i++)
    3c6e:	ee 15       	cp	r30, r14
    3c70:	ff 05       	cpc	r31, r15
    3c72:	09 f0       	breq	.+2      	; 0x3c76 <main+0x180>
    3c74:	b8 cf       	rjmp	.-144    	; 0x3be6 <main+0xf0>
    3c76:	0f 2e       	mov	r0, r31
    3c78:	ff ea       	ldi	r31, 0xAF	; 175
    3c7a:	cf 2e       	mov	r12, r31
    3c7c:	f1 e4       	ldi	r31, 0x41	; 65
    3c7e:	df 2e       	mov	r13, r31
    3c80:	f0 2d       	mov	r31, r0
    3c82:	0f 2e       	mov	r0, r31
    3c84:	f2 e7       	ldi	r31, 0x72	; 114
    3c86:	2f 2e       	mov	r2, r31
    3c88:	f1 e4       	ldi	r31, 0x41	; 65
    3c8a:	3f 2e       	mov	r3, r31
    3c8c:	f0 2d       	mov	r31, r0
    3c8e:	0f 2e       	mov	r0, r31
    3c90:	f8 e7       	ldi	r31, 0x78	; 120
    3c92:	ef 2e       	mov	r14, r31
    3c94:	f1 2c       	mov	r15, r1
    3c96:	f0 2d       	mov	r31, r0
    3c98:	00 e0       	ldi	r16, 0x00	; 0
    3c9a:	10 e0       	ldi	r17, 0x00	; 0
	{
		// 0 < theta < 60
		for(uint8_t i=0;i<=60;i++)
		{
			// The first half of the lookup table is for Phase A 0-60 degrees
			spacevec1_lut[i]=(uint8_t) (127.5 + 127.5 * (sqrt(3)/2*cos(i / 180.0 * 3.14159265358979323846) + 0.5 * sin(i / 180.0 * 3.14159265358979323846)));
    3c9c:	b8 01       	movw	r22, r16
    3c9e:	01 2e       	mov	r0, r17
    3ca0:	00 0c       	add	r0, r0
    3ca2:	88 0b       	sbc	r24, r24
    3ca4:	99 0b       	sbc	r25, r25
    3ca6:	0e 94 fd 22 	call	0x45fa	; 0x45fa <__floatsisf>
    3caa:	20 e0       	ldi	r18, 0x00	; 0
    3cac:	30 e0       	ldi	r19, 0x00	; 0
    3cae:	44 e3       	ldi	r20, 0x34	; 52
    3cb0:	53 e4       	ldi	r21, 0x43	; 67
    3cb2:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <__divsf3>
    3cb6:	2b ed       	ldi	r18, 0xDB	; 219
    3cb8:	3f e0       	ldi	r19, 0x0F	; 15
    3cba:	49 e4       	ldi	r20, 0x49	; 73
    3cbc:	50 e4       	ldi	r21, 0x40	; 64
    3cbe:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3cc2:	4b 01       	movw	r8, r22
    3cc4:	5c 01       	movw	r10, r24
    3cc6:	0e 94 55 22 	call	0x44aa	; 0x44aa <cos>
    3cca:	2b 01       	movw	r4, r22
    3ccc:	3c 01       	movw	r6, r24
    3cce:	c5 01       	movw	r24, r10
    3cd0:	b4 01       	movw	r22, r8
    3cd2:	0e 94 35 24 	call	0x486a	; 0x486a <sin>
    3cd6:	4b 01       	movw	r8, r22
    3cd8:	5c 01       	movw	r10, r24
    3cda:	27 ed       	ldi	r18, 0xD7	; 215
    3cdc:	33 eb       	ldi	r19, 0xB3	; 179
    3cde:	4d e5       	ldi	r20, 0x5D	; 93
    3ce0:	5f e3       	ldi	r21, 0x3F	; 63
    3ce2:	c3 01       	movw	r24, r6
    3ce4:	b2 01       	movw	r22, r4
    3ce6:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3cea:	2b 01       	movw	r4, r22
    3cec:	3c 01       	movw	r6, r24
    3cee:	20 e0       	ldi	r18, 0x00	; 0
    3cf0:	30 e0       	ldi	r19, 0x00	; 0
    3cf2:	40 e0       	ldi	r20, 0x00	; 0
    3cf4:	5f e3       	ldi	r21, 0x3F	; 63
    3cf6:	c5 01       	movw	r24, r10
    3cf8:	b4 01       	movw	r22, r8
    3cfa:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3cfe:	9b 01       	movw	r18, r22
    3d00:	ac 01       	movw	r20, r24
    3d02:	c3 01       	movw	r24, r6
    3d04:	b2 01       	movw	r22, r4
    3d06:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <__addsf3>
    3d0a:	20 e0       	ldi	r18, 0x00	; 0
    3d0c:	30 e0       	ldi	r19, 0x00	; 0
    3d0e:	4f ef       	ldi	r20, 0xFF	; 255
    3d10:	52 e4       	ldi	r21, 0x42	; 66
    3d12:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3d16:	20 e0       	ldi	r18, 0x00	; 0
    3d18:	30 e0       	ldi	r19, 0x00	; 0
    3d1a:	4f ef       	ldi	r20, 0xFF	; 255
    3d1c:	52 e4       	ldi	r21, 0x42	; 66
    3d1e:	0e 94 e9 21 	call	0x43d2	; 0x43d2 <__addsf3>
    3d22:	0e 94 cc 22 	call	0x4598	; 0x4598 <__fixunssfsi>
    3d26:	f6 01       	movw	r30, r12
    3d28:	61 93       	st	Z+, r22
    3d2a:	6f 01       	movw	r12, r30
			// The second half of the lookup table is for Phase B 0-60 degrees
			spacevec2_lut[i]=(uint8_t) (127.5 - 127.5 * (sin((2 * i + 120) / 180.0 * 3.14159265358979323846)));
    3d2c:	b7 01       	movw	r22, r14
    3d2e:	0f 2c       	mov	r0, r15
    3d30:	00 0c       	add	r0, r0
    3d32:	88 0b       	sbc	r24, r24
    3d34:	99 0b       	sbc	r25, r25
    3d36:	0e 94 fd 22 	call	0x45fa	; 0x45fa <__floatsisf>
    3d3a:	20 e0       	ldi	r18, 0x00	; 0
    3d3c:	30 e0       	ldi	r19, 0x00	; 0
    3d3e:	44 e3       	ldi	r20, 0x34	; 52
    3d40:	53 e4       	ldi	r21, 0x43	; 67
    3d42:	0e 94 5a 22 	call	0x44b4	; 0x44b4 <__divsf3>
    3d46:	2b ed       	ldi	r18, 0xDB	; 219
    3d48:	3f e0       	ldi	r19, 0x0F	; 15
    3d4a:	49 e4       	ldi	r20, 0x49	; 73
    3d4c:	50 e4       	ldi	r21, 0x40	; 64
    3d4e:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3d52:	0e 94 35 24 	call	0x486a	; 0x486a <sin>
    3d56:	20 e0       	ldi	r18, 0x00	; 0
    3d58:	30 e0       	ldi	r19, 0x00	; 0
    3d5a:	4f ef       	ldi	r20, 0xFF	; 255
    3d5c:	52 e4       	ldi	r21, 0x42	; 66
    3d5e:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    3d62:	9b 01       	movw	r18, r22
    3d64:	ac 01       	movw	r20, r24
    3d66:	60 e0       	ldi	r22, 0x00	; 0
    3d68:	70 e0       	ldi	r23, 0x00	; 0
    3d6a:	8f ef       	ldi	r24, 0xFF	; 255
    3d6c:	92 e4       	ldi	r25, 0x42	; 66
    3d6e:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <__subsf3>
    3d72:	0e 94 cc 22 	call	0x4598	; 0x4598 <__fixunssfsi>
    3d76:	f1 01       	movw	r30, r2
    3d78:	61 93       	st	Z+, r22
    3d7a:	1f 01       	movw	r2, r30
    3d7c:	0f 5f       	subi	r16, 0xFF	; 255
    3d7e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d80:	f2 e0       	ldi	r31, 0x02	; 2
    3d82:	ef 0e       	add	r14, r31
    3d84:	f1 1c       	adc	r15, r1
	}
		
	// Build space-vector lookup table parts 1 and 2
	{
		// 0 < theta < 60
		for(uint8_t i=0;i<=60;i++)
    3d86:	0d 33       	cpi	r16, 0x3D	; 61
    3d88:	11 05       	cpc	r17, r1
    3d8a:	09 f0       	breq	.+2      	; 0x3d8e <main+0x298>
    3d8c:	87 cf       	rjmp	.-242    	; 0x3c9c <main+0x1a6>
		}
	}
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3d8e:	0e 94 36 0d 	call	0x1a6c	; 0x1a6c <vTaskStartScheduler>
}
    3d92:	80 e0       	ldi	r24, 0x00	; 0
    3d94:	90 e0       	ldi	r25, 0x00	; 0
    3d96:	6d 96       	adiw	r28, 0x1d	; 29
    3d98:	cd bf       	out	0x3d, r28	; 61
    3d9a:	de bf       	out	0x3e, r29	; 62
    3d9c:	df 91       	pop	r29
    3d9e:	cf 91       	pop	r28
    3da0:	1f 91       	pop	r17
    3da2:	0f 91       	pop	r16
    3da4:	ff 90       	pop	r15
    3da6:	ef 90       	pop	r14
    3da8:	df 90       	pop	r13
    3daa:	cf 90       	pop	r12
    3dac:	bf 90       	pop	r11
    3dae:	af 90       	pop	r10
    3db0:	9f 90       	pop	r9
    3db2:	8f 90       	pop	r8
    3db4:	7f 90       	pop	r7
    3db6:	6f 90       	pop	r6
    3db8:	5f 90       	pop	r5
    3dba:	4f 90       	pop	r4
    3dbc:	3f 90       	pop	r3
    3dbe:	2f 90       	pop	r2
    3dc0:	08 95       	ret

00003dc2 <__vector_14>:


ISR(TCC0_OVF_vect)
{
    3dc2:	1f 92       	push	r1
    3dc4:	0f 92       	push	r0
    3dc6:	0f b6       	in	r0, 0x3f	; 63
    3dc8:	0f 92       	push	r0
    3dca:	11 24       	eor	r1, r1
    3dcc:	0b b6       	in	r0, 0x3b	; 59
    3dce:	0f 92       	push	r0
    3dd0:	0f 93       	push	r16
    3dd2:	1f 93       	push	r17
    3dd4:	2f 93       	push	r18
    3dd6:	3f 93       	push	r19
    3dd8:	4f 93       	push	r20
    3dda:	5f 93       	push	r21
    3ddc:	6f 93       	push	r22
    3dde:	7f 93       	push	r23
    3de0:	8f 93       	push	r24
    3de2:	9f 93       	push	r25
    3de4:	af 93       	push	r26
    3de6:	bf 93       	push	r27
    3de8:	cf 93       	push	r28
    3dea:	df 93       	push	r29
    3dec:	ef 93       	push	r30
    3dee:	ff 93       	push	r31
	//PORTC.OUT = PORTC.OUT ^ (1 << 3);
	PORTC.OUTTGL = 1 << 3;
    3df0:	88 e0       	ldi	r24, 0x08	; 8
    3df2:	80 93 47 06 	sts	0x0647, r24	; 0x800647 <__TEXT_REGION_LENGTH__+0x700647>
	
	// Increment the angle and make sure its still inside 360
	angle += delta_angle;
    3df6:	20 91 70 41 	lds	r18, 0x4170	; 0x804170 <angle>
    3dfa:	30 91 71 41 	lds	r19, 0x4171	; 0x804171 <angle+0x1>
    3dfe:	80 91 06 20 	lds	r24, 0x2006	; 0x802006 <delta_angle>
    3e02:	90 91 07 20 	lds	r25, 0x2007	; 0x802007 <delta_angle+0x1>
    3e06:	82 0f       	add	r24, r18
    3e08:	93 1f       	adc	r25, r19
    3e0a:	80 93 70 41 	sts	0x4170, r24	; 0x804170 <angle>
    3e0e:	90 93 71 41 	sts	0x4171, r25	; 0x804171 <angle+0x1>
	if(angle > 359)
    3e12:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3e16:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3e1a:	88 36       	cpi	r24, 0x68	; 104
    3e1c:	91 40       	sbci	r25, 0x01	; 1
    3e1e:	5c f0       	brlt	.+22     	; 0x3e36 <__vector_14+0x74>
	{
		angle -= 360;
    3e20:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3e24:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3e28:	88 56       	subi	r24, 0x68	; 104
    3e2a:	91 40       	sbci	r25, 0x01	; 1
    3e2c:	80 93 70 41 	sts	0x4170, r24	; 0x804170 <angle>
    3e30:	90 93 71 41 	sts	0x4171, r25	; 0x804171 <angle+0x1>
    3e34:	10 c0       	rjmp	.+32     	; 0x3e56 <__vector_14+0x94>
	}
	else if(angle < 0)
    3e36:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3e3a:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3e3e:	99 23       	and	r25, r25
    3e40:	54 f4       	brge	.+20     	; 0x3e56 <__vector_14+0x94>
	{
		angle += 360;
    3e42:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3e46:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3e4a:	88 59       	subi	r24, 0x98	; 152
    3e4c:	9e 4f       	sbci	r25, 0xFE	; 254
    3e4e:	80 93 70 41 	sts	0x4170, r24	; 0x804170 <angle>
    3e52:	90 93 71 41 	sts	0x4171, r25	; 0x804171 <angle+0x1>
	//     | Sec 1 | Sec 2 | Sec 3 | Sec 4 | Sec 5 | Sec 6 |
	// | A |  lut1 | -lut2 | -lut1 | -lut1 |  lut2 |  lut1 |
	// | B |  lut2 |  lut1 |  lut1 | -lut2 | -lut1 | -lut1 |
	// | C | -lut1 | -lut1 |  lut2 |  lut1 |  lut1 | -lut2 |
	//			 ABC - ABC
	if (angle < 60)			// Sector 1: 100 - 110
    3e56:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3e5a:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3e5e:	cc 97       	sbiw	r24, 0x3c	; 60
    3e60:	0c f0       	brlt	.+2      	; 0x3e64 <__vector_14+0xa2>
    3e62:	4c c0       	rjmp	.+152    	; 0x3efc <__vector_14+0x13a>

		// Sector 1
		// A <= lut1
		// B <= lut2
		// C <= -lut1
		A_duty = (0   + (uint16_t) spacevec1_lut[angle])*((uint16_t) effort)/255;
    3e64:	e0 91 70 41 	lds	r30, 0x4170	; 0x804170 <angle>
    3e68:	f0 91 71 41 	lds	r31, 0x4171	; 0x804171 <angle+0x1>
    3e6c:	40 91 08 20 	lds	r20, 0x2008	; 0x802008 <effort>
    3e70:	50 91 09 20 	lds	r21, 0x2009	; 0x802009 <effort+0x1>
    3e74:	e1 55       	subi	r30, 0x51	; 81
    3e76:	fe 4b       	sbci	r31, 0xBE	; 190
    3e78:	80 81       	ld	r24, Z
    3e7a:	84 9f       	mul	r24, r20
    3e7c:	90 01       	movw	r18, r0
    3e7e:	85 9f       	mul	r24, r21
    3e80:	30 0d       	add	r19, r0
    3e82:	11 24       	eor	r1, r1
    3e84:	a1 e8       	ldi	r26, 0x81	; 129
    3e86:	b0 e8       	ldi	r27, 0x80	; 128
    3e88:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3e8c:	fc 01       	movw	r30, r24
    3e8e:	ee 0f       	add	r30, r30
    3e90:	ef 2f       	mov	r30, r31
    3e92:	ee 1f       	adc	r30, r30
    3e94:	ff 0b       	sbc	r31, r31
    3e96:	f1 95       	neg	r31
		B_duty = (0   + (uint16_t) spacevec2_lut[angle])*((uint16_t) effort)/255;
    3e98:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    3e9c:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    3ea0:	ae 58       	subi	r26, 0x8E	; 142
    3ea2:	be 4b       	sbci	r27, 0xBE	; 190
    3ea4:	8c 91       	ld	r24, X
    3ea6:	84 9f       	mul	r24, r20
    3ea8:	90 01       	movw	r18, r0
    3eaa:	85 9f       	mul	r24, r21
    3eac:	30 0d       	add	r19, r0
    3eae:	11 24       	eor	r1, r1
    3eb0:	a1 e8       	ldi	r26, 0x81	; 129
    3eb2:	b0 e8       	ldi	r27, 0x80	; 128
    3eb4:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3eb8:	ec 01       	movw	r28, r24
    3eba:	cc 0f       	add	r28, r28
    3ebc:	cd 2f       	mov	r28, r29
    3ebe:	cc 1f       	adc	r28, r28
    3ec0:	dd 0b       	sbc	r29, r29
    3ec2:	d1 95       	neg	r29
		C_duty = (255 - (uint16_t) spacevec1_lut[angle])*((uint16_t) effort)/255;
    3ec4:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    3ec8:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    3ecc:	a1 55       	subi	r26, 0x51	; 81
    3ece:	be 4b       	sbci	r27, 0xBE	; 190
    3ed0:	2c 91       	ld	r18, X
    3ed2:	8f ef       	ldi	r24, 0xFF	; 255
    3ed4:	90 e0       	ldi	r25, 0x00	; 0
    3ed6:	82 1b       	sub	r24, r18
    3ed8:	91 09       	sbc	r25, r1
    3eda:	84 9f       	mul	r24, r20
    3edc:	90 01       	movw	r18, r0
    3ede:	85 9f       	mul	r24, r21
    3ee0:	30 0d       	add	r19, r0
    3ee2:	94 9f       	mul	r25, r20
    3ee4:	30 0d       	add	r19, r0
    3ee6:	11 24       	eor	r1, r1
    3ee8:	a1 e8       	ldi	r26, 0x81	; 129
    3eea:	b0 e8       	ldi	r27, 0x80	; 128
    3eec:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3ef0:	88 0f       	add	r24, r24
    3ef2:	89 2f       	mov	r24, r25
    3ef4:	88 1f       	adc	r24, r24
    3ef6:	99 0b       	sbc	r25, r25
    3ef8:	91 95       	neg	r25
    3efa:	bc c1       	rjmp	.+888    	; 0x4274 <__vector_14+0x4b2>
	}
	else if (angle < 120)	// Sector 2: 110 - 010
    3efc:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3f00:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3f04:	88 37       	cpi	r24, 0x78	; 120
    3f06:	91 05       	cpc	r25, r1
    3f08:	0c f0       	brlt	.+2      	; 0x3f0c <__vector_14+0x14a>
    3f0a:	52 c0       	rjmp	.+164    	; 0x3fb0 <__vector_14+0x1ee>
				
		// Sector 2
		// A <= -lut2
		// B <= lut1
		// C <= -lut1
		A_duty = (255 - (uint16_t) spacevec2_lut[angle-60])*((uint16_t) effort)/255;
    3f0c:	e0 91 70 41 	lds	r30, 0x4170	; 0x804170 <angle>
    3f10:	f0 91 71 41 	lds	r31, 0x4171	; 0x804171 <angle+0x1>
    3f14:	00 91 08 20 	lds	r16, 0x2008	; 0x802008 <effort>
    3f18:	10 91 09 20 	lds	r17, 0x2009	; 0x802009 <effort+0x1>
    3f1c:	ea 5c       	subi	r30, 0xCA	; 202
    3f1e:	fe 4b       	sbci	r31, 0xBE	; 190
    3f20:	80 81       	ld	r24, Z
    3f22:	4f ef       	ldi	r20, 0xFF	; 255
    3f24:	50 e0       	ldi	r21, 0x00	; 0
    3f26:	9a 01       	movw	r18, r20
    3f28:	28 1b       	sub	r18, r24
    3f2a:	31 09       	sbc	r19, r1
    3f2c:	c9 01       	movw	r24, r18
    3f2e:	80 9f       	mul	r24, r16
    3f30:	90 01       	movw	r18, r0
    3f32:	81 9f       	mul	r24, r17
    3f34:	30 0d       	add	r19, r0
    3f36:	90 9f       	mul	r25, r16
    3f38:	30 0d       	add	r19, r0
    3f3a:	11 24       	eor	r1, r1
    3f3c:	a1 e8       	ldi	r26, 0x81	; 129
    3f3e:	b0 e8       	ldi	r27, 0x80	; 128
    3f40:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3f44:	fc 01       	movw	r30, r24
    3f46:	ee 0f       	add	r30, r30
    3f48:	ef 2f       	mov	r30, r31
    3f4a:	ee 1f       	adc	r30, r30
    3f4c:	ff 0b       	sbc	r31, r31
    3f4e:	f1 95       	neg	r31
		B_duty = (0   + (uint16_t) spacevec1_lut[angle-60])*((uint16_t) effort)/255;
    3f50:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    3f54:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    3f58:	ad 58       	subi	r26, 0x8D	; 141
    3f5a:	be 4b       	sbci	r27, 0xBE	; 190
    3f5c:	8c 91       	ld	r24, X
    3f5e:	80 9f       	mul	r24, r16
    3f60:	90 01       	movw	r18, r0
    3f62:	81 9f       	mul	r24, r17
    3f64:	30 0d       	add	r19, r0
    3f66:	11 24       	eor	r1, r1
    3f68:	a1 e8       	ldi	r26, 0x81	; 129
    3f6a:	b0 e8       	ldi	r27, 0x80	; 128
    3f6c:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3f70:	ec 01       	movw	r28, r24
    3f72:	cc 0f       	add	r28, r28
    3f74:	cd 2f       	mov	r28, r29
    3f76:	cc 1f       	adc	r28, r28
    3f78:	dd 0b       	sbc	r29, r29
    3f7a:	d1 95       	neg	r29
		C_duty = (255 - (uint16_t) spacevec1_lut[angle-60])*((uint16_t) effort)/255;
    3f7c:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    3f80:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    3f84:	ad 58       	subi	r26, 0x8D	; 141
    3f86:	be 4b       	sbci	r27, 0xBE	; 190
    3f88:	8c 91       	ld	r24, X
    3f8a:	48 1b       	sub	r20, r24
    3f8c:	51 09       	sbc	r21, r1
    3f8e:	40 9f       	mul	r20, r16
    3f90:	90 01       	movw	r18, r0
    3f92:	41 9f       	mul	r20, r17
    3f94:	30 0d       	add	r19, r0
    3f96:	50 9f       	mul	r21, r16
    3f98:	30 0d       	add	r19, r0
    3f9a:	11 24       	eor	r1, r1
    3f9c:	a1 e8       	ldi	r26, 0x81	; 129
    3f9e:	b0 e8       	ldi	r27, 0x80	; 128
    3fa0:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3fa4:	88 0f       	add	r24, r24
    3fa6:	89 2f       	mov	r24, r25
    3fa8:	88 1f       	adc	r24, r24
    3faa:	99 0b       	sbc	r25, r25
    3fac:	91 95       	neg	r25
    3fae:	62 c1       	rjmp	.+708    	; 0x4274 <__vector_14+0x4b2>
	}
	else if (angle < 180)	// Sector 3: 010 - 011
    3fb0:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    3fb4:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    3fb8:	84 3b       	cpi	r24, 0xB4	; 180
    3fba:	91 05       	cpc	r25, r1
    3fbc:	0c f0       	brlt	.+2      	; 0x3fc0 <__vector_14+0x1fe>
    3fbe:	4c c0       	rjmp	.+152    	; 0x4058 <__vector_14+0x296>
				
		// Sector 3
		// A <= -lut1
		// B <= lut1
		// C <= lut2
		A_duty = (255 - (uint16_t) spacevec1_lut[angle-120])*((uint16_t) effort)/255;
    3fc0:	e0 91 70 41 	lds	r30, 0x4170	; 0x804170 <angle>
    3fc4:	f0 91 71 41 	lds	r31, 0x4171	; 0x804171 <angle+0x1>
    3fc8:	40 91 08 20 	lds	r20, 0x2008	; 0x802008 <effort>
    3fcc:	50 91 09 20 	lds	r21, 0x2009	; 0x802009 <effort+0x1>
    3fd0:	e9 5c       	subi	r30, 0xC9	; 201
    3fd2:	fe 4b       	sbci	r31, 0xBE	; 190
    3fd4:	20 81       	ld	r18, Z
    3fd6:	8f ef       	ldi	r24, 0xFF	; 255
    3fd8:	90 e0       	ldi	r25, 0x00	; 0
    3fda:	82 1b       	sub	r24, r18
    3fdc:	91 09       	sbc	r25, r1
    3fde:	84 9f       	mul	r24, r20
    3fe0:	90 01       	movw	r18, r0
    3fe2:	85 9f       	mul	r24, r21
    3fe4:	30 0d       	add	r19, r0
    3fe6:	94 9f       	mul	r25, r20
    3fe8:	30 0d       	add	r19, r0
    3fea:	11 24       	eor	r1, r1
    3fec:	a1 e8       	ldi	r26, 0x81	; 129
    3fee:	b0 e8       	ldi	r27, 0x80	; 128
    3ff0:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    3ff4:	fc 01       	movw	r30, r24
    3ff6:	ee 0f       	add	r30, r30
    3ff8:	ef 2f       	mov	r30, r31
    3ffa:	ee 1f       	adc	r30, r30
    3ffc:	ff 0b       	sbc	r31, r31
    3ffe:	f1 95       	neg	r31
		B_duty = (0   + (uint16_t) spacevec1_lut[angle-120])*((uint16_t) effort)/255;
    4000:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    4004:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    4008:	a9 5c       	subi	r26, 0xC9	; 201
    400a:	be 4b       	sbci	r27, 0xBE	; 190
    400c:	8c 91       	ld	r24, X
    400e:	84 9f       	mul	r24, r20
    4010:	90 01       	movw	r18, r0
    4012:	85 9f       	mul	r24, r21
    4014:	30 0d       	add	r19, r0
    4016:	11 24       	eor	r1, r1
    4018:	a1 e8       	ldi	r26, 0x81	; 129
    401a:	b0 e8       	ldi	r27, 0x80	; 128
    401c:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    4020:	ec 01       	movw	r28, r24
    4022:	cc 0f       	add	r28, r28
    4024:	cd 2f       	mov	r28, r29
    4026:	cc 1f       	adc	r28, r28
    4028:	dd 0b       	sbc	r29, r29
    402a:	d1 95       	neg	r29
		C_duty = (0   + (uint16_t) spacevec2_lut[angle-120])*((uint16_t) effort)/255;
    402c:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    4030:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    4034:	a6 50       	subi	r26, 0x06	; 6
    4036:	bf 4b       	sbci	r27, 0xBF	; 191
    4038:	8c 91       	ld	r24, X
    403a:	84 9f       	mul	r24, r20
    403c:	90 01       	movw	r18, r0
    403e:	85 9f       	mul	r24, r21
    4040:	30 0d       	add	r19, r0
    4042:	11 24       	eor	r1, r1
    4044:	a1 e8       	ldi	r26, 0x81	; 129
    4046:	b0 e8       	ldi	r27, 0x80	; 128
    4048:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    404c:	88 0f       	add	r24, r24
    404e:	89 2f       	mov	r24, r25
    4050:	88 1f       	adc	r24, r24
    4052:	99 0b       	sbc	r25, r25
    4054:	91 95       	neg	r25
    4056:	0e c1       	rjmp	.+540    	; 0x4274 <__vector_14+0x4b2>
	}
	else if (angle < 240)	// Sector 4: 011 - 001
    4058:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    405c:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    4060:	80 3f       	cpi	r24, 0xF0	; 240
    4062:	91 05       	cpc	r25, r1
    4064:	0c f0       	brlt	.+2      	; 0x4068 <__vector_14+0x2a6>
    4066:	52 c0       	rjmp	.+164    	; 0x410c <__vector_14+0x34a>
				
		// Sector 4
		// A <= -lut1
		// B <= -lut2
		// C <= lut1
		A_duty = (255 - (uint16_t) spacevec1_lut[angle-180])*((uint16_t) effort)/255;
    4068:	e0 91 70 41 	lds	r30, 0x4170	; 0x804170 <angle>
    406c:	f0 91 71 41 	lds	r31, 0x4171	; 0x804171 <angle+0x1>
    4070:	00 91 08 20 	lds	r16, 0x2008	; 0x802008 <effort>
    4074:	10 91 09 20 	lds	r17, 0x2009	; 0x802009 <effort+0x1>
    4078:	e5 50       	subi	r30, 0x05	; 5
    407a:	ff 4b       	sbci	r31, 0xBF	; 191
    407c:	80 81       	ld	r24, Z
    407e:	4f ef       	ldi	r20, 0xFF	; 255
    4080:	50 e0       	ldi	r21, 0x00	; 0
    4082:	9a 01       	movw	r18, r20
    4084:	28 1b       	sub	r18, r24
    4086:	31 09       	sbc	r19, r1
    4088:	c9 01       	movw	r24, r18
    408a:	80 9f       	mul	r24, r16
    408c:	90 01       	movw	r18, r0
    408e:	81 9f       	mul	r24, r17
    4090:	30 0d       	add	r19, r0
    4092:	90 9f       	mul	r25, r16
    4094:	30 0d       	add	r19, r0
    4096:	11 24       	eor	r1, r1
    4098:	a1 e8       	ldi	r26, 0x81	; 129
    409a:	b0 e8       	ldi	r27, 0x80	; 128
    409c:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    40a0:	fc 01       	movw	r30, r24
    40a2:	ee 0f       	add	r30, r30
    40a4:	ef 2f       	mov	r30, r31
    40a6:	ee 1f       	adc	r30, r30
    40a8:	ff 0b       	sbc	r31, r31
    40aa:	f1 95       	neg	r31
		B_duty = (255 - (uint16_t) spacevec2_lut[angle-180])*((uint16_t) effort)/255;
    40ac:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    40b0:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    40b4:	a2 54       	subi	r26, 0x42	; 66
    40b6:	bf 4b       	sbci	r27, 0xBF	; 191
    40b8:	8c 91       	ld	r24, X
    40ba:	48 1b       	sub	r20, r24
    40bc:	51 09       	sbc	r21, r1
    40be:	40 9f       	mul	r20, r16
    40c0:	90 01       	movw	r18, r0
    40c2:	41 9f       	mul	r20, r17
    40c4:	30 0d       	add	r19, r0
    40c6:	50 9f       	mul	r21, r16
    40c8:	30 0d       	add	r19, r0
    40ca:	11 24       	eor	r1, r1
    40cc:	a1 e8       	ldi	r26, 0x81	; 129
    40ce:	b0 e8       	ldi	r27, 0x80	; 128
    40d0:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    40d4:	ec 01       	movw	r28, r24
    40d6:	cc 0f       	add	r28, r28
    40d8:	cd 2f       	mov	r28, r29
    40da:	cc 1f       	adc	r28, r28
    40dc:	dd 0b       	sbc	r29, r29
    40de:	d1 95       	neg	r29
		C_duty = (0   + (uint16_t) spacevec1_lut[angle-180])*((uint16_t) effort)/255;
    40e0:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    40e4:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    40e8:	a5 50       	subi	r26, 0x05	; 5
    40ea:	bf 4b       	sbci	r27, 0xBF	; 191
    40ec:	8c 91       	ld	r24, X
    40ee:	80 9f       	mul	r24, r16
    40f0:	90 01       	movw	r18, r0
    40f2:	81 9f       	mul	r24, r17
    40f4:	30 0d       	add	r19, r0
    40f6:	11 24       	eor	r1, r1
    40f8:	a1 e8       	ldi	r26, 0x81	; 129
    40fa:	b0 e8       	ldi	r27, 0x80	; 128
    40fc:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    4100:	88 0f       	add	r24, r24
    4102:	89 2f       	mov	r24, r25
    4104:	88 1f       	adc	r24, r24
    4106:	99 0b       	sbc	r25, r25
    4108:	91 95       	neg	r25
    410a:	b4 c0       	rjmp	.+360    	; 0x4274 <__vector_14+0x4b2>
	}
	else if (angle < 300)	// Sector 5: 001 - 101
    410c:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    4110:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    4114:	8c 32       	cpi	r24, 0x2C	; 44
    4116:	91 40       	sbci	r25, 0x01	; 1
    4118:	0c f0       	brlt	.+2      	; 0x411c <__vector_14+0x35a>
    411a:	4c c0       	rjmp	.+152    	; 0x41b4 <__vector_14+0x3f2>
				
		// Sector 5
		// A <= lut2
		// B <= -lut1
		// C <= lut1
		A_duty = (0   + (uint16_t) spacevec2_lut[angle-240])*((uint16_t) effort)/255;
    411c:	e0 91 70 41 	lds	r30, 0x4170	; 0x804170 <angle>
    4120:	f0 91 71 41 	lds	r31, 0x4171	; 0x804171 <angle+0x1>
    4124:	40 91 08 20 	lds	r20, 0x2008	; 0x802008 <effort>
    4128:	50 91 09 20 	lds	r21, 0x2009	; 0x802009 <effort+0x1>
    412c:	ee 57       	subi	r30, 0x7E	; 126
    412e:	ff 4b       	sbci	r31, 0xBF	; 191
    4130:	80 81       	ld	r24, Z
    4132:	84 9f       	mul	r24, r20
    4134:	90 01       	movw	r18, r0
    4136:	85 9f       	mul	r24, r21
    4138:	30 0d       	add	r19, r0
    413a:	11 24       	eor	r1, r1
    413c:	a1 e8       	ldi	r26, 0x81	; 129
    413e:	b0 e8       	ldi	r27, 0x80	; 128
    4140:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    4144:	fc 01       	movw	r30, r24
    4146:	ee 0f       	add	r30, r30
    4148:	ef 2f       	mov	r30, r31
    414a:	ee 1f       	adc	r30, r30
    414c:	ff 0b       	sbc	r31, r31
    414e:	f1 95       	neg	r31
		B_duty = (255 - (uint16_t) spacevec1_lut[angle-240])*((uint16_t) effort)/255;
    4150:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    4154:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    4158:	a1 54       	subi	r26, 0x41	; 65
    415a:	bf 4b       	sbci	r27, 0xBF	; 191
    415c:	2c 91       	ld	r18, X
    415e:	8f ef       	ldi	r24, 0xFF	; 255
    4160:	90 e0       	ldi	r25, 0x00	; 0
    4162:	82 1b       	sub	r24, r18
    4164:	91 09       	sbc	r25, r1
    4166:	84 9f       	mul	r24, r20
    4168:	90 01       	movw	r18, r0
    416a:	85 9f       	mul	r24, r21
    416c:	30 0d       	add	r19, r0
    416e:	94 9f       	mul	r25, r20
    4170:	30 0d       	add	r19, r0
    4172:	11 24       	eor	r1, r1
    4174:	a1 e8       	ldi	r26, 0x81	; 129
    4176:	b0 e8       	ldi	r27, 0x80	; 128
    4178:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    417c:	ec 01       	movw	r28, r24
    417e:	cc 0f       	add	r28, r28
    4180:	cd 2f       	mov	r28, r29
    4182:	cc 1f       	adc	r28, r28
    4184:	dd 0b       	sbc	r29, r29
    4186:	d1 95       	neg	r29
		C_duty = (0   + (uint16_t) spacevec1_lut[angle-240])*((uint16_t) effort)/255;
    4188:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    418c:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    4190:	a1 54       	subi	r26, 0x41	; 65
    4192:	bf 4b       	sbci	r27, 0xBF	; 191
    4194:	8c 91       	ld	r24, X
    4196:	84 9f       	mul	r24, r20
    4198:	90 01       	movw	r18, r0
    419a:	85 9f       	mul	r24, r21
    419c:	30 0d       	add	r19, r0
    419e:	11 24       	eor	r1, r1
    41a0:	a1 e8       	ldi	r26, 0x81	; 129
    41a2:	b0 e8       	ldi	r27, 0x80	; 128
    41a4:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    41a8:	88 0f       	add	r24, r24
    41aa:	89 2f       	mov	r24, r25
    41ac:	88 1f       	adc	r24, r24
    41ae:	99 0b       	sbc	r25, r25
    41b0:	91 95       	neg	r25
    41b2:	60 c0       	rjmp	.+192    	; 0x4274 <__vector_14+0x4b2>
	}
	else if (angle < 360)	// Sector 6: 101 - 100
    41b4:	80 91 70 41 	lds	r24, 0x4170	; 0x804170 <angle>
    41b8:	90 91 71 41 	lds	r25, 0x4171	; 0x804171 <angle+0x1>
    41bc:	88 36       	cpi	r24, 0x68	; 104
    41be:	91 40       	sbci	r25, 0x01	; 1
    41c0:	0c f0       	brlt	.+2      	; 0x41c4 <__vector_14+0x402>
    41c2:	52 c0       	rjmp	.+164    	; 0x4268 <__vector_14+0x4a6>
				
		// Sector 6
		// A <= lut1
		// B <= -lut1
		// C <= -lut2
		A_duty = (0   + (uint16_t) spacevec1_lut[angle-300])*((uint16_t) effort)/255;
    41c4:	e0 91 70 41 	lds	r30, 0x4170	; 0x804170 <angle>
    41c8:	f0 91 71 41 	lds	r31, 0x4171	; 0x804171 <angle+0x1>
    41cc:	00 91 08 20 	lds	r16, 0x2008	; 0x802008 <effort>
    41d0:	10 91 09 20 	lds	r17, 0x2009	; 0x802009 <effort+0x1>
    41d4:	ed 57       	subi	r30, 0x7D	; 125
    41d6:	ff 4b       	sbci	r31, 0xBF	; 191
    41d8:	80 81       	ld	r24, Z
    41da:	80 9f       	mul	r24, r16
    41dc:	90 01       	movw	r18, r0
    41de:	81 9f       	mul	r24, r17
    41e0:	30 0d       	add	r19, r0
    41e2:	11 24       	eor	r1, r1
    41e4:	a1 e8       	ldi	r26, 0x81	; 129
    41e6:	b0 e8       	ldi	r27, 0x80	; 128
    41e8:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    41ec:	fc 01       	movw	r30, r24
    41ee:	ee 0f       	add	r30, r30
    41f0:	ef 2f       	mov	r30, r31
    41f2:	ee 1f       	adc	r30, r30
    41f4:	ff 0b       	sbc	r31, r31
    41f6:	f1 95       	neg	r31
		B_duty = (255 - (uint16_t) spacevec1_lut[angle-300])*((uint16_t) effort)/255;
    41f8:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    41fc:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    4200:	ad 57       	subi	r26, 0x7D	; 125
    4202:	bf 4b       	sbci	r27, 0xBF	; 191
    4204:	8c 91       	ld	r24, X
    4206:	4f ef       	ldi	r20, 0xFF	; 255
    4208:	50 e0       	ldi	r21, 0x00	; 0
    420a:	9a 01       	movw	r18, r20
    420c:	28 1b       	sub	r18, r24
    420e:	31 09       	sbc	r19, r1
    4210:	c9 01       	movw	r24, r18
    4212:	80 9f       	mul	r24, r16
    4214:	90 01       	movw	r18, r0
    4216:	81 9f       	mul	r24, r17
    4218:	30 0d       	add	r19, r0
    421a:	90 9f       	mul	r25, r16
    421c:	30 0d       	add	r19, r0
    421e:	11 24       	eor	r1, r1
    4220:	a1 e8       	ldi	r26, 0x81	; 129
    4222:	b0 e8       	ldi	r27, 0x80	; 128
    4224:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    4228:	ec 01       	movw	r28, r24
    422a:	cc 0f       	add	r28, r28
    422c:	cd 2f       	mov	r28, r29
    422e:	cc 1f       	adc	r28, r28
    4230:	dd 0b       	sbc	r29, r29
    4232:	d1 95       	neg	r29
		C_duty = (255 - (uint16_t) spacevec2_lut[angle-300])*((uint16_t) effort)/255;
    4234:	a0 91 70 41 	lds	r26, 0x4170	; 0x804170 <angle>
    4238:	b0 91 71 41 	lds	r27, 0x4171	; 0x804171 <angle+0x1>
    423c:	aa 5b       	subi	r26, 0xBA	; 186
    423e:	bf 4b       	sbci	r27, 0xBF	; 191
    4240:	8c 91       	ld	r24, X
    4242:	48 1b       	sub	r20, r24
    4244:	51 09       	sbc	r21, r1
    4246:	40 9f       	mul	r20, r16
    4248:	90 01       	movw	r18, r0
    424a:	41 9f       	mul	r20, r17
    424c:	30 0d       	add	r19, r0
    424e:	50 9f       	mul	r21, r16
    4250:	30 0d       	add	r19, r0
    4252:	11 24       	eor	r1, r1
    4254:	a1 e8       	ldi	r26, 0x81	; 129
    4256:	b0 e8       	ldi	r27, 0x80	; 128
    4258:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    425c:	88 0f       	add	r24, r24
    425e:	89 2f       	mov	r24, r25
    4260:	88 1f       	adc	r24, r24
    4262:	99 0b       	sbc	r25, r25
    4264:	91 95       	neg	r25
    4266:	06 c0       	rjmp	.+12     	; 0x4274 <__vector_14+0x4b2>
	}
	else					// Invalid sector
	{
		A_duty = 0;
		B_duty = 0;
		C_duty = 0;
    4268:	80 e0       	ldi	r24, 0x00	; 0
    426a:	90 e0       	ldi	r25, 0x00	; 0
		C_duty = (255 - (uint16_t) spacevec2_lut[angle-300])*((uint16_t) effort)/255;
	}
	else					// Invalid sector
	{
		A_duty = 0;
		B_duty = 0;
    426c:	c0 e0       	ldi	r28, 0x00	; 0
    426e:	d0 e0       	ldi	r29, 0x00	; 0
		B_duty = (255 - (uint16_t) spacevec1_lut[angle-300])*((uint16_t) effort)/255;
		C_duty = (255 - (uint16_t) spacevec2_lut[angle-300])*((uint16_t) effort)/255;
	}
	else					// Invalid sector
	{
		A_duty = 0;
    4270:	e0 e0       	ldi	r30, 0x00	; 0
    4272:	f0 e0       	ldi	r31, 0x00	; 0
		C_duty = 0;
	}
			
	// Offset duty cycles so that the p-p effort value is centered at 127 (50%) effort
	// This allows equal "all-on" and "all-off" time in the center aligned-pwm scheme
	A_duty += (255 - (uint8_t) (effort))/2;
    4274:	40 91 08 20 	lds	r20, 0x2008	; 0x802008 <effort>
    4278:	50 91 09 20 	lds	r21, 0x2009	; 0x802009 <effort+0x1>
    427c:	40 95       	com	r20
    427e:	50 95       	com	r21
    4280:	55 27       	eor	r21, r21
    4282:	9a 01       	movw	r18, r20
    4284:	35 95       	asr	r19
    4286:	27 95       	ror	r18

	//PORTC.OUT &= ~(1 << 3);


	// Set PWM duty cycles based on results
	TCC0.CCABUF = A_duty;
    4288:	af 01       	movw	r20, r30
    428a:	42 0f       	add	r20, r18
    428c:	53 1f       	adc	r21, r19
    428e:	e0 e0       	ldi	r30, 0x00	; 0
    4290:	f8 e0       	ldi	r31, 0x08	; 8
    4292:	40 af       	std	Z+56, r20	; 0x38
    4294:	51 af       	std	Z+57, r21	; 0x39
	TCC0.CCBBUF = B_duty;
    4296:	ae 01       	movw	r20, r28
    4298:	42 0f       	add	r20, r18
    429a:	53 1f       	adc	r21, r19
    429c:	42 af       	std	Z+58, r20	; 0x3a
    429e:	53 af       	std	Z+59, r21	; 0x3b
	TCC0.CCCBUF = C_duty;
    42a0:	28 0f       	add	r18, r24
    42a2:	39 1f       	adc	r19, r25
    42a4:	24 af       	std	Z+60, r18	; 0x3c
    42a6:	35 af       	std	Z+61, r19	; 0x3d
    42a8:	ff 91       	pop	r31
    42aa:	ef 91       	pop	r30
    42ac:	df 91       	pop	r29
    42ae:	cf 91       	pop	r28
    42b0:	bf 91       	pop	r27
    42b2:	af 91       	pop	r26
    42b4:	9f 91       	pop	r25
    42b6:	8f 91       	pop	r24
    42b8:	7f 91       	pop	r23
    42ba:	6f 91       	pop	r22
    42bc:	5f 91       	pop	r21
    42be:	4f 91       	pop	r20
    42c0:	3f 91       	pop	r19
    42c2:	2f 91       	pop	r18
    42c4:	1f 91       	pop	r17
    42c6:	0f 91       	pop	r16
    42c8:	0f 90       	pop	r0
    42ca:	0b be       	out	0x3b, r0	; 59
    42cc:	0f 90       	pop	r0
    42ce:	0f be       	out	0x3f, r0	; 63
    42d0:	0f 90       	pop	r0
    42d2:	1f 90       	pop	r1
    42d4:	18 95       	reti

000042d6 <_GLOBAL__sub_I_counter>:
    42d6:	cf 92       	push	r12
    42d8:	df 92       	push	r13
    42da:	ef 92       	push	r14
    42dc:	ff 92       	push	r15
    42de:	0f 93       	push	r16
    42e0:	1f 93       	push	r17
    42e2:	cf 93       	push	r28
    42e4:	df 93       	push	r29

#include "task_user.h"                      // Header for user interface task
#include "task_LED.h"                      // Header for user interface task

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    42e6:	0a e0       	ldi	r16, 0x0A	; 10
    42e8:	10 e0       	ldi	r17, 0x00	; 0
    42ea:	20 e0       	ldi	r18, 0x00	; 0
    42ec:	30 e0       	ldi	r19, 0x00	; 0
    42ee:	40 e0       	ldi	r20, 0x00	; 0
    42f0:	50 e0       	ldi	r21, 0x00	; 0
    42f2:	60 e2       	ldi	r22, 0x20	; 32
    42f4:	70 e0       	ldi	r23, 0x00	; 0
    42f6:	8b e5       	ldi	r24, 0x5B	; 91
    42f8:	92 e4       	ldi	r25, 0x42	; 66
    42fa:	0e 94 90 14 	call	0x2920	; 0x2920 <_ZN14frt_text_queueC1EjP8emstreamm>

template <class data_type>
frt_base_queue<data_type>::frt_base_queue (emstream* p_ser_dev)
{
	// Save the pointer to a serial devide so it may be used for debugging
	p_serial = p_ser_dev;
    42fe:	c1 e5       	ldi	r28, 0x51	; 81
    4300:	d2 e4       	ldi	r29, 0x42	; 66
    4302:	1a 82       	std	Y+2, r1	; 0x02
    4304:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4306:	8b e9       	ldi	r24, 0x9B	; 155
    4308:	90 e2       	ldi	r25, 0x20	; 32
    430a:	88 83       	st	Y, r24
    430c:	99 83       	std	Y+1, r25	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    430e:	40 e0       	ldi	r20, 0x00	; 0
    4310:	62 e0       	ldi	r22, 0x02	; 2
    4312:	8f ef       	ldi	r24, 0xFF	; 255
    4314:	0e 94 df 09 	call	0x13be	; 0x13be <xQueueGenericCreate>
    4318:	8c 83       	std	Y+4, r24	; 0x04
    431a:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    431c:	0f 2e       	mov	r0, r31
    431e:	fa e0       	ldi	r31, 0x0A	; 10
    4320:	cf 2e       	mov	r12, r31
    4322:	d1 2c       	mov	r13, r1
    4324:	e1 2c       	mov	r14, r1
    4326:	f1 2c       	mov	r15, r1
    4328:	f0 2d       	mov	r31, r0
    432a:	ce 82       	std	Y+6, r12	; 0x06
    432c:	df 82       	std	Y+7, r13	; 0x07
    432e:	e8 86       	std	Y+8, r14	; 0x08
    4330:	f9 86       	std	Y+9, r15	; 0x09
    4332:	c7 e4       	ldi	r28, 0x47	; 71
    4334:	d2 e4       	ldi	r29, 0x42	; 66
    4336:	1a 82       	std	Y+2, r1	; 0x02
    4338:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    433a:	0f eb       	ldi	r16, 0xBF	; 191
    433c:	10 e2       	ldi	r17, 0x20	; 32
    433e:	08 83       	st	Y, r16
    4340:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4342:	40 e0       	ldi	r20, 0x00	; 0
    4344:	62 e0       	ldi	r22, 0x02	; 2
    4346:	8f ef       	ldi	r24, 0xFF	; 255
    4348:	0e 94 df 09 	call	0x13be	; 0x13be <xQueueGenericCreate>
    434c:	8c 83       	std	Y+4, r24	; 0x04
    434e:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4350:	ce 82       	std	Y+6, r12	; 0x06
    4352:	df 82       	std	Y+7, r13	; 0x07
    4354:	e8 86       	std	Y+8, r14	; 0x08
    4356:	f9 86       	std	Y+9, r15	; 0x09
    4358:	cd e3       	ldi	r28, 0x3D	; 61
    435a:	d2 e4       	ldi	r29, 0x42	; 66
    435c:	1a 82       	std	Y+2, r1	; 0x02
    435e:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4360:	08 83       	st	Y, r16
    4362:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4364:	40 e0       	ldi	r20, 0x00	; 0
    4366:	62 e0       	ldi	r22, 0x02	; 2
    4368:	8f ef       	ldi	r24, 0xFF	; 255
    436a:	0e 94 df 09 	call	0x13be	; 0x13be <xQueueGenericCreate>
    436e:	8c 83       	std	Y+4, r24	; 0x04
    4370:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4372:	ce 82       	std	Y+6, r12	; 0x06
    4374:	df 82       	std	Y+7, r13	; 0x07
    4376:	e8 86       	std	Y+8, r14	; 0x08
    4378:	f9 86       	std	Y+9, r15	; 0x09
    437a:	c3 e3       	ldi	r28, 0x33	; 51
    437c:	d2 e4       	ldi	r29, 0x42	; 66
    437e:	1a 82       	std	Y+2, r1	; 0x02
    4380:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    4382:	08 83       	st	Y, r16
    4384:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    4386:	40 e0       	ldi	r20, 0x00	; 0
    4388:	62 e0       	ldi	r22, 0x02	; 2
    438a:	8f ef       	ldi	r24, 0xFF	; 255
    438c:	0e 94 df 09 	call	0x13be	; 0x13be <xQueueGenericCreate>
    4390:	8c 83       	std	Y+4, r24	; 0x04
    4392:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    4394:	ce 82       	std	Y+6, r12	; 0x06
    4396:	df 82       	std	Y+7, r13	; 0x07
    4398:	e8 86       	std	Y+8, r14	; 0x08
    439a:	f9 86       	std	Y+9, r15	; 0x09
    439c:	c9 e2       	ldi	r28, 0x29	; 41
    439e:	d2 e4       	ldi	r29, 0x42	; 66
    43a0:	1a 82       	std	Y+2, r1	; 0x02
    43a2:	1b 82       	std	Y+3, r1	; 0x03
 */

template <class data_type>
frt_queue<data_type>::frt_queue (uint8_t queue_size, emstream* p_ser_dev,
								portTickType wait_time)
	: frt_base_queue<data_type> (p_ser_dev)
    43a4:	08 83       	st	Y, r16
    43a6:	19 83       	std	Y+1, r17	; 0x01
{
	// Create a FreeRTOS queue object with space for the data items
	handle = xQueueCreate (queue_size, sizeof (data_type));
    43a8:	40 e0       	ldi	r20, 0x00	; 0
    43aa:	62 e0       	ldi	r22, 0x02	; 2
    43ac:	8f ef       	ldi	r24, 0xFF	; 255
    43ae:	0e 94 df 09 	call	0x13be	; 0x13be <xQueueGenericCreate>
    43b2:	8c 83       	std	Y+4, r24	; 0x04
    43b4:	9d 83       	std	Y+5, r25	; 0x05

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = wait_time;
    43b6:	ce 82       	std	Y+6, r12	; 0x06
    43b8:	df 82       	std	Y+7, r13	; 0x07
    43ba:	e8 86       	std	Y+8, r14	; 0x08
    43bc:	f9 86       	std	Y+9, r15	; 0x09

	// Set PWM duty cycles based on results
	TCC0.CCABUF = A_duty;
	TCC0.CCBBUF = B_duty;
	TCC0.CCCBUF = C_duty;
    43be:	df 91       	pop	r29
    43c0:	cf 91       	pop	r28
    43c2:	1f 91       	pop	r17
    43c4:	0f 91       	pop	r16
    43c6:	ff 90       	pop	r15
    43c8:	ef 90       	pop	r14
    43ca:	df 90       	pop	r13
    43cc:	cf 90       	pop	r12
    43ce:	08 95       	ret

000043d0 <__subsf3>:
    43d0:	50 58       	subi	r21, 0x80	; 128

000043d2 <__addsf3>:
    43d2:	bb 27       	eor	r27, r27
    43d4:	aa 27       	eor	r26, r26
    43d6:	0e 94 00 22 	call	0x4400	; 0x4400 <__addsf3x>
    43da:	0c 94 7a 23 	jmp	0x46f4	; 0x46f4 <__fp_round>
    43de:	0e 94 41 23 	call	0x4682	; 0x4682 <__fp_pscA>
    43e2:	38 f0       	brcs	.+14     	; 0x43f2 <__addsf3+0x20>
    43e4:	0e 94 48 23 	call	0x4690	; 0x4690 <__fp_pscB>
    43e8:	20 f0       	brcs	.+8      	; 0x43f2 <__addsf3+0x20>
    43ea:	39 f4       	brne	.+14     	; 0x43fa <__addsf3+0x28>
    43ec:	9f 3f       	cpi	r25, 0xFF	; 255
    43ee:	19 f4       	brne	.+6      	; 0x43f6 <__addsf3+0x24>
    43f0:	26 f4       	brtc	.+8      	; 0x43fa <__addsf3+0x28>
    43f2:	0c 94 3e 23 	jmp	0x467c	; 0x467c <__fp_nan>
    43f6:	0e f4       	brtc	.+2      	; 0x43fa <__addsf3+0x28>
    43f8:	e0 95       	com	r30
    43fa:	e7 fb       	bst	r30, 7
    43fc:	0c 94 38 23 	jmp	0x4670	; 0x4670 <__fp_inf>

00004400 <__addsf3x>:
    4400:	e9 2f       	mov	r30, r25
    4402:	0e 94 9f 23 	call	0x473e	; 0x473e <__fp_split3>
    4406:	58 f3       	brcs	.-42     	; 0x43de <__addsf3+0xc>
    4408:	ba 17       	cp	r27, r26
    440a:	62 07       	cpc	r22, r18
    440c:	73 07       	cpc	r23, r19
    440e:	84 07       	cpc	r24, r20
    4410:	95 07       	cpc	r25, r21
    4412:	20 f0       	brcs	.+8      	; 0x441c <__addsf3x+0x1c>
    4414:	79 f4       	brne	.+30     	; 0x4434 <__addsf3x+0x34>
    4416:	a6 f5       	brtc	.+104    	; 0x4480 <__addsf3x+0x80>
    4418:	0c 94 c1 23 	jmp	0x4782	; 0x4782 <__fp_zero>
    441c:	0e f4       	brtc	.+2      	; 0x4420 <__addsf3x+0x20>
    441e:	e0 95       	com	r30
    4420:	0b 2e       	mov	r0, r27
    4422:	ba 2f       	mov	r27, r26
    4424:	a0 2d       	mov	r26, r0
    4426:	0b 01       	movw	r0, r22
    4428:	b9 01       	movw	r22, r18
    442a:	90 01       	movw	r18, r0
    442c:	0c 01       	movw	r0, r24
    442e:	ca 01       	movw	r24, r20
    4430:	a0 01       	movw	r20, r0
    4432:	11 24       	eor	r1, r1
    4434:	ff 27       	eor	r31, r31
    4436:	59 1b       	sub	r21, r25
    4438:	99 f0       	breq	.+38     	; 0x4460 <__addsf3x+0x60>
    443a:	59 3f       	cpi	r21, 0xF9	; 249
    443c:	50 f4       	brcc	.+20     	; 0x4452 <__addsf3x+0x52>
    443e:	50 3e       	cpi	r21, 0xE0	; 224
    4440:	68 f1       	brcs	.+90     	; 0x449c <__addsf3x+0x9c>
    4442:	1a 16       	cp	r1, r26
    4444:	f0 40       	sbci	r31, 0x00	; 0
    4446:	a2 2f       	mov	r26, r18
    4448:	23 2f       	mov	r18, r19
    444a:	34 2f       	mov	r19, r20
    444c:	44 27       	eor	r20, r20
    444e:	58 5f       	subi	r21, 0xF8	; 248
    4450:	f3 cf       	rjmp	.-26     	; 0x4438 <__addsf3x+0x38>
    4452:	46 95       	lsr	r20
    4454:	37 95       	ror	r19
    4456:	27 95       	ror	r18
    4458:	a7 95       	ror	r26
    445a:	f0 40       	sbci	r31, 0x00	; 0
    445c:	53 95       	inc	r21
    445e:	c9 f7       	brne	.-14     	; 0x4452 <__addsf3x+0x52>
    4460:	7e f4       	brtc	.+30     	; 0x4480 <__addsf3x+0x80>
    4462:	1f 16       	cp	r1, r31
    4464:	ba 0b       	sbc	r27, r26
    4466:	62 0b       	sbc	r22, r18
    4468:	73 0b       	sbc	r23, r19
    446a:	84 0b       	sbc	r24, r20
    446c:	ba f0       	brmi	.+46     	; 0x449c <__addsf3x+0x9c>
    446e:	91 50       	subi	r25, 0x01	; 1
    4470:	a1 f0       	breq	.+40     	; 0x449a <__addsf3x+0x9a>
    4472:	ff 0f       	add	r31, r31
    4474:	bb 1f       	adc	r27, r27
    4476:	66 1f       	adc	r22, r22
    4478:	77 1f       	adc	r23, r23
    447a:	88 1f       	adc	r24, r24
    447c:	c2 f7       	brpl	.-16     	; 0x446e <__addsf3x+0x6e>
    447e:	0e c0       	rjmp	.+28     	; 0x449c <__addsf3x+0x9c>
    4480:	ba 0f       	add	r27, r26
    4482:	62 1f       	adc	r22, r18
    4484:	73 1f       	adc	r23, r19
    4486:	84 1f       	adc	r24, r20
    4488:	48 f4       	brcc	.+18     	; 0x449c <__addsf3x+0x9c>
    448a:	87 95       	ror	r24
    448c:	77 95       	ror	r23
    448e:	67 95       	ror	r22
    4490:	b7 95       	ror	r27
    4492:	f7 95       	ror	r31
    4494:	9e 3f       	cpi	r25, 0xFE	; 254
    4496:	08 f0       	brcs	.+2      	; 0x449a <__addsf3x+0x9a>
    4498:	b0 cf       	rjmp	.-160    	; 0x43fa <__addsf3+0x28>
    449a:	93 95       	inc	r25
    449c:	88 0f       	add	r24, r24
    449e:	08 f0       	brcs	.+2      	; 0x44a2 <__addsf3x+0xa2>
    44a0:	99 27       	eor	r25, r25
    44a2:	ee 0f       	add	r30, r30
    44a4:	97 95       	ror	r25
    44a6:	87 95       	ror	r24
    44a8:	08 95       	ret

000044aa <cos>:
    44aa:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__fp_rempio2>
    44ae:	e3 95       	inc	r30
    44b0:	0c 94 8b 23 	jmp	0x4716	; 0x4716 <__fp_sinus>

000044b4 <__divsf3>:
    44b4:	0e 94 6e 22 	call	0x44dc	; 0x44dc <__divsf3x>
    44b8:	0c 94 7a 23 	jmp	0x46f4	; 0x46f4 <__fp_round>
    44bc:	0e 94 48 23 	call	0x4690	; 0x4690 <__fp_pscB>
    44c0:	58 f0       	brcs	.+22     	; 0x44d8 <__divsf3+0x24>
    44c2:	0e 94 41 23 	call	0x4682	; 0x4682 <__fp_pscA>
    44c6:	40 f0       	brcs	.+16     	; 0x44d8 <__divsf3+0x24>
    44c8:	29 f4       	brne	.+10     	; 0x44d4 <__divsf3+0x20>
    44ca:	5f 3f       	cpi	r21, 0xFF	; 255
    44cc:	29 f0       	breq	.+10     	; 0x44d8 <__divsf3+0x24>
    44ce:	0c 94 38 23 	jmp	0x4670	; 0x4670 <__fp_inf>
    44d2:	51 11       	cpse	r21, r1
    44d4:	0c 94 c2 23 	jmp	0x4784	; 0x4784 <__fp_szero>
    44d8:	0c 94 3e 23 	jmp	0x467c	; 0x467c <__fp_nan>

000044dc <__divsf3x>:
    44dc:	0e 94 9f 23 	call	0x473e	; 0x473e <__fp_split3>
    44e0:	68 f3       	brcs	.-38     	; 0x44bc <__divsf3+0x8>

000044e2 <__divsf3_pse>:
    44e2:	99 23       	and	r25, r25
    44e4:	b1 f3       	breq	.-20     	; 0x44d2 <__divsf3+0x1e>
    44e6:	55 23       	and	r21, r21
    44e8:	91 f3       	breq	.-28     	; 0x44ce <__divsf3+0x1a>
    44ea:	95 1b       	sub	r25, r21
    44ec:	55 0b       	sbc	r21, r21
    44ee:	bb 27       	eor	r27, r27
    44f0:	aa 27       	eor	r26, r26
    44f2:	62 17       	cp	r22, r18
    44f4:	73 07       	cpc	r23, r19
    44f6:	84 07       	cpc	r24, r20
    44f8:	38 f0       	brcs	.+14     	; 0x4508 <__divsf3_pse+0x26>
    44fa:	9f 5f       	subi	r25, 0xFF	; 255
    44fc:	5f 4f       	sbci	r21, 0xFF	; 255
    44fe:	22 0f       	add	r18, r18
    4500:	33 1f       	adc	r19, r19
    4502:	44 1f       	adc	r20, r20
    4504:	aa 1f       	adc	r26, r26
    4506:	a9 f3       	breq	.-22     	; 0x44f2 <__divsf3_pse+0x10>
    4508:	35 d0       	rcall	.+106    	; 0x4574 <__divsf3_pse+0x92>
    450a:	0e 2e       	mov	r0, r30
    450c:	3a f0       	brmi	.+14     	; 0x451c <__divsf3_pse+0x3a>
    450e:	e0 e8       	ldi	r30, 0x80	; 128
    4510:	32 d0       	rcall	.+100    	; 0x4576 <__divsf3_pse+0x94>
    4512:	91 50       	subi	r25, 0x01	; 1
    4514:	50 40       	sbci	r21, 0x00	; 0
    4516:	e6 95       	lsr	r30
    4518:	00 1c       	adc	r0, r0
    451a:	ca f7       	brpl	.-14     	; 0x450e <__divsf3_pse+0x2c>
    451c:	2b d0       	rcall	.+86     	; 0x4574 <__divsf3_pse+0x92>
    451e:	fe 2f       	mov	r31, r30
    4520:	29 d0       	rcall	.+82     	; 0x4574 <__divsf3_pse+0x92>
    4522:	66 0f       	add	r22, r22
    4524:	77 1f       	adc	r23, r23
    4526:	88 1f       	adc	r24, r24
    4528:	bb 1f       	adc	r27, r27
    452a:	26 17       	cp	r18, r22
    452c:	37 07       	cpc	r19, r23
    452e:	48 07       	cpc	r20, r24
    4530:	ab 07       	cpc	r26, r27
    4532:	b0 e8       	ldi	r27, 0x80	; 128
    4534:	09 f0       	breq	.+2      	; 0x4538 <__divsf3_pse+0x56>
    4536:	bb 0b       	sbc	r27, r27
    4538:	80 2d       	mov	r24, r0
    453a:	bf 01       	movw	r22, r30
    453c:	ff 27       	eor	r31, r31
    453e:	93 58       	subi	r25, 0x83	; 131
    4540:	5f 4f       	sbci	r21, 0xFF	; 255
    4542:	3a f0       	brmi	.+14     	; 0x4552 <__divsf3_pse+0x70>
    4544:	9e 3f       	cpi	r25, 0xFE	; 254
    4546:	51 05       	cpc	r21, r1
    4548:	78 f0       	brcs	.+30     	; 0x4568 <__divsf3_pse+0x86>
    454a:	0c 94 38 23 	jmp	0x4670	; 0x4670 <__fp_inf>
    454e:	0c 94 c2 23 	jmp	0x4784	; 0x4784 <__fp_szero>
    4552:	5f 3f       	cpi	r21, 0xFF	; 255
    4554:	e4 f3       	brlt	.-8      	; 0x454e <__divsf3_pse+0x6c>
    4556:	98 3e       	cpi	r25, 0xE8	; 232
    4558:	d4 f3       	brlt	.-12     	; 0x454e <__divsf3_pse+0x6c>
    455a:	86 95       	lsr	r24
    455c:	77 95       	ror	r23
    455e:	67 95       	ror	r22
    4560:	b7 95       	ror	r27
    4562:	f7 95       	ror	r31
    4564:	9f 5f       	subi	r25, 0xFF	; 255
    4566:	c9 f7       	brne	.-14     	; 0x455a <__divsf3_pse+0x78>
    4568:	88 0f       	add	r24, r24
    456a:	91 1d       	adc	r25, r1
    456c:	96 95       	lsr	r25
    456e:	87 95       	ror	r24
    4570:	97 f9       	bld	r25, 7
    4572:	08 95       	ret
    4574:	e1 e0       	ldi	r30, 0x01	; 1
    4576:	66 0f       	add	r22, r22
    4578:	77 1f       	adc	r23, r23
    457a:	88 1f       	adc	r24, r24
    457c:	bb 1f       	adc	r27, r27
    457e:	62 17       	cp	r22, r18
    4580:	73 07       	cpc	r23, r19
    4582:	84 07       	cpc	r24, r20
    4584:	ba 07       	cpc	r27, r26
    4586:	20 f0       	brcs	.+8      	; 0x4590 <__divsf3_pse+0xae>
    4588:	62 1b       	sub	r22, r18
    458a:	73 0b       	sbc	r23, r19
    458c:	84 0b       	sbc	r24, r20
    458e:	ba 0b       	sbc	r27, r26
    4590:	ee 1f       	adc	r30, r30
    4592:	88 f7       	brcc	.-30     	; 0x4576 <__divsf3_pse+0x94>
    4594:	e0 95       	com	r30
    4596:	08 95       	ret

00004598 <__fixunssfsi>:
    4598:	0e 94 a7 23 	call	0x474e	; 0x474e <__fp_splitA>
    459c:	88 f0       	brcs	.+34     	; 0x45c0 <__fixunssfsi+0x28>
    459e:	9f 57       	subi	r25, 0x7F	; 127
    45a0:	98 f0       	brcs	.+38     	; 0x45c8 <__fixunssfsi+0x30>
    45a2:	b9 2f       	mov	r27, r25
    45a4:	99 27       	eor	r25, r25
    45a6:	b7 51       	subi	r27, 0x17	; 23
    45a8:	b0 f0       	brcs	.+44     	; 0x45d6 <__fixunssfsi+0x3e>
    45aa:	e1 f0       	breq	.+56     	; 0x45e4 <__fixunssfsi+0x4c>
    45ac:	66 0f       	add	r22, r22
    45ae:	77 1f       	adc	r23, r23
    45b0:	88 1f       	adc	r24, r24
    45b2:	99 1f       	adc	r25, r25
    45b4:	1a f0       	brmi	.+6      	; 0x45bc <__fixunssfsi+0x24>
    45b6:	ba 95       	dec	r27
    45b8:	c9 f7       	brne	.-14     	; 0x45ac <__fixunssfsi+0x14>
    45ba:	14 c0       	rjmp	.+40     	; 0x45e4 <__fixunssfsi+0x4c>
    45bc:	b1 30       	cpi	r27, 0x01	; 1
    45be:	91 f0       	breq	.+36     	; 0x45e4 <__fixunssfsi+0x4c>
    45c0:	0e 94 c1 23 	call	0x4782	; 0x4782 <__fp_zero>
    45c4:	b1 e0       	ldi	r27, 0x01	; 1
    45c6:	08 95       	ret
    45c8:	0c 94 c1 23 	jmp	0x4782	; 0x4782 <__fp_zero>
    45cc:	67 2f       	mov	r22, r23
    45ce:	78 2f       	mov	r23, r24
    45d0:	88 27       	eor	r24, r24
    45d2:	b8 5f       	subi	r27, 0xF8	; 248
    45d4:	39 f0       	breq	.+14     	; 0x45e4 <__fixunssfsi+0x4c>
    45d6:	b9 3f       	cpi	r27, 0xF9	; 249
    45d8:	cc f3       	brlt	.-14     	; 0x45cc <__fixunssfsi+0x34>
    45da:	86 95       	lsr	r24
    45dc:	77 95       	ror	r23
    45de:	67 95       	ror	r22
    45e0:	b3 95       	inc	r27
    45e2:	d9 f7       	brne	.-10     	; 0x45da <__fixunssfsi+0x42>
    45e4:	3e f4       	brtc	.+14     	; 0x45f4 <__fixunssfsi+0x5c>
    45e6:	90 95       	com	r25
    45e8:	80 95       	com	r24
    45ea:	70 95       	com	r23
    45ec:	61 95       	neg	r22
    45ee:	7f 4f       	sbci	r23, 0xFF	; 255
    45f0:	8f 4f       	sbci	r24, 0xFF	; 255
    45f2:	9f 4f       	sbci	r25, 0xFF	; 255
    45f4:	08 95       	ret

000045f6 <__floatunsisf>:
    45f6:	e8 94       	clt
    45f8:	09 c0       	rjmp	.+18     	; 0x460c <__floatsisf+0x12>

000045fa <__floatsisf>:
    45fa:	97 fb       	bst	r25, 7
    45fc:	3e f4       	brtc	.+14     	; 0x460c <__floatsisf+0x12>
    45fe:	90 95       	com	r25
    4600:	80 95       	com	r24
    4602:	70 95       	com	r23
    4604:	61 95       	neg	r22
    4606:	7f 4f       	sbci	r23, 0xFF	; 255
    4608:	8f 4f       	sbci	r24, 0xFF	; 255
    460a:	9f 4f       	sbci	r25, 0xFF	; 255
    460c:	99 23       	and	r25, r25
    460e:	a9 f0       	breq	.+42     	; 0x463a <__floatsisf+0x40>
    4610:	f9 2f       	mov	r31, r25
    4612:	96 e9       	ldi	r25, 0x96	; 150
    4614:	bb 27       	eor	r27, r27
    4616:	93 95       	inc	r25
    4618:	f6 95       	lsr	r31
    461a:	87 95       	ror	r24
    461c:	77 95       	ror	r23
    461e:	67 95       	ror	r22
    4620:	b7 95       	ror	r27
    4622:	f1 11       	cpse	r31, r1
    4624:	f8 cf       	rjmp	.-16     	; 0x4616 <__floatsisf+0x1c>
    4626:	fa f4       	brpl	.+62     	; 0x4666 <__floatsisf+0x6c>
    4628:	bb 0f       	add	r27, r27
    462a:	11 f4       	brne	.+4      	; 0x4630 <__floatsisf+0x36>
    462c:	60 ff       	sbrs	r22, 0
    462e:	1b c0       	rjmp	.+54     	; 0x4666 <__floatsisf+0x6c>
    4630:	6f 5f       	subi	r22, 0xFF	; 255
    4632:	7f 4f       	sbci	r23, 0xFF	; 255
    4634:	8f 4f       	sbci	r24, 0xFF	; 255
    4636:	9f 4f       	sbci	r25, 0xFF	; 255
    4638:	16 c0       	rjmp	.+44     	; 0x4666 <__floatsisf+0x6c>
    463a:	88 23       	and	r24, r24
    463c:	11 f0       	breq	.+4      	; 0x4642 <__floatsisf+0x48>
    463e:	96 e9       	ldi	r25, 0x96	; 150
    4640:	11 c0       	rjmp	.+34     	; 0x4664 <__floatsisf+0x6a>
    4642:	77 23       	and	r23, r23
    4644:	21 f0       	breq	.+8      	; 0x464e <__floatsisf+0x54>
    4646:	9e e8       	ldi	r25, 0x8E	; 142
    4648:	87 2f       	mov	r24, r23
    464a:	76 2f       	mov	r23, r22
    464c:	05 c0       	rjmp	.+10     	; 0x4658 <__floatsisf+0x5e>
    464e:	66 23       	and	r22, r22
    4650:	71 f0       	breq	.+28     	; 0x466e <__floatsisf+0x74>
    4652:	96 e8       	ldi	r25, 0x86	; 134
    4654:	86 2f       	mov	r24, r22
    4656:	70 e0       	ldi	r23, 0x00	; 0
    4658:	60 e0       	ldi	r22, 0x00	; 0
    465a:	2a f0       	brmi	.+10     	; 0x4666 <__floatsisf+0x6c>
    465c:	9a 95       	dec	r25
    465e:	66 0f       	add	r22, r22
    4660:	77 1f       	adc	r23, r23
    4662:	88 1f       	adc	r24, r24
    4664:	da f7       	brpl	.-10     	; 0x465c <__floatsisf+0x62>
    4666:	88 0f       	add	r24, r24
    4668:	96 95       	lsr	r25
    466a:	87 95       	ror	r24
    466c:	97 f9       	bld	r25, 7
    466e:	08 95       	ret

00004670 <__fp_inf>:
    4670:	97 f9       	bld	r25, 7
    4672:	9f 67       	ori	r25, 0x7F	; 127
    4674:	80 e8       	ldi	r24, 0x80	; 128
    4676:	70 e0       	ldi	r23, 0x00	; 0
    4678:	60 e0       	ldi	r22, 0x00	; 0
    467a:	08 95       	ret

0000467c <__fp_nan>:
    467c:	9f ef       	ldi	r25, 0xFF	; 255
    467e:	80 ec       	ldi	r24, 0xC0	; 192
    4680:	08 95       	ret

00004682 <__fp_pscA>:
    4682:	00 24       	eor	r0, r0
    4684:	0a 94       	dec	r0
    4686:	16 16       	cp	r1, r22
    4688:	17 06       	cpc	r1, r23
    468a:	18 06       	cpc	r1, r24
    468c:	09 06       	cpc	r0, r25
    468e:	08 95       	ret

00004690 <__fp_pscB>:
    4690:	00 24       	eor	r0, r0
    4692:	0a 94       	dec	r0
    4694:	12 16       	cp	r1, r18
    4696:	13 06       	cpc	r1, r19
    4698:	14 06       	cpc	r1, r20
    469a:	05 06       	cpc	r0, r21
    469c:	08 95       	ret
    469e:	0c 94 3e 23 	jmp	0x467c	; 0x467c <__fp_nan>

000046a2 <__fp_rempio2>:
    46a2:	0e 94 a7 23 	call	0x474e	; 0x474e <__fp_splitA>
    46a6:	d8 f3       	brcs	.-10     	; 0x469e <__fp_pscB+0xe>
    46a8:	e8 94       	clt
    46aa:	e0 e0       	ldi	r30, 0x00	; 0
    46ac:	bb 27       	eor	r27, r27
    46ae:	9f 57       	subi	r25, 0x7F	; 127
    46b0:	f0 f0       	brcs	.+60     	; 0x46ee <__fp_rempio2+0x4c>
    46b2:	2a ed       	ldi	r18, 0xDA	; 218
    46b4:	3f e0       	ldi	r19, 0x0F	; 15
    46b6:	49 ec       	ldi	r20, 0xC9	; 201
    46b8:	06 c0       	rjmp	.+12     	; 0x46c6 <__fp_rempio2+0x24>
    46ba:	ee 0f       	add	r30, r30
    46bc:	bb 0f       	add	r27, r27
    46be:	66 1f       	adc	r22, r22
    46c0:	77 1f       	adc	r23, r23
    46c2:	88 1f       	adc	r24, r24
    46c4:	28 f0       	brcs	.+10     	; 0x46d0 <__fp_rempio2+0x2e>
    46c6:	b2 3a       	cpi	r27, 0xA2	; 162
    46c8:	62 07       	cpc	r22, r18
    46ca:	73 07       	cpc	r23, r19
    46cc:	84 07       	cpc	r24, r20
    46ce:	28 f0       	brcs	.+10     	; 0x46da <__fp_rempio2+0x38>
    46d0:	b2 5a       	subi	r27, 0xA2	; 162
    46d2:	62 0b       	sbc	r22, r18
    46d4:	73 0b       	sbc	r23, r19
    46d6:	84 0b       	sbc	r24, r20
    46d8:	e3 95       	inc	r30
    46da:	9a 95       	dec	r25
    46dc:	72 f7       	brpl	.-36     	; 0x46ba <__fp_rempio2+0x18>
    46de:	80 38       	cpi	r24, 0x80	; 128
    46e0:	30 f4       	brcc	.+12     	; 0x46ee <__fp_rempio2+0x4c>
    46e2:	9a 95       	dec	r25
    46e4:	bb 0f       	add	r27, r27
    46e6:	66 1f       	adc	r22, r22
    46e8:	77 1f       	adc	r23, r23
    46ea:	88 1f       	adc	r24, r24
    46ec:	d2 f7       	brpl	.-12     	; 0x46e2 <__fp_rempio2+0x40>
    46ee:	90 48       	sbci	r25, 0x80	; 128
    46f0:	0c 94 3f 24 	jmp	0x487e	; 0x487e <__fp_mpack_finite>

000046f4 <__fp_round>:
    46f4:	09 2e       	mov	r0, r25
    46f6:	03 94       	inc	r0
    46f8:	00 0c       	add	r0, r0
    46fa:	11 f4       	brne	.+4      	; 0x4700 <__fp_round+0xc>
    46fc:	88 23       	and	r24, r24
    46fe:	52 f0       	brmi	.+20     	; 0x4714 <__fp_round+0x20>
    4700:	bb 0f       	add	r27, r27
    4702:	40 f4       	brcc	.+16     	; 0x4714 <__fp_round+0x20>
    4704:	bf 2b       	or	r27, r31
    4706:	11 f4       	brne	.+4      	; 0x470c <__fp_round+0x18>
    4708:	60 ff       	sbrs	r22, 0
    470a:	04 c0       	rjmp	.+8      	; 0x4714 <__fp_round+0x20>
    470c:	6f 5f       	subi	r22, 0xFF	; 255
    470e:	7f 4f       	sbci	r23, 0xFF	; 255
    4710:	8f 4f       	sbci	r24, 0xFF	; 255
    4712:	9f 4f       	sbci	r25, 0xFF	; 255
    4714:	08 95       	ret

00004716 <__fp_sinus>:
    4716:	ef 93       	push	r30
    4718:	e0 ff       	sbrs	r30, 0
    471a:	07 c0       	rjmp	.+14     	; 0x472a <__fp_sinus+0x14>
    471c:	a2 ea       	ldi	r26, 0xA2	; 162
    471e:	2a ed       	ldi	r18, 0xDA	; 218
    4720:	3f e0       	ldi	r19, 0x0F	; 15
    4722:	49 ec       	ldi	r20, 0xC9	; 201
    4724:	5f eb       	ldi	r21, 0xBF	; 191
    4726:	0e 94 00 22 	call	0x4400	; 0x4400 <__addsf3x>
    472a:	0e 94 7a 23 	call	0x46f4	; 0x46f4 <__fp_round>
    472e:	0f 90       	pop	r0
    4730:	03 94       	inc	r0
    4732:	01 fc       	sbrc	r0, 1
    4734:	90 58       	subi	r25, 0x80	; 128
    4736:	e2 e1       	ldi	r30, 0x12	; 18
    4738:	f2 e0       	ldi	r31, 0x02	; 2
    473a:	0c 94 4b 24 	jmp	0x4896	; 0x4896 <__fp_powsodd>

0000473e <__fp_split3>:
    473e:	57 fd       	sbrc	r21, 7
    4740:	90 58       	subi	r25, 0x80	; 128
    4742:	44 0f       	add	r20, r20
    4744:	55 1f       	adc	r21, r21
    4746:	59 f0       	breq	.+22     	; 0x475e <__fp_splitA+0x10>
    4748:	5f 3f       	cpi	r21, 0xFF	; 255
    474a:	71 f0       	breq	.+28     	; 0x4768 <__fp_splitA+0x1a>
    474c:	47 95       	ror	r20

0000474e <__fp_splitA>:
    474e:	88 0f       	add	r24, r24
    4750:	97 fb       	bst	r25, 7
    4752:	99 1f       	adc	r25, r25
    4754:	61 f0       	breq	.+24     	; 0x476e <__fp_splitA+0x20>
    4756:	9f 3f       	cpi	r25, 0xFF	; 255
    4758:	79 f0       	breq	.+30     	; 0x4778 <__fp_splitA+0x2a>
    475a:	87 95       	ror	r24
    475c:	08 95       	ret
    475e:	12 16       	cp	r1, r18
    4760:	13 06       	cpc	r1, r19
    4762:	14 06       	cpc	r1, r20
    4764:	55 1f       	adc	r21, r21
    4766:	f2 cf       	rjmp	.-28     	; 0x474c <__fp_split3+0xe>
    4768:	46 95       	lsr	r20
    476a:	f1 df       	rcall	.-30     	; 0x474e <__fp_splitA>
    476c:	08 c0       	rjmp	.+16     	; 0x477e <__fp_splitA+0x30>
    476e:	16 16       	cp	r1, r22
    4770:	17 06       	cpc	r1, r23
    4772:	18 06       	cpc	r1, r24
    4774:	99 1f       	adc	r25, r25
    4776:	f1 cf       	rjmp	.-30     	; 0x475a <__fp_splitA+0xc>
    4778:	86 95       	lsr	r24
    477a:	71 05       	cpc	r23, r1
    477c:	61 05       	cpc	r22, r1
    477e:	08 94       	sec
    4780:	08 95       	ret

00004782 <__fp_zero>:
    4782:	e8 94       	clt

00004784 <__fp_szero>:
    4784:	bb 27       	eor	r27, r27
    4786:	66 27       	eor	r22, r22
    4788:	77 27       	eor	r23, r23
    478a:	cb 01       	movw	r24, r22
    478c:	97 f9       	bld	r25, 7
    478e:	08 95       	ret

00004790 <__mulsf3>:
    4790:	0e 94 db 23 	call	0x47b6	; 0x47b6 <__mulsf3x>
    4794:	0c 94 7a 23 	jmp	0x46f4	; 0x46f4 <__fp_round>
    4798:	0e 94 41 23 	call	0x4682	; 0x4682 <__fp_pscA>
    479c:	38 f0       	brcs	.+14     	; 0x47ac <__mulsf3+0x1c>
    479e:	0e 94 48 23 	call	0x4690	; 0x4690 <__fp_pscB>
    47a2:	20 f0       	brcs	.+8      	; 0x47ac <__mulsf3+0x1c>
    47a4:	95 23       	and	r25, r21
    47a6:	11 f0       	breq	.+4      	; 0x47ac <__mulsf3+0x1c>
    47a8:	0c 94 38 23 	jmp	0x4670	; 0x4670 <__fp_inf>
    47ac:	0c 94 3e 23 	jmp	0x467c	; 0x467c <__fp_nan>
    47b0:	11 24       	eor	r1, r1
    47b2:	0c 94 c2 23 	jmp	0x4784	; 0x4784 <__fp_szero>

000047b6 <__mulsf3x>:
    47b6:	0e 94 9f 23 	call	0x473e	; 0x473e <__fp_split3>
    47ba:	70 f3       	brcs	.-36     	; 0x4798 <__mulsf3+0x8>

000047bc <__mulsf3_pse>:
    47bc:	95 9f       	mul	r25, r21
    47be:	c1 f3       	breq	.-16     	; 0x47b0 <__mulsf3+0x20>
    47c0:	95 0f       	add	r25, r21
    47c2:	50 e0       	ldi	r21, 0x00	; 0
    47c4:	55 1f       	adc	r21, r21
    47c6:	62 9f       	mul	r22, r18
    47c8:	f0 01       	movw	r30, r0
    47ca:	72 9f       	mul	r23, r18
    47cc:	bb 27       	eor	r27, r27
    47ce:	f0 0d       	add	r31, r0
    47d0:	b1 1d       	adc	r27, r1
    47d2:	63 9f       	mul	r22, r19
    47d4:	aa 27       	eor	r26, r26
    47d6:	f0 0d       	add	r31, r0
    47d8:	b1 1d       	adc	r27, r1
    47da:	aa 1f       	adc	r26, r26
    47dc:	64 9f       	mul	r22, r20
    47de:	66 27       	eor	r22, r22
    47e0:	b0 0d       	add	r27, r0
    47e2:	a1 1d       	adc	r26, r1
    47e4:	66 1f       	adc	r22, r22
    47e6:	82 9f       	mul	r24, r18
    47e8:	22 27       	eor	r18, r18
    47ea:	b0 0d       	add	r27, r0
    47ec:	a1 1d       	adc	r26, r1
    47ee:	62 1f       	adc	r22, r18
    47f0:	73 9f       	mul	r23, r19
    47f2:	b0 0d       	add	r27, r0
    47f4:	a1 1d       	adc	r26, r1
    47f6:	62 1f       	adc	r22, r18
    47f8:	83 9f       	mul	r24, r19
    47fa:	a0 0d       	add	r26, r0
    47fc:	61 1d       	adc	r22, r1
    47fe:	22 1f       	adc	r18, r18
    4800:	74 9f       	mul	r23, r20
    4802:	33 27       	eor	r19, r19
    4804:	a0 0d       	add	r26, r0
    4806:	61 1d       	adc	r22, r1
    4808:	23 1f       	adc	r18, r19
    480a:	84 9f       	mul	r24, r20
    480c:	60 0d       	add	r22, r0
    480e:	21 1d       	adc	r18, r1
    4810:	82 2f       	mov	r24, r18
    4812:	76 2f       	mov	r23, r22
    4814:	6a 2f       	mov	r22, r26
    4816:	11 24       	eor	r1, r1
    4818:	9f 57       	subi	r25, 0x7F	; 127
    481a:	50 40       	sbci	r21, 0x00	; 0
    481c:	9a f0       	brmi	.+38     	; 0x4844 <__mulsf3_pse+0x88>
    481e:	f1 f0       	breq	.+60     	; 0x485c <__mulsf3_pse+0xa0>
    4820:	88 23       	and	r24, r24
    4822:	4a f0       	brmi	.+18     	; 0x4836 <__mulsf3_pse+0x7a>
    4824:	ee 0f       	add	r30, r30
    4826:	ff 1f       	adc	r31, r31
    4828:	bb 1f       	adc	r27, r27
    482a:	66 1f       	adc	r22, r22
    482c:	77 1f       	adc	r23, r23
    482e:	88 1f       	adc	r24, r24
    4830:	91 50       	subi	r25, 0x01	; 1
    4832:	50 40       	sbci	r21, 0x00	; 0
    4834:	a9 f7       	brne	.-22     	; 0x4820 <__mulsf3_pse+0x64>
    4836:	9e 3f       	cpi	r25, 0xFE	; 254
    4838:	51 05       	cpc	r21, r1
    483a:	80 f0       	brcs	.+32     	; 0x485c <__mulsf3_pse+0xa0>
    483c:	0c 94 38 23 	jmp	0x4670	; 0x4670 <__fp_inf>
    4840:	0c 94 c2 23 	jmp	0x4784	; 0x4784 <__fp_szero>
    4844:	5f 3f       	cpi	r21, 0xFF	; 255
    4846:	e4 f3       	brlt	.-8      	; 0x4840 <__mulsf3_pse+0x84>
    4848:	98 3e       	cpi	r25, 0xE8	; 232
    484a:	d4 f3       	brlt	.-12     	; 0x4840 <__mulsf3_pse+0x84>
    484c:	86 95       	lsr	r24
    484e:	77 95       	ror	r23
    4850:	67 95       	ror	r22
    4852:	b7 95       	ror	r27
    4854:	f7 95       	ror	r31
    4856:	e7 95       	ror	r30
    4858:	9f 5f       	subi	r25, 0xFF	; 255
    485a:	c1 f7       	brne	.-16     	; 0x484c <__mulsf3_pse+0x90>
    485c:	fe 2b       	or	r31, r30
    485e:	88 0f       	add	r24, r24
    4860:	91 1d       	adc	r25, r1
    4862:	96 95       	lsr	r25
    4864:	87 95       	ror	r24
    4866:	97 f9       	bld	r25, 7
    4868:	08 95       	ret

0000486a <sin>:
    486a:	9f 93       	push	r25
    486c:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__fp_rempio2>
    4870:	0f 90       	pop	r0
    4872:	07 fc       	sbrc	r0, 7
    4874:	ee 5f       	subi	r30, 0xFE	; 254
    4876:	0c 94 8b 23 	jmp	0x4716	; 0x4716 <__fp_sinus>

0000487a <__fp_mpack>:
    487a:	9f 3f       	cpi	r25, 0xFF	; 255
    487c:	31 f0       	breq	.+12     	; 0x488a <__fp_mpack_finite+0xc>

0000487e <__fp_mpack_finite>:
    487e:	91 50       	subi	r25, 0x01	; 1
    4880:	20 f4       	brcc	.+8      	; 0x488a <__fp_mpack_finite+0xc>
    4882:	87 95       	ror	r24
    4884:	77 95       	ror	r23
    4886:	67 95       	ror	r22
    4888:	b7 95       	ror	r27
    488a:	88 0f       	add	r24, r24
    488c:	91 1d       	adc	r25, r1
    488e:	96 95       	lsr	r25
    4890:	87 95       	ror	r24
    4892:	97 f9       	bld	r25, 7
    4894:	08 95       	ret

00004896 <__fp_powsodd>:
    4896:	9f 93       	push	r25
    4898:	8f 93       	push	r24
    489a:	7f 93       	push	r23
    489c:	6f 93       	push	r22
    489e:	ff 93       	push	r31
    48a0:	ef 93       	push	r30
    48a2:	9b 01       	movw	r18, r22
    48a4:	ac 01       	movw	r20, r24
    48a6:	0e 94 c8 23 	call	0x4790	; 0x4790 <__mulsf3>
    48aa:	ef 91       	pop	r30
    48ac:	ff 91       	pop	r31
    48ae:	0e 94 5f 24 	call	0x48be	; 0x48be <__fp_powser>
    48b2:	2f 91       	pop	r18
    48b4:	3f 91       	pop	r19
    48b6:	4f 91       	pop	r20
    48b8:	5f 91       	pop	r21
    48ba:	0c 94 c8 23 	jmp	0x4790	; 0x4790 <__mulsf3>

000048be <__fp_powser>:
    48be:	df 93       	push	r29
    48c0:	cf 93       	push	r28
    48c2:	1f 93       	push	r17
    48c4:	0f 93       	push	r16
    48c6:	ff 92       	push	r15
    48c8:	ef 92       	push	r14
    48ca:	df 92       	push	r13
    48cc:	7b 01       	movw	r14, r22
    48ce:	8c 01       	movw	r16, r24
    48d0:	68 94       	set
    48d2:	06 c0       	rjmp	.+12     	; 0x48e0 <__fp_powser+0x22>
    48d4:	da 2e       	mov	r13, r26
    48d6:	ef 01       	movw	r28, r30
    48d8:	0e 94 db 23 	call	0x47b6	; 0x47b6 <__mulsf3x>
    48dc:	fe 01       	movw	r30, r28
    48de:	e8 94       	clt
    48e0:	a5 91       	lpm	r26, Z+
    48e2:	25 91       	lpm	r18, Z+
    48e4:	35 91       	lpm	r19, Z+
    48e6:	45 91       	lpm	r20, Z+
    48e8:	55 91       	lpm	r21, Z+
    48ea:	a6 f3       	brts	.-24     	; 0x48d4 <__fp_powser+0x16>
    48ec:	ef 01       	movw	r28, r30
    48ee:	0e 94 00 22 	call	0x4400	; 0x4400 <__addsf3x>
    48f2:	fe 01       	movw	r30, r28
    48f4:	97 01       	movw	r18, r14
    48f6:	a8 01       	movw	r20, r16
    48f8:	da 94       	dec	r13
    48fa:	69 f7       	brne	.-38     	; 0x48d6 <__fp_powser+0x18>
    48fc:	df 90       	pop	r13
    48fe:	ef 90       	pop	r14
    4900:	ff 90       	pop	r15
    4902:	0f 91       	pop	r16
    4904:	1f 91       	pop	r17
    4906:	cf 91       	pop	r28
    4908:	df 91       	pop	r29
    490a:	08 95       	ret

0000490c <__mulsi3>:
    490c:	db 01       	movw	r26, r22
    490e:	8f 93       	push	r24
    4910:	9f 93       	push	r25
    4912:	0e 94 ee 24 	call	0x49dc	; 0x49dc <__muluhisi3>
    4916:	bf 91       	pop	r27
    4918:	af 91       	pop	r26
    491a:	a2 9f       	mul	r26, r18
    491c:	80 0d       	add	r24, r0
    491e:	91 1d       	adc	r25, r1
    4920:	a3 9f       	mul	r26, r19
    4922:	90 0d       	add	r25, r0
    4924:	b2 9f       	mul	r27, r18
    4926:	90 0d       	add	r25, r0
    4928:	11 24       	eor	r1, r1
    492a:	08 95       	ret

0000492c <__udivmodsi4>:
    492c:	a1 e2       	ldi	r26, 0x21	; 33
    492e:	1a 2e       	mov	r1, r26
    4930:	aa 1b       	sub	r26, r26
    4932:	bb 1b       	sub	r27, r27
    4934:	fd 01       	movw	r30, r26
    4936:	0d c0       	rjmp	.+26     	; 0x4952 <__udivmodsi4_ep>

00004938 <__udivmodsi4_loop>:
    4938:	aa 1f       	adc	r26, r26
    493a:	bb 1f       	adc	r27, r27
    493c:	ee 1f       	adc	r30, r30
    493e:	ff 1f       	adc	r31, r31
    4940:	a2 17       	cp	r26, r18
    4942:	b3 07       	cpc	r27, r19
    4944:	e4 07       	cpc	r30, r20
    4946:	f5 07       	cpc	r31, r21
    4948:	20 f0       	brcs	.+8      	; 0x4952 <__udivmodsi4_ep>
    494a:	a2 1b       	sub	r26, r18
    494c:	b3 0b       	sbc	r27, r19
    494e:	e4 0b       	sbc	r30, r20
    4950:	f5 0b       	sbc	r31, r21

00004952 <__udivmodsi4_ep>:
    4952:	66 1f       	adc	r22, r22
    4954:	77 1f       	adc	r23, r23
    4956:	88 1f       	adc	r24, r24
    4958:	99 1f       	adc	r25, r25
    495a:	1a 94       	dec	r1
    495c:	69 f7       	brne	.-38     	; 0x4938 <__udivmodsi4_loop>
    495e:	60 95       	com	r22
    4960:	70 95       	com	r23
    4962:	80 95       	com	r24
    4964:	90 95       	com	r25
    4966:	9b 01       	movw	r18, r22
    4968:	ac 01       	movw	r20, r24
    496a:	bd 01       	movw	r22, r26
    496c:	cf 01       	movw	r24, r30
    496e:	08 95       	ret

00004970 <__divmodsi4>:
    4970:	05 2e       	mov	r0, r21
    4972:	97 fb       	bst	r25, 7
    4974:	1e f4       	brtc	.+6      	; 0x497c <__divmodsi4+0xc>
    4976:	00 94       	com	r0
    4978:	0e 94 cf 24 	call	0x499e	; 0x499e <__negsi2>
    497c:	57 fd       	sbrc	r21, 7
    497e:	07 d0       	rcall	.+14     	; 0x498e <__divmodsi4_neg2>
    4980:	0e 94 96 24 	call	0x492c	; 0x492c <__udivmodsi4>
    4984:	07 fc       	sbrc	r0, 7
    4986:	03 d0       	rcall	.+6      	; 0x498e <__divmodsi4_neg2>
    4988:	4e f4       	brtc	.+18     	; 0x499c <__divmodsi4_exit>
    498a:	0c 94 cf 24 	jmp	0x499e	; 0x499e <__negsi2>

0000498e <__divmodsi4_neg2>:
    498e:	50 95       	com	r21
    4990:	40 95       	com	r20
    4992:	30 95       	com	r19
    4994:	21 95       	neg	r18
    4996:	3f 4f       	sbci	r19, 0xFF	; 255
    4998:	4f 4f       	sbci	r20, 0xFF	; 255
    499a:	5f 4f       	sbci	r21, 0xFF	; 255

0000499c <__divmodsi4_exit>:
    499c:	08 95       	ret

0000499e <__negsi2>:
    499e:	90 95       	com	r25
    49a0:	80 95       	com	r24
    49a2:	70 95       	com	r23
    49a4:	61 95       	neg	r22
    49a6:	7f 4f       	sbci	r23, 0xFF	; 255
    49a8:	8f 4f       	sbci	r24, 0xFF	; 255
    49aa:	9f 4f       	sbci	r25, 0xFF	; 255
    49ac:	08 95       	ret

000049ae <__tablejump2__>:
    49ae:	ee 0f       	add	r30, r30
    49b0:	ff 1f       	adc	r31, r31
    49b2:	88 1f       	adc	r24, r24
    49b4:	8b bf       	out	0x3b, r24	; 59
    49b6:	07 90       	elpm	r0, Z+
    49b8:	f6 91       	elpm	r31, Z
    49ba:	e0 2d       	mov	r30, r0
    49bc:	19 94       	eijmp

000049be <__umulhisi3>:
    49be:	a2 9f       	mul	r26, r18
    49c0:	b0 01       	movw	r22, r0
    49c2:	b3 9f       	mul	r27, r19
    49c4:	c0 01       	movw	r24, r0
    49c6:	a3 9f       	mul	r26, r19
    49c8:	70 0d       	add	r23, r0
    49ca:	81 1d       	adc	r24, r1
    49cc:	11 24       	eor	r1, r1
    49ce:	91 1d       	adc	r25, r1
    49d0:	b2 9f       	mul	r27, r18
    49d2:	70 0d       	add	r23, r0
    49d4:	81 1d       	adc	r24, r1
    49d6:	11 24       	eor	r1, r1
    49d8:	91 1d       	adc	r25, r1
    49da:	08 95       	ret

000049dc <__muluhisi3>:
    49dc:	0e 94 df 24 	call	0x49be	; 0x49be <__umulhisi3>
    49e0:	a5 9f       	mul	r26, r21
    49e2:	90 0d       	add	r25, r0
    49e4:	b4 9f       	mul	r27, r20
    49e6:	90 0d       	add	r25, r0
    49e8:	a4 9f       	mul	r26, r20
    49ea:	80 0d       	add	r24, r0
    49ec:	91 1d       	adc	r25, r1
    49ee:	11 24       	eor	r1, r1
    49f0:	08 95       	ret

000049f2 <memcpy>:
    49f2:	fb 01       	movw	r30, r22
    49f4:	dc 01       	movw	r26, r24
    49f6:	02 c0       	rjmp	.+4      	; 0x49fc <memcpy+0xa>
    49f8:	01 90       	ld	r0, Z+
    49fa:	0d 92       	st	X+, r0
    49fc:	41 50       	subi	r20, 0x01	; 1
    49fe:	50 40       	sbci	r21, 0x00	; 0
    4a00:	d8 f7       	brcc	.-10     	; 0x49f8 <memcpy+0x6>
    4a02:	08 95       	ret

00004a04 <memset>:
    4a04:	dc 01       	movw	r26, r24
    4a06:	01 c0       	rjmp	.+2      	; 0x4a0a <memset+0x6>
    4a08:	6d 93       	st	X+, r22
    4a0a:	41 50       	subi	r20, 0x01	; 1
    4a0c:	50 40       	sbci	r21, 0x00	; 0
    4a0e:	e0 f7       	brcc	.-8      	; 0x4a08 <memset+0x4>
    4a10:	08 95       	ret

00004a12 <strncpy>:
    4a12:	fb 01       	movw	r30, r22
    4a14:	dc 01       	movw	r26, r24
    4a16:	41 50       	subi	r20, 0x01	; 1
    4a18:	50 40       	sbci	r21, 0x00	; 0
    4a1a:	48 f0       	brcs	.+18     	; 0x4a2e <strncpy+0x1c>
    4a1c:	01 90       	ld	r0, Z+
    4a1e:	0d 92       	st	X+, r0
    4a20:	00 20       	and	r0, r0
    4a22:	c9 f7       	brne	.-14     	; 0x4a16 <strncpy+0x4>
    4a24:	01 c0       	rjmp	.+2      	; 0x4a28 <strncpy+0x16>
    4a26:	1d 92       	st	X+, r1
    4a28:	41 50       	subi	r20, 0x01	; 1
    4a2a:	50 40       	sbci	r21, 0x00	; 0
    4a2c:	e0 f7       	brcc	.-8      	; 0x4a26 <strncpy+0x14>
    4a2e:	08 95       	ret

00004a30 <ultoa>:
    4a30:	25 32       	cpi	r18, 0x25	; 37
    4a32:	31 05       	cpc	r19, r1
    4a34:	20 f4       	brcc	.+8      	; 0x4a3e <ultoa+0xe>
    4a36:	22 30       	cpi	r18, 0x02	; 2
    4a38:	10 f0       	brcs	.+4      	; 0x4a3e <ultoa+0xe>
    4a3a:	0c 94 23 25 	jmp	0x4a46	; 0x4a46 <__ultoa_ncheck>
    4a3e:	fa 01       	movw	r30, r20
    4a40:	10 82       	st	Z, r1
    4a42:	ca 01       	movw	r24, r20
    4a44:	08 95       	ret

00004a46 <__ultoa_ncheck>:
    4a46:	bb 27       	eor	r27, r27

00004a48 <__ultoa_common>:
    4a48:	fa 01       	movw	r30, r20
    4a4a:	a6 2f       	mov	r26, r22
    4a4c:	62 17       	cp	r22, r18
    4a4e:	71 05       	cpc	r23, r1
    4a50:	81 05       	cpc	r24, r1
    4a52:	91 05       	cpc	r25, r1
    4a54:	33 0b       	sbc	r19, r19
    4a56:	30 fb       	bst	r19, 0
    4a58:	66 f0       	brts	.+24     	; 0x4a72 <__ultoa_common+0x2a>
    4a5a:	aa 27       	eor	r26, r26
    4a5c:	66 0f       	add	r22, r22
    4a5e:	77 1f       	adc	r23, r23
    4a60:	88 1f       	adc	r24, r24
    4a62:	99 1f       	adc	r25, r25
    4a64:	aa 1f       	adc	r26, r26
    4a66:	a2 17       	cp	r26, r18
    4a68:	10 f0       	brcs	.+4      	; 0x4a6e <__ultoa_common+0x26>
    4a6a:	a2 1b       	sub	r26, r18
    4a6c:	63 95       	inc	r22
    4a6e:	38 50       	subi	r19, 0x08	; 8
    4a70:	a9 f7       	brne	.-22     	; 0x4a5c <__ultoa_common+0x14>
    4a72:	a0 5d       	subi	r26, 0xD0	; 208
    4a74:	aa 33       	cpi	r26, 0x3A	; 58
    4a76:	08 f0       	brcs	.+2      	; 0x4a7a <__ultoa_common+0x32>
    4a78:	a9 5d       	subi	r26, 0xD9	; 217
    4a7a:	a1 93       	st	Z+, r26
    4a7c:	36 f7       	brtc	.-52     	; 0x4a4a <__ultoa_common+0x2>
    4a7e:	b1 11       	cpse	r27, r1
    4a80:	b1 93       	st	Z+, r27
    4a82:	10 82       	st	Z, r1
    4a84:	ca 01       	movw	r24, r20
    4a86:	0c 94 6a 25 	jmp	0x4ad4	; 0x4ad4 <strrev>

00004a8a <utoa>:
    4a8a:	45 32       	cpi	r20, 0x25	; 37
    4a8c:	51 05       	cpc	r21, r1
    4a8e:	20 f4       	brcc	.+8      	; 0x4a98 <utoa+0xe>
    4a90:	42 30       	cpi	r20, 0x02	; 2
    4a92:	10 f0       	brcs	.+4      	; 0x4a98 <utoa+0xe>
    4a94:	0c 94 50 25 	jmp	0x4aa0	; 0x4aa0 <__utoa_ncheck>
    4a98:	fb 01       	movw	r30, r22
    4a9a:	10 82       	st	Z, r1
    4a9c:	cb 01       	movw	r24, r22
    4a9e:	08 95       	ret

00004aa0 <__utoa_ncheck>:
    4aa0:	bb 27       	eor	r27, r27

00004aa2 <__utoa_common>:
    4aa2:	fb 01       	movw	r30, r22
    4aa4:	55 27       	eor	r21, r21
    4aa6:	aa 27       	eor	r26, r26
    4aa8:	88 0f       	add	r24, r24
    4aaa:	99 1f       	adc	r25, r25
    4aac:	aa 1f       	adc	r26, r26
    4aae:	a4 17       	cp	r26, r20
    4ab0:	10 f0       	brcs	.+4      	; 0x4ab6 <__utoa_common+0x14>
    4ab2:	a4 1b       	sub	r26, r20
    4ab4:	83 95       	inc	r24
    4ab6:	50 51       	subi	r21, 0x10	; 16
    4ab8:	b9 f7       	brne	.-18     	; 0x4aa8 <__utoa_common+0x6>
    4aba:	a0 5d       	subi	r26, 0xD0	; 208
    4abc:	aa 33       	cpi	r26, 0x3A	; 58
    4abe:	08 f0       	brcs	.+2      	; 0x4ac2 <__utoa_common+0x20>
    4ac0:	a9 5d       	subi	r26, 0xD9	; 217
    4ac2:	a1 93       	st	Z+, r26
    4ac4:	00 97       	sbiw	r24, 0x00	; 0
    4ac6:	79 f7       	brne	.-34     	; 0x4aa6 <__utoa_common+0x4>
    4ac8:	b1 11       	cpse	r27, r1
    4aca:	b1 93       	st	Z+, r27
    4acc:	11 92       	st	Z+, r1
    4ace:	cb 01       	movw	r24, r22
    4ad0:	0c 94 6a 25 	jmp	0x4ad4	; 0x4ad4 <strrev>

00004ad4 <strrev>:
    4ad4:	dc 01       	movw	r26, r24
    4ad6:	fc 01       	movw	r30, r24
    4ad8:	67 2f       	mov	r22, r23
    4ada:	71 91       	ld	r23, Z+
    4adc:	77 23       	and	r23, r23
    4ade:	e1 f7       	brne	.-8      	; 0x4ad8 <strrev+0x4>
    4ae0:	32 97       	sbiw	r30, 0x02	; 2
    4ae2:	04 c0       	rjmp	.+8      	; 0x4aec <strrev+0x18>
    4ae4:	7c 91       	ld	r23, X
    4ae6:	6d 93       	st	X+, r22
    4ae8:	70 83       	st	Z, r23
    4aea:	62 91       	ld	r22, -Z
    4aec:	ae 17       	cp	r26, r30
    4aee:	bf 07       	cpc	r27, r31
    4af0:	c8 f3       	brcs	.-14     	; 0x4ae4 <strrev+0x10>
    4af2:	08 95       	ret

00004af4 <_exit>:
    4af4:	f8 94       	cli

00004af6 <__stop_program>:
    4af6:	ff cf       	rjmp	.-2      	; 0x4af6 <__stop_program>
