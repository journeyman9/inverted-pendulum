
FREERTOS_SHELL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003ac0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e8  00802000  00003ac0  00003b54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000109c  008020e8  008020e8  00003c3c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003c3c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003c6c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000688  00000000  00000000  00003cac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000eca4  00000000  00000000  00004334  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005eae  00000000  00000000  00012fd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004d03  00000000  00000000  00018e86  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001238  00000000  00000000  0001db8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004b74  00000000  00000000  0001edc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000593e  00000000  00000000  00023938  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000538  00000000  00000000  00029276  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 a9 02 	jmp	0x552	; 0x552 <__ctors_end>
       4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
       c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      10:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      14:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      18:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      1c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      20:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      24:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      28:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      2c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      30:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      34:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      38:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      3c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      40:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      44:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      48:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      4c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      50:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      54:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      58:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      5c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      60:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      64:	0c 94 c8 19 	jmp	0x3390	; 0x3390 <__vector_25>
      68:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      6c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      70:	0c 94 26 1a 	jmp	0x344c	; 0x344c <__vector_28>
      74:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      78:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      7c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      80:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      84:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      88:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      8c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      90:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      94:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      98:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      9c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      c4:	0c 94 e2 09 	jmp	0x13c4	; 0x13c4 <__vector_49>
      c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      e8:	0c 94 40 1b 	jmp	0x3680	; 0x3680 <__vector_58>
      ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
      fc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     100:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     104:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     108:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     10c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     110:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     114:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     118:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     11c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     120:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     124:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     128:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     12c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     130:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     134:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     138:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     13c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     140:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     144:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     148:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     14c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     150:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     154:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     158:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     15c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     160:	0c 94 84 1a 	jmp	0x3508	; 0x3508 <__vector_88>
     164:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     168:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     16c:	0c 94 e2 1a 	jmp	0x35c4	; 0x35c4 <__vector_91>
     170:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     174:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     178:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     17c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     180:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     184:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     188:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     18c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     190:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     194:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     198:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     19c:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1a8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ac:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1b8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1bc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1c8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1cc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1d8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1dc:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1e8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1ec:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f0:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f4:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1f8:	0c 94 df 02 	jmp	0x5be	; 0x5be <__bad_interrupt>
     1fc:	b4 17       	cp	r27, r20
     1fe:	b7 17       	cp	r27, r23
     200:	ba 17       	cp	r27, r26
     202:	bd 17       	cp	r27, r29
     204:	c0 17       	cp	r28, r16
     206:	c3 17       	cp	r28, r19
     208:	c5 17       	cp	r28, r21
     20a:	d6 17       	cp	r29, r22
     20c:	de 17       	cp	r29, r30
     20e:	e8 17       	cp	r30, r24
     210:	e6 17       	cp	r30, r22

00000212 <__trampolines_start>:
     212:	0c 94 c0 17 	jmp	0x2f80	; 0x2f80 <_ZN8emstreamlsE15ser_manipulator+0x36>
     216:	0c 94 d7 03 	jmp	0x7ae	; 0x7ae <_ZN21task_pendulum_encoder3runEv>
     21a:	0c 94 29 04 	jmp	0x852	; 0x852 <_ZN22task_system_controller3runEv>
     21e:	0c 94 95 13 	jmp	0x272a	; 0x272a <_ZN8frt_task12print_statusER8emstream>
     222:	0c 94 59 17 	jmp	0x2eb2	; 0x2eb2 <_ZN8emstream7getcharEv>
     226:	0c 94 5e 17 	jmp	0x2ebc	; 0x2ebc <_ZN8emstream12transmit_nowEv>
     22a:	0c 94 2c 19 	jmp	0x3258	; 0x3258 <_ZN5rs23214check_for_charEv>
     22e:	0c 94 c0 16 	jmp	0x2d80	; 0x2d80 <__cxa_pure_virtual>
     232:	0c 94 57 17 	jmp	0x2eae	; 0x2eae <_ZN8emstream13ready_to_sendEv>
     236:	0c 94 d6 17 	jmp	0x2fac	; 0x2fac <_ZN8emstreamlsE15ser_manipulator+0x62>
     23a:	0c 94 e8 17 	jmp	0x2fd0	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
     23e:	0c 94 fd 14 	jmp	0x29fa	; 0x29fa <_ZN14frt_text_queue14check_for_charEv>
     242:	0c 94 5c 17 	jmp	0x2eb8	; 0x2eb8 <_ZN8emstream14check_for_charEv>
     246:	0c 94 ba 17 	jmp	0x2f74	; 0x2f74 <_ZN8emstreamlsE15ser_manipulator+0x2a>
     24a:	0c 94 de 17 	jmp	0x2fbc	; 0x2fbc <_ZN8emstreamlsE15ser_manipulator+0x72>
     24e:	0c 94 5f 17 	jmp	0x2ebe	; 0x2ebe <_ZN8emstream12clear_screenEv>
     252:	0c 94 b7 17 	jmp	0x2f6e	; 0x2f6e <_ZN8emstreamlsE15ser_manipulator+0x24>
     256:	0c 94 c3 17 	jmp	0x2f86	; 0x2f86 <_ZN8emstreamlsE15ser_manipulator+0x3c>
     25a:	0c 94 58 1c 	jmp	0x38b0	; 0x38b0 <_GLOBAL__sub_I_counter>
     25e:	0c 94 06 19 	jmp	0x320c	; 0x320c <_ZN5rs2327getcharEv>
     262:	0c 94 3f 19 	jmp	0x327e	; 0x327e <_ZN5rs23212clear_screenEv>
     266:	0c 94 a6 02 	jmp	0x54c	; 0x54c <_call_static_run_method>
     26a:	0c 94 08 15 	jmp	0x2a10	; 0x2a10 <_ZN14frt_text_queue7putcharEc>
     26e:	0c 94 66 0c 	jmp	0x18cc	; 0x18cc <prvIdleTask>
     272:	0c 94 e6 17 	jmp	0x2fcc	; 0x2fcc <_ZN8emstreamlsE15ser_manipulator+0x82>
     276:	0c 94 e1 02 	jmp	0x5c2	; 0x5c2 <_ZN17task_limit_switch3runEv>
     27a:	0c 94 33 03 	jmp	0x666	; 0x666 <_ZN18task_motor_command3runEv>
     27e:	0c 94 85 03 	jmp	0x70a	; 0x70a <_ZN18task_motor_encoder3runEv>
     282:	0c 94 be 05 	jmp	0xb7c	; 0xb7c <_ZN9task_user3runEv>
     286:	0c 94 bd 17 	jmp	0x2f7a	; 0x2f7a <_ZN8emstreamlsE15ser_manipulator+0x30>
     28a:	0c 94 e2 18 	jmp	0x31c4	; 0x31c4 <_ZN5rs2327putcharEc>
     28e:	0c 94 c5 17 	jmp	0x2f8a	; 0x2f8a <_ZN8emstreamlsE15ser_manipulator+0x40>
     292:	0c 94 df 14 	jmp	0x29be	; 0x29be <_ZN14frt_text_queue7getcharEv>
     296:	0c 94 b4 17 	jmp	0x2f68	; 0x2f68 <_ZN8emstreamlsE15ser_manipulator+0x1e>

0000029a <__trampolines_end>:
     29a:	2c 20       	and	r2, r12
     29c:	54 43       	sbci	r21, 0x34	; 52
     29e:	43 30       	cpi	r20, 0x03	; 3
     2a0:	43 43       	sbci	r20, 0x33	; 51
     2a2:	41 3d       	cpi	r20, 0xD1	; 209
	...

000002a5 <_ZZN9task_user11show_statusEvE3__c_3>:
     2a5:	2f 00                                               /.

000002a7 <_ZZN9task_user11show_statusEvE3__c_2>:
     2a7:	2c 20 48 65 61 70 20 66 72 65 65 3a 20 00           , Heap free: .

000002b5 <_ZZN9task_user11show_statusEvE3__c_1>:
     2b5:	54 69 6d 65 3a 20 00                                Time: .

000002bc <_ZZN9task_user11show_statusEvE3__c_0>:
     2bc:	46 65 62 20 32 32 20 32 30 32 35 00                 Feb 22 2025.

000002c8 <_ZZN9task_user11show_statusEvE3__c>:
     2c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     2d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000002e7 <_ZZN9task_user18print_help_messageEvE3__c_10>:
     2e7:	20 20 20 20 68 3a 20 20 20 48 41 4c 50 21 00            h:   HALP!.

000002f6 <_ZZN9task_user18print_help_messageEvE3__c_9>:
     2f6:	20 20 20 20 65 3a 20 20 20 45 78 69 74 20 63 6f         e:   Exit co
     306:	6d 6d 61 6e 64 20 6d 6f 64 65 00                    mmand mode.

00000311 <_ZZN9task_user18print_help_messageEvE3__c_8>:
     311:	20 20 20 20 73 3a 20 20 20 53 74 61 63 6b 20 64         s:   Stack d
     321:	75 6d 70 20 66 6f 72 20 74 61 73 6b 73 00           ump for tasks.

0000032f <_ZZN9task_user18print_help_messageEvE3__c_7>:
     32f:	20 20 20 20 76 3a 20 20 20 56 65 72 73 69 6f 6e         v:   Version
     33f:	20 61 6e 64 20 73 65 74 75 70 20 69 6e 66 6f 72      and setup infor
     34f:	6d 61 74 69 6f 6e 00                                mation.

00000356 <_ZZN9task_user18print_help_messageEvE3__c_6>:
     356:	20 20 20 20 6e 3a 20 20 20 53 68 6f 77 20 74 68         n:   Show th
     366:	65 20 74 69 6d 65 20 72 69 67 68 74 20 6e 6f 77     e time right now
	...

00000377 <_ZZN9task_user18print_help_messageEvE3__c_5>:
     377:	20 20 49 6e 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64       In command mod
     387:	65 20 6f 6e 6c 79 3a 00                             e only:.

0000038f <_ZZN9task_user18print_help_messageEvE3__c_4>:
     38f:	20 20 43 74 6c 2d 41 3a 20 45 6e 74 65 72 20 63       Ctl-A: Enter c
     39f:	6f 6d 6d 61 6e 64 20 6d 6f 64 65 00                 ommand mode.

000003ab <_ZZN9task_user18print_help_messageEvE3__c_3>:
     3ab:	20 20 43 74 6c 2d 43 3a 20 52 65 73 65 74 20 74       Ctl-C: Reset t
     3bb:	68 65 20 41 56 52 00                                he AVR.

000003c2 <_ZZN9task_user18print_help_messageEvE3__c_2>:
     3c2:	20 68 65 6c 70 00                                    help.

000003c8 <_ZZN9task_user18print_help_messageEvE3__c_1>:
     3c8:	4d 45 34 30 35 20 62 61 73 65 20 72 61 64 69 6f     ME405 base radio
     3d8:	20 70 72 6f 67 72 61 6d 20 56 30 2e 34 20 00         program V0.4 .

000003e7 <_ZZN9task_user18print_help_messageEvE3__c_0>:
     3e7:	1b 5b 33 30 6d 00                                   .[30m.

000003ed <_ZZN9task_user18print_help_messageEvE3__c>:
     3ed:	1b 5b 34 36 6d 00                                   .[46m.

000003f3 <_ZZN9task_user3runEvE3__c_3>:
     3f3:	49 6c 6c 65 67 61 6c 20 73 74 61 74 65 21 20 52     Illegal state! R
     403:	65 73 65 74 74 69 6e 67 20 41 56 52 00              esetting AVR.

00000410 <_ZZN9task_user3runEvE3__c_2>:
     410:	3a 57 54 46 3f 00                                   :WTF?.

00000416 <_ZZN9task_user3runEvE3__c_1>:
     416:	45 78 69 74 20 63 6f 6d 6d 61 6e 64 20 6d 6f 64     Exit command mod
     426:	65 00                                               e.

00000428 <_ZZN9task_user3runEvE3__c_0>:
     428:	52 65 73 65 74 74 69 6e 67 20 41 56 52 00           Resetting AVR.

00000436 <_ZZN9task_user3runEvE3__c>:
     436:	50 72 65 73 73 20 43 74 72 6c 2d 41 20 66 6f 72     Press Ctrl-A for
     446:	20 63 6f 6d 6d 61 6e 64 20 6d 6f 64 65 00            command mode.

00000454 <_ZZN8frt_task15emergency_resetEvE3__c_0>:
     454:	52 65 73 65 74 74 69 6e 67 00                       Resetting.

0000045e <_ZZN8frt_task15emergency_resetEvE3__c>:
     45e:	45 52 52 4f 52 20 69 6e 20 74 61 73 6b 20 00        ERROR in task .

0000046d <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_2>:
     46d:	45 52 52 4f 52 20 63 72 65 61 74 69 6e 67 20 74     ERROR creating t
     47d:	61 73 6b 20 00                                      ask .

00000482 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_1>:
     482:	2c 20 73 74 61 63 6b 20 61 74 20 30 78 00           , stack at 0x.

00000490 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c_0>:
     490:	20 63 72 65 61 74 65 64 00                           created.

00000499 <_ZZN8frt_taskC4EPKchjP8emstreamE3__c>:
     499:	54 61 73 6b 20 00                                   Task .

0000049f <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_1>:
     49f:	1b 5b 32 32 6d 00                                   .[22m.

000004a5 <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c_0>:
     4a5:	54 61 73 6b 3a 20 00                                Task: .

000004ac <_ZZN8frt_task19print_stack_in_listEP8emstreamE3__c>:
     4ac:	1b 5b 31 6d 00                                      .[1m.

000004b1 <_ZZ17print_task_stacksP8emstreamE3__c_1>:
     4b1:	1b 5b 32 32 6d 00                                   .[22m.

000004b7 <_ZZ17print_task_stacksP8emstreamE3__c_0>:
     4b7:	54 61 73 6b 3a 20 49 44 4c 45 00                    Task: IDLE.

000004c2 <_ZZ17print_task_stacksP8emstreamE3__c>:
     4c2:	1b 5b 31 6d 00                                      .[1m.

000004c7 <_ZZ15print_task_listP8emstreamE3__c_9>:
     4c7:	09 09 00                                            ...

000004ca <_ZZ15print_task_listP8emstreamE3__c_8>:
     4ca:	2f 00                                               /.

000004cc <_ZZ15print_task_listP8emstreamE3__c_7>:
     4cc:	49 44 4c 45 09 09 30 09 2d 09 00                    IDLE..0.-..

000004d7 <_ZZ15print_task_listP8emstreamE3__c_6>:
     4d7:	09 2d 2d 2d 2d 00                                   .----.

000004dd <_ZZ15print_task_listP8emstreamE3__c_5>:
     4dd:	09 2d 2d 2d 2d 2d 2d 2d 2d 2d 2d 00                 .----------.

000004e9 <_ZZ15print_task_listP8emstreamE3__c_4>:
     4e9:	2d 2d 2d 2d 09 09 2d 2d 2d 2d 09 2d 2d 2d 2d 2d     ----..----.-----
	...

000004fa <_ZZ15print_task_listP8emstreamE3__c_3>:
     4fa:	09 52 75 6e 73 00                                   .Runs.

00000500 <_ZZ15print_task_listP8emstreamE3__c_2>:
     500:	09 46 72 65 65 2f 54 6f 74 61 6c 00                 .Free/Total.

0000050c <_ZZ15print_task_listP8emstreamE3__c_1>:
     50c:	4e 61 6d 65 09 09 50 72 69 2e 09 53 74 61 74 65     Name..Pri..State
	...

0000051d <_ZZ15print_task_listP8emstreamE3__c_0>:
     51d:	09 53 74 61 63 6b 00                                .Stack.

00000524 <_ZZ15print_task_listP8emstreamE3__c>:
     524:	54 61 73 6b 09 09 20 20 09 20 00                    Task..  . .

0000052f <_ZZN8frt_task12print_statusER8emstreamE3__c_3>:
     52f:	09 00                                               ..

00000531 <_ZZN8frt_task12print_statusER8emstreamE3__c_2>:
     531:	09 00                                               ..

00000533 <_ZZN8frt_task12print_statusER8emstreamE3__c_1>:
     533:	2f 00                                               /.

00000535 <_ZZN8frt_task12print_statusER8emstreamE3__c_0>:
     535:	09 00                                               ..

00000537 <_ZZN8frt_task12print_statusER8emstreamE3__c>:
     537:	09 00                                               ..

00000539 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_2>:
     539:	1b 5b 32 32 6d 00                                   .[22m.

0000053f <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_1>:
     53f:	1b 5b 31 6d 00                                      .[1m.

00000544 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c_0>:
     544:	1b 5b 31 6d 00                                      .[1m.

00000549 <_ZZ15hex_dump_memoryPhS_P8emstreambhE3__c>:
     549:	20 20 00                                              .

0000054c <_call_static_run_method>:
 *                the pointer is used to find the task's static run method
 */

extern "C" inline void _call_static_run_method (frt_task* p_task)
{
	frt_task::_call_users_run_method (p_task);
     54c:	0e 94 2d 12 	call	0x245a	; 0x245a <_ZN8frt_task22_call_users_run_methodEPS_>

00000550 <__ctors_start>:
     550:	58 1c       	adc	r5, r8

00000552 <__ctors_end>:
     552:	11 24       	eor	r1, r1
     554:	1f be       	out	0x3f, r1	; 63
     556:	cf ef       	ldi	r28, 0xFF	; 255
     558:	cd bf       	out	0x3d, r28	; 61
     55a:	df e3       	ldi	r29, 0x3F	; 63
     55c:	de bf       	out	0x3e, r29	; 62
     55e:	00 e0       	ldi	r16, 0x00	; 0
     560:	0c bf       	out	0x3c, r16	; 60
     562:	18 be       	out	0x38, r1	; 56
     564:	19 be       	out	0x39, r1	; 57
     566:	1a be       	out	0x3a, r1	; 58
     568:	1b be       	out	0x3b, r1	; 59

0000056a <__do_copy_data>:
     56a:	10 e2       	ldi	r17, 0x20	; 32
     56c:	a0 e0       	ldi	r26, 0x00	; 0
     56e:	b0 e2       	ldi	r27, 0x20	; 32
     570:	e0 ec       	ldi	r30, 0xC0	; 192
     572:	fa e3       	ldi	r31, 0x3A	; 58
     574:	00 e0       	ldi	r16, 0x00	; 0
     576:	0b bf       	out	0x3b, r16	; 59
     578:	02 c0       	rjmp	.+4      	; 0x57e <__do_copy_data+0x14>
     57a:	07 90       	elpm	r0, Z+
     57c:	0d 92       	st	X+, r0
     57e:	a8 3e       	cpi	r26, 0xE8	; 232
     580:	b1 07       	cpc	r27, r17
     582:	d9 f7       	brne	.-10     	; 0x57a <__do_copy_data+0x10>
     584:	1b be       	out	0x3b, r1	; 59

00000586 <__do_clear_bss>:
     586:	21 e3       	ldi	r18, 0x31	; 49
     588:	a8 ee       	ldi	r26, 0xE8	; 232
     58a:	b0 e2       	ldi	r27, 0x20	; 32
     58c:	01 c0       	rjmp	.+2      	; 0x590 <.do_clear_bss_start>

0000058e <.do_clear_bss_loop>:
     58e:	1d 92       	st	X+, r1

00000590 <.do_clear_bss_start>:
     590:	a4 38       	cpi	r26, 0x84	; 132
     592:	b2 07       	cpc	r27, r18
     594:	e1 f7       	brne	.-8      	; 0x58e <.do_clear_bss_loop>

00000596 <__do_global_ctors>:
     596:	12 e0       	ldi	r17, 0x02	; 2
     598:	c9 ea       	ldi	r28, 0xA9	; 169
     59a:	d2 e0       	ldi	r29, 0x02	; 2
     59c:	00 e0       	ldi	r16, 0x00	; 0
     59e:	06 c0       	rjmp	.+12     	; 0x5ac <__do_global_ctors+0x16>
     5a0:	21 97       	sbiw	r28, 0x01	; 1
     5a2:	01 09       	sbc	r16, r1
     5a4:	80 2f       	mov	r24, r16
     5a6:	fe 01       	movw	r30, r28
     5a8:	0e 94 ba 1c 	call	0x3974	; 0x3974 <__tablejump2__>
     5ac:	c8 3a       	cpi	r28, 0xA8	; 168
     5ae:	d1 07       	cpc	r29, r17
     5b0:	80 e0       	ldi	r24, 0x00	; 0
     5b2:	08 07       	cpc	r16, r24
     5b4:	a9 f7       	brne	.-22     	; 0x5a0 <__do_global_ctors+0xa>
     5b6:	0e 94 b3 1b 	call	0x3766	; 0x3766 <main>
     5ba:	0c 94 5e 1d 	jmp	0x3abc	; 0x3abc <_exit>

000005be <__bad_interrupt>:
     5be:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000005c2 <_ZN17task_limit_switch3runEv>:
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
	// Nothing to do in this constructor other than call the parent constructor
}


void task_limit_switch::run(void) {
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
     5c6:	00 d0       	rcall	.+0      	; 0x5c8 <_ZN17task_limit_switch3runEv+0x6>
     5c8:	1f 92       	push	r1
     5ca:	cd b7       	in	r28, 0x3d	; 61
     5cc:	de b7       	in	r29, 0x3e	; 62
     5ce:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     5d0:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <xTaskGetTickCount>
     5d4:	69 83       	std	Y+1, r22	; 0x01
     5d6:	7a 83       	std	Y+2, r23	; 0x02
     5d8:	8b 83       	std	Y+3, r24	; 0x03
     5da:	9c 83       	std	Y+4, r25	; 0x04
	
	while(1) {
		
		if (runs % 100 == 0) {
     5dc:	0f 2e       	mov	r0, r31
     5de:	f4 e6       	ldi	r31, 0x64	; 100
     5e0:	cf 2e       	mov	r12, r31
     5e2:	d1 2c       	mov	r13, r1
     5e4:	e1 2c       	mov	r14, r1
     5e6:	f1 2c       	mov	r15, r1
     5e8:	f0 2d       	mov	r31, r0
     5ea:	f8 01       	movw	r30, r16
     5ec:	66 85       	ldd	r22, Z+14	; 0x0e
     5ee:	77 85       	ldd	r23, Z+15	; 0x0f
     5f0:	80 89       	ldd	r24, Z+16	; 0x10
     5f2:	91 89       	ldd	r25, Z+17	; 0x11
     5f4:	a7 01       	movw	r20, r14
     5f6:	96 01       	movw	r18, r12
     5f8:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
     5fc:	67 2b       	or	r22, r23
     5fe:	68 2b       	or	r22, r24
     600:	69 2b       	or	r22, r25
     602:	61 f4       	brne	.+24     	; 0x61c <_ZN17task_limit_switch3runEv+0x5a>
			*p_serial << "Scary, scary skeletons!" << endl;
     604:	f8 01       	movw	r30, r16
     606:	a6 80       	ldd	r10, Z+6	; 0x06
     608:	b7 80       	ldd	r11, Z+7	; 0x07
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
     60a:	66 e0       	ldi	r22, 0x06	; 6
     60c:	70 e2       	ldi	r23, 0x20	; 32
     60e:	c5 01       	movw	r24, r10
     610:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     614:	66 e0       	ldi	r22, 0x06	; 6
     616:	c5 01       	movw	r24, r10
     618:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		}

		
		// Increment counter for debugging
		runs++;
     61c:	f8 01       	movw	r30, r16
     61e:	86 85       	ldd	r24, Z+14	; 0x0e
     620:	97 85       	ldd	r25, Z+15	; 0x0f
     622:	a0 89       	ldd	r26, Z+16	; 0x10
     624:	b1 89       	ldd	r27, Z+17	; 0x11
     626:	01 96       	adiw	r24, 0x01	; 1
     628:	a1 1d       	adc	r26, r1
     62a:	b1 1d       	adc	r27, r1
     62c:	86 87       	std	Z+14, r24	; 0x0e
     62e:	97 87       	std	Z+15, r25	; 0x0f
     630:	a0 8b       	std	Z+16, r26	; 0x10
     632:	b1 8b       	std	Z+17, r27	; 0x11
		 *                    delay so as to get precise, regular timing
		 *  @param interval The duration of the delay interval in RTOS ticks
		 */
		void delay_from_to (portTickType& from_ticks, portTickType interval)
		{
			vTaskDelayUntil (&from_ticks, interval);
     634:	41 e0       	ldi	r20, 0x01	; 1
     636:	50 e0       	ldi	r21, 0x00	; 0
     638:	60 e0       	ldi	r22, 0x00	; 0
     63a:	70 e0       	ldi	r23, 0x00	; 0
     63c:	ce 01       	movw	r24, r28
     63e:	01 96       	adiw	r24, 0x01	; 1
     640:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskDelayUntil>
     644:	d2 cf       	rjmp	.-92     	; 0x5ea <_ZN17task_limit_switch3runEv+0x28>

00000646 <_ZN17task_limit_switchC1EPKchjP8emstream>:
#include "shared_data_sender.h"
#include "shared_data_receiver.h"

#include "task_limit_switch.h"                  // Template

task_limit_switch::task_limit_switch (
     646:	0f 93       	push	r16
     648:	1f 93       	push	r17
     64a:	cf 93       	push	r28
     64c:	df 93       	push	r29
     64e:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE a_priority,
	size_t a_stack_size,
	emstream* p_ser_dev
)
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
     650:	0e 94 40 12 	call	0x2480	; 0x2480 <_ZN8frt_taskC1EPKchjP8emstream>
     654:	82 e2       	ldi	r24, 0x22	; 34
     656:	90 e2       	ldi	r25, 0x20	; 32
     658:	88 83       	st	Y, r24
     65a:	99 83       	std	Y+1, r25	; 0x01
	// Nothing to do in this constructor other than call the parent constructor
}
     65c:	df 91       	pop	r29
     65e:	cf 91       	pop	r28
     660:	1f 91       	pop	r17
     662:	0f 91       	pop	r16
     664:	08 95       	ret

00000666 <_ZN18task_motor_command3runEv>:
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
	// Nothing to do in this constructor other than call the parent constructor
}


void task_motor_command::run(void) {
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	00 d0       	rcall	.+0      	; 0x66c <_ZN18task_motor_command3runEv+0x6>
     66c:	1f 92       	push	r1
     66e:	cd b7       	in	r28, 0x3d	; 61
     670:	de b7       	in	r29, 0x3e	; 62
     672:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     674:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <xTaskGetTickCount>
     678:	69 83       	std	Y+1, r22	; 0x01
     67a:	7a 83       	std	Y+2, r23	; 0x02
     67c:	8b 83       	std	Y+3, r24	; 0x03
     67e:	9c 83       	std	Y+4, r25	; 0x04
	
		
	while(1) {
		
		if (runs % 100 == 0) {
     680:	0f 2e       	mov	r0, r31
     682:	f4 e6       	ldi	r31, 0x64	; 100
     684:	cf 2e       	mov	r12, r31
     686:	d1 2c       	mov	r13, r1
     688:	e1 2c       	mov	r14, r1
     68a:	f1 2c       	mov	r15, r1
     68c:	f0 2d       	mov	r31, r0
     68e:	f8 01       	movw	r30, r16
     690:	66 85       	ldd	r22, Z+14	; 0x0e
     692:	77 85       	ldd	r23, Z+15	; 0x0f
     694:	80 89       	ldd	r24, Z+16	; 0x10
     696:	91 89       	ldd	r25, Z+17	; 0x11
     698:	a7 01       	movw	r20, r14
     69a:	96 01       	movw	r18, r12
     69c:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
     6a0:	67 2b       	or	r22, r23
     6a2:	68 2b       	or	r22, r24
     6a4:	69 2b       	or	r22, r25
     6a6:	61 f4       	brne	.+24     	; 0x6c0 <_ZN18task_motor_command3runEv+0x5a>
			*p_serial << "Scary, scary skeletons!" << endl;
     6a8:	f8 01       	movw	r30, r16
     6aa:	a6 80       	ldd	r10, Z+6	; 0x06
     6ac:	b7 80       	ldd	r11, Z+7	; 0x07
     6ae:	66 e0       	ldi	r22, 0x06	; 6
     6b0:	70 e2       	ldi	r23, 0x20	; 32
     6b2:	c5 01       	movw	r24, r10
     6b4:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     6b8:	66 e0       	ldi	r22, 0x06	; 6
     6ba:	c5 01       	movw	r24, r10
     6bc:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		}

		
		// Increment counter for debugging
		runs++;
     6c0:	f8 01       	movw	r30, r16
     6c2:	86 85       	ldd	r24, Z+14	; 0x0e
     6c4:	97 85       	ldd	r25, Z+15	; 0x0f
     6c6:	a0 89       	ldd	r26, Z+16	; 0x10
     6c8:	b1 89       	ldd	r27, Z+17	; 0x11
     6ca:	01 96       	adiw	r24, 0x01	; 1
     6cc:	a1 1d       	adc	r26, r1
     6ce:	b1 1d       	adc	r27, r1
     6d0:	86 87       	std	Z+14, r24	; 0x0e
     6d2:	97 87       	std	Z+15, r25	; 0x0f
     6d4:	a0 8b       	std	Z+16, r26	; 0x10
     6d6:	b1 8b       	std	Z+17, r27	; 0x11
     6d8:	41 e0       	ldi	r20, 0x01	; 1
     6da:	50 e0       	ldi	r21, 0x00	; 0
     6dc:	60 e0       	ldi	r22, 0x00	; 0
     6de:	70 e0       	ldi	r23, 0x00	; 0
     6e0:	ce 01       	movw	r24, r28
     6e2:	01 96       	adiw	r24, 0x01	; 1
     6e4:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskDelayUntil>
     6e8:	d2 cf       	rjmp	.-92     	; 0x68e <_ZN18task_motor_command3runEv+0x28>

000006ea <_ZN18task_motor_commandC1EPKchjP8emstream>:
#include "shared_data_sender.h"
#include "shared_data_receiver.h"

#include "task_motor_command.h"                  // Template

task_motor_command::task_motor_command(
     6ea:	0f 93       	push	r16
     6ec:	1f 93       	push	r17
     6ee:	cf 93       	push	r28
     6f0:	df 93       	push	r29
     6f2:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE a_priority,
	size_t a_stack_size,
	emstream* p_ser_dev
)
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
     6f4:	0e 94 40 12 	call	0x2480	; 0x2480 <_ZN8frt_taskC1EPKchjP8emstream>
     6f8:	8a e2       	ldi	r24, 0x2A	; 42
     6fa:	90 e2       	ldi	r25, 0x20	; 32
     6fc:	88 83       	st	Y, r24
     6fe:	99 83       	std	Y+1, r25	; 0x01
	// Nothing to do in this constructor other than call the parent constructor
}
     700:	df 91       	pop	r29
     702:	cf 91       	pop	r28
     704:	1f 91       	pop	r17
     706:	0f 91       	pop	r16
     708:	08 95       	ret

0000070a <_ZN18task_motor_encoder3runEv>:
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
		// Nothing to do in this constructor other than call the parent constructor
}

void task_motor_encoder::run(void) {
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	00 d0       	rcall	.+0      	; 0x710 <_ZN18task_motor_encoder3runEv+0x6>
     710:	1f 92       	push	r1
     712:	cd b7       	in	r28, 0x3d	; 61
     714:	de b7       	in	r29, 0x3e	; 62
     716:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     718:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <xTaskGetTickCount>
     71c:	69 83       	std	Y+1, r22	; 0x01
     71e:	7a 83       	std	Y+2, r23	; 0x02
     720:	8b 83       	std	Y+3, r24	; 0x03
     722:	9c 83       	std	Y+4, r25	; 0x04
		
	while(1) {
		
		
		
		if (runs % 100 == 0) {
     724:	0f 2e       	mov	r0, r31
     726:	f4 e6       	ldi	r31, 0x64	; 100
     728:	cf 2e       	mov	r12, r31
     72a:	d1 2c       	mov	r13, r1
     72c:	e1 2c       	mov	r14, r1
     72e:	f1 2c       	mov	r15, r1
     730:	f0 2d       	mov	r31, r0
     732:	f8 01       	movw	r30, r16
     734:	66 85       	ldd	r22, Z+14	; 0x0e
     736:	77 85       	ldd	r23, Z+15	; 0x0f
     738:	80 89       	ldd	r24, Z+16	; 0x10
     73a:	91 89       	ldd	r25, Z+17	; 0x11
     73c:	a7 01       	movw	r20, r14
     73e:	96 01       	movw	r18, r12
     740:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
     744:	67 2b       	or	r22, r23
     746:	68 2b       	or	r22, r24
     748:	69 2b       	or	r22, r25
     74a:	61 f4       	brne	.+24     	; 0x764 <_ZN18task_motor_encoder3runEv+0x5a>
			*p_serial << "Scary, scary skeletons!" << endl;
     74c:	f8 01       	movw	r30, r16
     74e:	a6 80       	ldd	r10, Z+6	; 0x06
     750:	b7 80       	ldd	r11, Z+7	; 0x07
     752:	66 e0       	ldi	r22, 0x06	; 6
     754:	70 e2       	ldi	r23, 0x20	; 32
     756:	c5 01       	movw	r24, r10
     758:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     75c:	66 e0       	ldi	r22, 0x06	; 6
     75e:	c5 01       	movw	r24, r10
     760:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		}

		
		// Increment counter for debugging
		runs++;
     764:	f8 01       	movw	r30, r16
     766:	86 85       	ldd	r24, Z+14	; 0x0e
     768:	97 85       	ldd	r25, Z+15	; 0x0f
     76a:	a0 89       	ldd	r26, Z+16	; 0x10
     76c:	b1 89       	ldd	r27, Z+17	; 0x11
     76e:	01 96       	adiw	r24, 0x01	; 1
     770:	a1 1d       	adc	r26, r1
     772:	b1 1d       	adc	r27, r1
     774:	86 87       	std	Z+14, r24	; 0x0e
     776:	97 87       	std	Z+15, r25	; 0x0f
     778:	a0 8b       	std	Z+16, r26	; 0x10
     77a:	b1 8b       	std	Z+17, r27	; 0x11
     77c:	41 e0       	ldi	r20, 0x01	; 1
     77e:	50 e0       	ldi	r21, 0x00	; 0
     780:	60 e0       	ldi	r22, 0x00	; 0
     782:	70 e0       	ldi	r23, 0x00	; 0
     784:	ce 01       	movw	r24, r28
     786:	01 96       	adiw	r24, 0x01	; 1
     788:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskDelayUntil>
     78c:	d2 cf       	rjmp	.-92     	; 0x732 <_ZN18task_motor_encoder3runEv+0x28>

0000078e <_ZN18task_motor_encoderC1EPKchjP8emstream>:
#include "shared_data_sender.h"
#include "shared_data_receiver.h"

#include "task_motor_encoder.h"                  // Template

task_motor_encoder::task_motor_encoder(
     78e:	0f 93       	push	r16
     790:	1f 93       	push	r17
     792:	cf 93       	push	r28
     794:	df 93       	push	r29
     796:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE a_priority,
	size_t a_stack_size,
	emstream* p_ser_dev
)
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
     798:	0e 94 40 12 	call	0x2480	; 0x2480 <_ZN8frt_taskC1EPKchjP8emstream>
     79c:	82 e3       	ldi	r24, 0x32	; 50
     79e:	90 e2       	ldi	r25, 0x20	; 32
     7a0:	88 83       	st	Y, r24
     7a2:	99 83       	std	Y+1, r25	; 0x01
		// Nothing to do in this constructor other than call the parent constructor
}
     7a4:	df 91       	pop	r29
     7a6:	cf 91       	pop	r28
     7a8:	1f 91       	pop	r17
     7aa:	0f 91       	pop	r16
     7ac:	08 95       	ret

000007ae <_ZN21task_pendulum_encoder3runEv>:
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
	// Nothing to do in this constructor other than call the parent constructor
}

void task_pendulum_encoder::run(void) {
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	00 d0       	rcall	.+0      	; 0x7b4 <_ZN21task_pendulum_encoder3runEv+0x6>
     7b4:	1f 92       	push	r1
     7b6:	cd b7       	in	r28, 0x3d	; 61
     7b8:	de b7       	in	r29, 0x3e	; 62
     7ba:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     7bc:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <xTaskGetTickCount>
     7c0:	69 83       	std	Y+1, r22	; 0x01
     7c2:	7a 83       	std	Y+2, r23	; 0x02
     7c4:	8b 83       	std	Y+3, r24	; 0x03
     7c6:	9c 83       	std	Y+4, r25	; 0x04
	
	while(1) {
		
		if (runs % 100 == 0) {
     7c8:	0f 2e       	mov	r0, r31
     7ca:	f4 e6       	ldi	r31, 0x64	; 100
     7cc:	cf 2e       	mov	r12, r31
     7ce:	d1 2c       	mov	r13, r1
     7d0:	e1 2c       	mov	r14, r1
     7d2:	f1 2c       	mov	r15, r1
     7d4:	f0 2d       	mov	r31, r0
     7d6:	f8 01       	movw	r30, r16
     7d8:	66 85       	ldd	r22, Z+14	; 0x0e
     7da:	77 85       	ldd	r23, Z+15	; 0x0f
     7dc:	80 89       	ldd	r24, Z+16	; 0x10
     7de:	91 89       	ldd	r25, Z+17	; 0x11
     7e0:	a7 01       	movw	r20, r14
     7e2:	96 01       	movw	r18, r12
     7e4:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
     7e8:	67 2b       	or	r22, r23
     7ea:	68 2b       	or	r22, r24
     7ec:	69 2b       	or	r22, r25
     7ee:	61 f4       	brne	.+24     	; 0x808 <_ZN21task_pendulum_encoder3runEv+0x5a>
			*p_serial << "Scary, scary skeletons!" << endl;
     7f0:	f8 01       	movw	r30, r16
     7f2:	a6 80       	ldd	r10, Z+6	; 0x06
     7f4:	b7 80       	ldd	r11, Z+7	; 0x07
     7f6:	66 e0       	ldi	r22, 0x06	; 6
     7f8:	70 e2       	ldi	r23, 0x20	; 32
     7fa:	c5 01       	movw	r24, r10
     7fc:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     800:	66 e0       	ldi	r22, 0x06	; 6
     802:	c5 01       	movw	r24, r10
     804:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		}
				
		// Increment counter for debugging
		runs++;
     808:	f8 01       	movw	r30, r16
     80a:	86 85       	ldd	r24, Z+14	; 0x0e
     80c:	97 85       	ldd	r25, Z+15	; 0x0f
     80e:	a0 89       	ldd	r26, Z+16	; 0x10
     810:	b1 89       	ldd	r27, Z+17	; 0x11
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	a1 1d       	adc	r26, r1
     816:	b1 1d       	adc	r27, r1
     818:	86 87       	std	Z+14, r24	; 0x0e
     81a:	97 87       	std	Z+15, r25	; 0x0f
     81c:	a0 8b       	std	Z+16, r26	; 0x10
     81e:	b1 8b       	std	Z+17, r27	; 0x11
     820:	41 e0       	ldi	r20, 0x01	; 1
     822:	50 e0       	ldi	r21, 0x00	; 0
     824:	60 e0       	ldi	r22, 0x00	; 0
     826:	70 e0       	ldi	r23, 0x00	; 0
     828:	ce 01       	movw	r24, r28
     82a:	01 96       	adiw	r24, 0x01	; 1
     82c:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskDelayUntil>
     830:	d2 cf       	rjmp	.-92     	; 0x7d6 <_ZN21task_pendulum_encoder3runEv+0x28>

00000832 <_ZN21task_pendulum_encoderC1EPKchjP8emstream>:
#include "shared_data_sender.h"
#include "shared_data_receiver.h"

#include "task_pendulum_encoder.h"

task_pendulum_encoder::task_pendulum_encoder(
     832:	0f 93       	push	r16
     834:	1f 93       	push	r17
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE a_priority,
	size_t a_stack_size,
	emstream* p_ser_dev
)
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
     83c:	0e 94 40 12 	call	0x2480	; 0x2480 <_ZN8frt_taskC1EPKchjP8emstream>
     840:	8a e3       	ldi	r24, 0x3A	; 58
     842:	90 e2       	ldi	r25, 0x20	; 32
     844:	88 83       	st	Y, r24
     846:	99 83       	std	Y+1, r25	; 0x01
	// Nothing to do in this constructor other than call the parent constructor
}
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	08 95       	ret

00000852 <_ZN22task_system_controller3runEv>:
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
	// Nothing to do in this constructor other than call the parent constructor
}


void task_system_controller::run(void) {
     852:	cf 93       	push	r28
     854:	df 93       	push	r29
     856:	00 d0       	rcall	.+0      	; 0x858 <_ZN22task_system_controller3runEv+0x6>
     858:	1f 92       	push	r1
     85a:	cd b7       	in	r28, 0x3d	; 61
     85c:	de b7       	in	r29, 0x3e	; 62
     85e:	8c 01       	movw	r16, r24
	// Make a variable which will hold times to use for precise task scheduling
	portTickType previousTicks = xTaskGetTickCount ();
     860:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <xTaskGetTickCount>
     864:	69 83       	std	Y+1, r22	; 0x01
     866:	7a 83       	std	Y+2, r23	; 0x02
     868:	8b 83       	std	Y+3, r24	; 0x03
     86a:	9c 83       	std	Y+4, r25	; 0x04
	
		
	while(1) {
		
		if (runs % 100 == 0) {
     86c:	0f 2e       	mov	r0, r31
     86e:	f4 e6       	ldi	r31, 0x64	; 100
     870:	cf 2e       	mov	r12, r31
     872:	d1 2c       	mov	r13, r1
     874:	e1 2c       	mov	r14, r1
     876:	f1 2c       	mov	r15, r1
     878:	f0 2d       	mov	r31, r0
     87a:	f8 01       	movw	r30, r16
     87c:	66 85       	ldd	r22, Z+14	; 0x0e
     87e:	77 85       	ldd	r23, Z+15	; 0x0f
     880:	80 89       	ldd	r24, Z+16	; 0x10
     882:	91 89       	ldd	r25, Z+17	; 0x11
     884:	a7 01       	movw	r20, r14
     886:	96 01       	movw	r18, r12
     888:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
     88c:	67 2b       	or	r22, r23
     88e:	68 2b       	or	r22, r24
     890:	69 2b       	or	r22, r25
     892:	61 f4       	brne	.+24     	; 0x8ac <_ZN22task_system_controller3runEv+0x5a>
			*p_serial << "Scary, scary skeletons!" << endl;
     894:	f8 01       	movw	r30, r16
     896:	a6 80       	ldd	r10, Z+6	; 0x06
     898:	b7 80       	ldd	r11, Z+7	; 0x07
     89a:	66 e0       	ldi	r22, 0x06	; 6
     89c:	70 e2       	ldi	r23, 0x20	; 32
     89e:	c5 01       	movw	r24, r10
     8a0:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     8a4:	66 e0       	ldi	r22, 0x06	; 6
     8a6:	c5 01       	movw	r24, r10
     8a8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		}

		
		// Increment counter for debugging
		runs++;
     8ac:	f8 01       	movw	r30, r16
     8ae:	86 85       	ldd	r24, Z+14	; 0x0e
     8b0:	97 85       	ldd	r25, Z+15	; 0x0f
     8b2:	a0 89       	ldd	r26, Z+16	; 0x10
     8b4:	b1 89       	ldd	r27, Z+17	; 0x11
     8b6:	01 96       	adiw	r24, 0x01	; 1
     8b8:	a1 1d       	adc	r26, r1
     8ba:	b1 1d       	adc	r27, r1
     8bc:	86 87       	std	Z+14, r24	; 0x0e
     8be:	97 87       	std	Z+15, r25	; 0x0f
     8c0:	a0 8b       	std	Z+16, r26	; 0x10
     8c2:	b1 8b       	std	Z+17, r27	; 0x11
     8c4:	41 e0       	ldi	r20, 0x01	; 1
     8c6:	50 e0       	ldi	r21, 0x00	; 0
     8c8:	60 e0       	ldi	r22, 0x00	; 0
     8ca:	70 e0       	ldi	r23, 0x00	; 0
     8cc:	ce 01       	movw	r24, r28
     8ce:	01 96       	adiw	r24, 0x01	; 1
     8d0:	0e 94 a3 0f 	call	0x1f46	; 0x1f46 <vTaskDelayUntil>
     8d4:	d2 cf       	rjmp	.-92     	; 0x87a <_ZN22task_system_controller3runEv+0x28>

000008d6 <_ZN22task_system_controllerC1EPKchjP8emstream>:
#include "shared_data_sender.h"
#include "shared_data_receiver.h"

#include "task_system_controller.h"                  // Template

task_system_controller::task_system_controller(
     8d6:	0f 93       	push	r16
     8d8:	1f 93       	push	r17
     8da:	cf 93       	push	r28
     8dc:	df 93       	push	r29
     8de:	ec 01       	movw	r28, r24
	unsigned portBASE_TYPE a_priority,
	size_t a_stack_size,
	emstream* p_ser_dev
)
// Call the parent (task base) constructor
: frt_task (a_name, a_priority, a_stack_size, p_ser_dev) {
     8e0:	0e 94 40 12 	call	0x2480	; 0x2480 <_ZN8frt_taskC1EPKchjP8emstream>
     8e4:	82 e4       	ldi	r24, 0x42	; 66
     8e6:	90 e2       	ldi	r25, 0x20	; 32
     8e8:	88 83       	st	Y, r24
     8ea:	99 83       	std	Y+1, r25	; 0x01
	// Nothing to do in this constructor other than call the parent constructor
}
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	08 95       	ret

000008f6 <_ZN9task_userC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

task_user::task_user (const char* a_name, 
     8f6:	0f 93       	push	r16
     8f8:	1f 93       	push	r17
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	ec 01       	movw	r28, r24
					  unsigned portBASE_TYPE a_priority, 
					  size_t a_stack_size,
					  emstream* p_ser_dev
					 )
	: frt_task (a_name, a_priority, a_stack_size, p_ser_dev)
     900:	0e 94 40 12 	call	0x2480	; 0x2480 <_ZN8frt_taskC1EPKchjP8emstream>
     904:	8a e4       	ldi	r24, 0x4A	; 74
     906:	90 e2       	ldi	r25, 0x20	; 32
     908:	88 83       	st	Y, r24
     90a:	99 83       	std	Y+1, r25	; 0x01
{
	// Nothing is done in the body of this constructor. All the work is done in the
	// call to the frt_task constructor on the line just above this one
}
     90c:	df 91       	pop	r29
     90e:	cf 91       	pop	r28
     910:	1f 91       	pop	r17
     912:	0f 91       	pop	r16
     914:	08 95       	ret

00000916 <_ZN9task_user18print_help_messageEv>:
//-------------------------------------------------------------------------------------
/** This method prints a simple help message.
 */

void task_user::print_help_message (void)
{
     916:	0f 93       	push	r16
     918:	1f 93       	push	r17
     91a:	cf 93       	push	r28
     91c:	df 93       	push	r29
     91e:	ec 01       	movw	r28, r24
	*p_serial << ATERM_BKG_CYAN << ATERM_TXT_BLACK << clrscr;
     920:	6a e0       	ldi	r22, 0x0A	; 10
     922:	8e 81       	ldd	r24, Y+6	; 0x06
     924:	9f 81       	ldd	r25, Y+7	; 0x07
     926:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     92a:	8c 01       	movw	r16, r24
     92c:	6d ee       	ldi	r22, 0xED	; 237
     92e:	73 e0       	ldi	r23, 0x03	; 3
     930:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     934:	6a e0       	ldi	r22, 0x0A	; 10
     936:	c8 01       	movw	r24, r16
     938:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     93c:	8c 01       	movw	r16, r24
     93e:	67 ee       	ldi	r22, 0xE7	; 231
     940:	73 e0       	ldi	r23, 0x03	; 3
     942:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     946:	67 e0       	ldi	r22, 0x07	; 7
     948:	c8 01       	movw	r24, r16
     94a:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PROGRAM_VERSION << PMS (" help") << endl;
     94e:	6a e0       	ldi	r22, 0x0A	; 10
     950:	8e 81       	ldd	r24, Y+6	; 0x06
     952:	9f 81       	ldd	r25, Y+7	; 0x07
     954:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     958:	8c 01       	movw	r16, r24
     95a:	68 ec       	ldi	r22, 0xC8	; 200
     95c:	73 e0       	ldi	r23, 0x03	; 3
     95e:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     962:	6a e0       	ldi	r22, 0x0A	; 10
     964:	c8 01       	movw	r24, r16
     966:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     96a:	8c 01       	movw	r16, r24
     96c:	62 ec       	ldi	r22, 0xC2	; 194
     96e:	73 e0       	ldi	r23, 0x03	; 3
     970:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     974:	66 e0       	ldi	r22, 0x06	; 6
     976:	c8 01       	movw	r24, r16
     978:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-C: Reset the AVR") << endl;
     97c:	6a e0       	ldi	r22, 0x0A	; 10
     97e:	8e 81       	ldd	r24, Y+6	; 0x06
     980:	9f 81       	ldd	r25, Y+7	; 0x07
     982:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     986:	8c 01       	movw	r16, r24
     988:	6b ea       	ldi	r22, 0xAB	; 171
     98a:	73 e0       	ldi	r23, 0x03	; 3
     98c:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     990:	66 e0       	ldi	r22, 0x06	; 6
     992:	c8 01       	movw	r24, r16
     994:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  Ctl-A: Enter command mode") << endl;
     998:	6a e0       	ldi	r22, 0x0A	; 10
     99a:	8e 81       	ldd	r24, Y+6	; 0x06
     99c:	9f 81       	ldd	r25, Y+7	; 0x07
     99e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     9a2:	8c 01       	movw	r16, r24
     9a4:	6f e8       	ldi	r22, 0x8F	; 143
     9a6:	73 e0       	ldi	r23, 0x03	; 3
     9a8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     9ac:	66 e0       	ldi	r22, 0x06	; 6
     9ae:	c8 01       	movw	r24, r16
     9b0:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("  In command mode only:") << endl;
     9b4:	6a e0       	ldi	r22, 0x0A	; 10
     9b6:	8e 81       	ldd	r24, Y+6	; 0x06
     9b8:	9f 81       	ldd	r25, Y+7	; 0x07
     9ba:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     9be:	8c 01       	movw	r16, r24
     9c0:	67 e7       	ldi	r22, 0x77	; 119
     9c2:	73 e0       	ldi	r23, 0x03	; 3
     9c4:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     9c8:	66 e0       	ldi	r22, 0x06	; 6
     9ca:	c8 01       	movw	r24, r16
     9cc:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    n:   Show the time right now") << endl;
     9d0:	6a e0       	ldi	r22, 0x0A	; 10
     9d2:	8e 81       	ldd	r24, Y+6	; 0x06
     9d4:	9f 81       	ldd	r25, Y+7	; 0x07
     9d6:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     9da:	8c 01       	movw	r16, r24
     9dc:	66 e5       	ldi	r22, 0x56	; 86
     9de:	73 e0       	ldi	r23, 0x03	; 3
     9e0:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     9e4:	66 e0       	ldi	r22, 0x06	; 6
     9e6:	c8 01       	movw	r24, r16
     9e8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    v:   Version and setup information") << endl;
     9ec:	6a e0       	ldi	r22, 0x0A	; 10
     9ee:	8e 81       	ldd	r24, Y+6	; 0x06
     9f0:	9f 81       	ldd	r25, Y+7	; 0x07
     9f2:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     9f6:	8c 01       	movw	r16, r24
     9f8:	6f e2       	ldi	r22, 0x2F	; 47
     9fa:	73 e0       	ldi	r23, 0x03	; 3
     9fc:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     a00:	66 e0       	ldi	r22, 0x06	; 6
     a02:	c8 01       	movw	r24, r16
     a04:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    s:   Stack dump for tasks") << endl;
     a08:	6a e0       	ldi	r22, 0x0A	; 10
     a0a:	8e 81       	ldd	r24, Y+6	; 0x06
     a0c:	9f 81       	ldd	r25, Y+7	; 0x07
     a0e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     a12:	8c 01       	movw	r16, r24
     a14:	61 e1       	ldi	r22, 0x11	; 17
     a16:	73 e0       	ldi	r23, 0x03	; 3
     a18:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     a1c:	66 e0       	ldi	r22, 0x06	; 6
     a1e:	c8 01       	movw	r24, r16
     a20:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    e:   Exit command mode") << endl;
     a24:	6a e0       	ldi	r22, 0x0A	; 10
     a26:	8e 81       	ldd	r24, Y+6	; 0x06
     a28:	9f 81       	ldd	r25, Y+7	; 0x07
     a2a:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     a2e:	8c 01       	movw	r16, r24
     a30:	66 ef       	ldi	r22, 0xF6	; 246
     a32:	72 e0       	ldi	r23, 0x02	; 2
     a34:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     a38:	66 e0       	ldi	r22, 0x06	; 6
     a3a:	c8 01       	movw	r24, r16
     a3c:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	*p_serial << PMS ("    h:   HALP!") << endl;
     a40:	6a e0       	ldi	r22, 0x0A	; 10
     a42:	8e 81       	ldd	r24, Y+6	; 0x06
     a44:	9f 81       	ldd	r25, Y+7	; 0x07
     a46:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     a4a:	ec 01       	movw	r28, r24
     a4c:	67 ee       	ldi	r22, 0xE7	; 231
     a4e:	72 e0       	ldi	r23, 0x02	; 2
     a50:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     a54:	66 e0       	ldi	r22, 0x06	; 6
     a56:	ce 01       	movw	r24, r28
     a58:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
}
     a5c:	df 91       	pop	r29
     a5e:	cf 91       	pop	r28
     a60:	1f 91       	pop	r17
     a62:	0f 91       	pop	r16
     a64:	08 95       	ret

00000a66 <_ZN9task_user11show_statusEv>:
 *    \li Processor cycles used by each task
 *    \li Amount of heap space free and setting of RTOS tick timer
 */

void task_user::show_status (void)
{
     a66:	af 92       	push	r10
     a68:	bf 92       	push	r11
     a6a:	cf 92       	push	r12
     a6c:	df 92       	push	r13
     a6e:	ef 92       	push	r14
     a70:	ff 92       	push	r15
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	00 d0       	rcall	.+0      	; 0xa7c <_ZN9task_user11show_statusEv+0x16>
     a7c:	00 d0       	rcall	.+0      	; 0xa7e <_ZN9task_user11show_statusEv+0x18>
     a7e:	cd b7       	in	r28, 0x3d	; 61
     a80:	de b7       	in	r29, 0x3e	; 62
     a82:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     a84:	19 82       	std	Y+1, r1	; 0x01
     a86:	1a 82       	std	Y+2, r1	; 0x02
     a88:	1b 82       	std	Y+3, r1	; 0x03
     a8a:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     a8c:	1d 82       	std	Y+5, r1	; 0x05
     a8e:	1e 82       	std	Y+6, r1	; 0x06
		 *  means that the number returned is how many bytes are currently unused. 
		 *  @return The approximate number of bytes left for use in the heap
		 */
		size_t heap_left (void)
		{
			return (xPortGetFreeHeapSize ());
     a90:	0e 94 b8 07 	call	0xf70	; 0xf70 <xPortGetFreeHeapSize>
     a94:	6c 01       	movw	r12, r24
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
			  << PMS ("Time: ") << the_time.set_to_now ()
     a96:	ce 01       	movw	r24, r28
     a98:	01 96       	adiw	r24, 0x01	; 1
     a9a:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <_ZN10time_stamp10set_to_nowEv>
     a9e:	5c 01       	movw	r10, r24
void task_user::show_status (void)
{
	time_stamp the_time;					// Holds current time for printing

	// Show program vesion, time, and free heap space
	*p_serial << endl << PROGRAM_VERSION << PMS (__DATE__) << endl 
     aa0:	66 e0       	ldi	r22, 0x06	; 6
     aa2:	f8 01       	movw	r30, r16
     aa4:	86 81       	ldd	r24, Z+6	; 0x06
     aa6:	97 81       	ldd	r25, Z+7	; 0x07
     aa8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     aac:	6a e0       	ldi	r22, 0x0A	; 10
     aae:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     ab2:	7c 01       	movw	r14, r24
     ab4:	68 ec       	ldi	r22, 0xC8	; 200
     ab6:	72 e0       	ldi	r23, 0x02	; 2
     ab8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     abc:	6a e0       	ldi	r22, 0x0A	; 10
     abe:	c7 01       	movw	r24, r14
     ac0:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     ac4:	7c 01       	movw	r14, r24
     ac6:	6c eb       	ldi	r22, 0xBC	; 188
     ac8:	72 e0       	ldi	r23, 0x02	; 2
     aca:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     ace:	66 e0       	ldi	r22, 0x06	; 6
     ad0:	c7 01       	movw	r24, r14
     ad2:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
			  << PMS ("Time: ") << the_time.set_to_now ()
     ad6:	6a e0       	ldi	r22, 0x0A	; 10
     ad8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     adc:	7c 01       	movw	r14, r24
     ade:	65 eb       	ldi	r22, 0xB5	; 181
     ae0:	72 e0       	ldi	r23, 0x02	; 2
     ae2:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     ae6:	b5 01       	movw	r22, r10
     ae8:	c7 01       	movw	r24, r14
     aea:	0e 94 95 15 	call	0x2b2a	; 0x2b2a <_ZlsR8emstreamR10time_stamp>
			  << PMS (", Heap free: ") << heap_left() << PMS ("/") 
     aee:	6a e0       	ldi	r22, 0x0A	; 10
     af0:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     af4:	7c 01       	movw	r14, r24
     af6:	67 ea       	ldi	r22, 0xA7	; 167
     af8:	72 e0       	ldi	r23, 0x02	; 2
     afa:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     afe:	b6 01       	movw	r22, r12
     b00:	c7 01       	movw	r24, r14
     b02:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <_ZN8emstreamlsEj>
     b06:	6a e0       	ldi	r22, 0x0A	; 10
     b08:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     b0c:	7c 01       	movw	r14, r24
     b0e:	65 ea       	ldi	r22, 0xA5	; 165
     b10:	72 e0       	ldi	r23, 0x02	; 2
     b12:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
			  << configTOTAL_HEAP_SIZE;
     b16:	4f ef       	ldi	r20, 0xFF	; 255
     b18:	5f e0       	ldi	r21, 0x0F	; 15
     b1a:	60 e0       	ldi	r22, 0x00	; 0
     b1c:	70 e0       	ldi	r23, 0x00	; 0
     b1e:	c7 01       	movw	r24, r14
     b20:	0e 94 20 18 	call	0x3040	; 0x3040 <_ZN8emstreamlsEm>

	// Show how the timer/counter is set up to cause RTOS timer ticks
	*p_serial << PMS (", TCC0CCA=") << TCC0.CCA << endl << endl;
     b24:	c0 90 28 08 	lds	r12, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
     b28:	d0 90 29 08 	lds	r13, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
     b2c:	6a e0       	ldi	r22, 0x0A	; 10
     b2e:	f8 01       	movw	r30, r16
     b30:	86 81       	ldd	r24, Z+6	; 0x06
     b32:	97 81       	ldd	r25, Z+7	; 0x07
     b34:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     b38:	7c 01       	movw	r14, r24
     b3a:	6a e9       	ldi	r22, 0x9A	; 154
     b3c:	72 e0       	ldi	r23, 0x02	; 2
     b3e:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     b42:	b6 01       	movw	r22, r12
     b44:	c7 01       	movw	r24, r14
     b46:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <_ZN8emstreamlsEj>
     b4a:	66 e0       	ldi	r22, 0x06	; 6
     b4c:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     b50:	66 e0       	ldi	r22, 0x06	; 6
     b52:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>

	// Have the tasks print their status
	print_task_list (p_serial);
     b56:	f8 01       	movw	r30, r16
     b58:	86 81       	ldd	r24, Z+6	; 0x06
     b5a:	97 81       	ldd	r25, Z+7	; 0x07
     b5c:	0e 94 4e 14 	call	0x289c	; 0x289c <_Z15print_task_listP8emstream>
}
     b60:	26 96       	adiw	r28, 0x06	; 6
     b62:	cd bf       	out	0x3d, r28	; 61
     b64:	de bf       	out	0x3e, r29	; 62
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	1f 91       	pop	r17
     b6c:	0f 91       	pop	r16
     b6e:	ff 90       	pop	r15
     b70:	ef 90       	pop	r14
     b72:	df 90       	pop	r13
     b74:	cf 90       	pop	r12
     b76:	bf 90       	pop	r11
     b78:	af 90       	pop	r10
     b7a:	08 95       	ret

00000b7c <_ZN9task_user3runEv>:
 *  is just following the modern government model of "This is the land of the free...
 *  free to do exactly what you're told." 
 */

void task_user::run (void)
{
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	00 d0       	rcall	.+0      	; 0xb82 <_ZN9task_user3runEv+0x6>
     b82:	00 d0       	rcall	.+0      	; 0xb84 <_ZN9task_user3runEv+0x8>
     b84:	cd b7       	in	r28, 0x3d	; 61
     b86:	de b7       	in	r29, 0x3e	; 62
     b88:	8c 01       	movw	r16, r24
	public:
		/** This constructor creates a time stamp with its time set to zero.
		 */
		time_stamp (void)
		{
			tick_count = 0;
     b8a:	19 82       	std	Y+1, r1	; 0x01
     b8c:	1a 82       	std	Y+2, r1	; 0x02
     b8e:	1b 82       	std	Y+3, r1	; 0x03
     b90:	1c 82       	std	Y+4, r1	; 0x04
			hardware_count = 0;
     b92:	1d 82       	std	Y+5, r1	; 0x05
     b94:	1e 82       	std	Y+6, r1	; 0x06
	char char_in;                           // Character read from serial device
	time_stamp a_time;                      // Holds the time so it can be displayed

	// Tell the user how to get into command mode (state 1), where the user interface
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;
     b96:	6a e0       	ldi	r22, 0x0A	; 10
     b98:	dc 01       	movw	r26, r24
     b9a:	16 96       	adiw	r26, 0x06	; 6
     b9c:	8d 91       	ld	r24, X+
     b9e:	9c 91       	ld	r25, X
     ba0:	17 97       	sbiw	r26, 0x07	; 7
     ba2:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     ba6:	7c 01       	movw	r14, r24
     ba8:	66 e3       	ldi	r22, 0x36	; 54
     baa:	74 e0       	ldi	r23, 0x04	; 4
     bac:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     bb0:	66 e0       	ldi	r22, 0x06	; 6
     bb2:	c7 01       	movw	r24, r14
     bb4:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
	{
		// Run the finite state machine. The variable 'state' is kept by the parent class
		switch (state)
     bb8:	f8 01       	movw	r30, r16
     bba:	84 85       	ldd	r24, Z+12	; 0x0c
     bbc:	88 23       	and	r24, r24
     bbe:	21 f0       	breq	.+8      	; 0xbc8 <_ZN9task_user3runEv+0x4c>
     bc0:	81 30       	cpi	r24, 0x01	; 1
     bc2:	09 f4       	brne	.+2      	; 0xbc6 <_ZN9task_user3runEv+0x4a>
     bc4:	5d c0       	rjmp	.+186    	; 0xc80 <_ZN9task_user3runEv+0x104>
     bc6:	d8 c0       	rjmp	.+432    	; 0xd78 <_ZN9task_user3runEv+0x1fc>
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 0, we transparently relay characters from the radio to the USB 
			// serial port and vice versa but watch for certain control characters
			case (0):
				if (p_serial->check_for_char ())        // If the user typed a
     bc8:	86 81       	ldd	r24, Z+6	; 0x06
     bca:	97 81       	ldd	r25, Z+7	; 0x07
     bcc:	dc 01       	movw	r26, r24
     bce:	ed 91       	ld	r30, X+
     bd0:	fc 91       	ld	r31, X
     bd2:	04 80       	ldd	r0, Z+4	; 0x04
     bd4:	f5 81       	ldd	r31, Z+5	; 0x05
     bd6:	e0 2d       	mov	r30, r0
     bd8:	19 95       	eicall
     bda:	88 23       	and	r24, r24
     bdc:	a9 f1       	breq	.+106    	; 0xc48 <_ZN9task_user3runEv+0xcc>
				{                                       // character, read
					char_in = p_serial->getchar ();     // the character
     bde:	f8 01       	movw	r30, r16
     be0:	86 81       	ldd	r24, Z+6	; 0x06
     be2:	97 81       	ldd	r25, Z+7	; 0x07
     be4:	dc 01       	movw	r26, r24
     be6:	ed 91       	ld	r30, X+
     be8:	fc 91       	ld	r31, X
     bea:	06 80       	ldd	r0, Z+6	; 0x06
     bec:	f7 81       	ldd	r31, Z+7	; 0x07
     bee:	e0 2d       	mov	r30, r0
     bf0:	19 95       	eicall

					// In this switch statement, we respond to different characters
					switch (char_in)
     bf2:	99 27       	eor	r25, r25
     bf4:	81 30       	cpi	r24, 0x01	; 1
     bf6:	91 05       	cpc	r25, r1
     bf8:	f9 f0       	breq	.+62     	; 0xc38 <_ZN9task_user3runEv+0xbc>
     bfa:	03 97       	sbiw	r24, 0x03	; 3
     bfc:	09 f0       	breq	.+2      	; 0xc00 <_ZN9task_user3runEv+0x84>
     bfe:	d8 c0       	rjmp	.+432    	; 0xdb0 <_ZN9task_user3runEv+0x234>
					{
						// Control-C means reset the AVR computer
						case (3):
							*p_serial << PMS ("Resetting AVR") << endl;
     c00:	6a e0       	ldi	r22, 0x0A	; 10
     c02:	f8 01       	movw	r30, r16
     c04:	86 81       	ldd	r24, Z+6	; 0x06
     c06:	97 81       	ldd	r25, Z+7	; 0x07
     c08:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     c0c:	8c 01       	movw	r16, r24
     c0e:	68 e2       	ldi	r22, 0x28	; 40
     c10:	74 e0       	ldi	r23, 0x04	; 4
     c12:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     c16:	66 e0       	ldi	r22, 0x06	; 6
     c18:	c8 01       	movw	r24, r16
     c1a:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
							wdt_enable (WDTO_120MS);
     c1e:	93 e0       	ldi	r25, 0x03	; 3
     c20:	88 ed       	ldi	r24, 0xD8	; 216
     c22:	08 b6       	in	r0, 0x38	; 56
     c24:	18 be       	out	0x38, r1	; 56
     c26:	84 bf       	out	0x34, r24	; 52
     c28:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     c2c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     c30:	81 fd       	sbrc	r24, 1
     c32:	fc cf       	rjmp	.-8      	; 0xc2c <_ZN9task_user3runEv+0xb0>
     c34:	08 be       	out	0x38, r0	; 56
     c36:	ff cf       	rjmp	.-2      	; 0xc36 <_ZN9task_user3runEv+0xba>
							for (;;);
							break;

						// Control-A puts this task in command mode
						case (1):
							print_help_message ();
     c38:	c8 01       	movw	r24, r16
     c3a:	0e 94 8b 04 	call	0x916	; 0x916 <_ZN9task_user18print_help_messageEv>
							transition_to (1);
     c3e:	61 e0       	ldi	r22, 0x01	; 1
     c40:	c8 01       	movw	r24, r16
     c42:	0e 94 3c 12 	call	0x2478	; 0x2478 <_ZN8frt_task13transition_toEh>
							break;
     c46:	b4 c0       	rjmp	.+360    	; 0xdb0 <_ZN9task_user3runEv+0x234>
					};
				}

				// Check the print queue to see if another task has sent this task 
				// something to be printed
				else if (print_ser_queue.check_for_char ())
     c48:	82 e7       	ldi	r24, 0x72	; 114
     c4a:	91 e3       	ldi	r25, 0x31	; 49
     c4c:	0e 94 fd 14 	call	0x29fa	; 0x29fa <_ZN14frt_text_queue14check_for_charEv>
     c50:	88 23       	and	r24, r24
     c52:	09 f4       	brne	.+2      	; 0xc56 <_ZN9task_user3runEv+0xda>
     c54:	ad c0       	rjmp	.+346    	; 0xdb0 <_ZN9task_user3runEv+0x234>
				{
					p_serial->putchar (print_ser_queue.getchar ());
     c56:	d8 01       	movw	r26, r16
     c58:	16 96       	adiw	r26, 0x06	; 6
     c5a:	ed 91       	ld	r30, X+
     c5c:	fc 91       	ld	r31, X
     c5e:	17 97       	sbiw	r26, 0x07	; 7
     c60:	01 90       	ld	r0, Z+
     c62:	f0 81       	ld	r31, Z
     c64:	e0 2d       	mov	r30, r0
     c66:	e2 80       	ldd	r14, Z+2	; 0x02
     c68:	f3 80       	ldd	r15, Z+3	; 0x03
     c6a:	82 e7       	ldi	r24, 0x72	; 114
     c6c:	91 e3       	ldi	r25, 0x31	; 49
     c6e:	0e 94 df 14 	call	0x29be	; 0x29be <_ZN14frt_text_queue7getcharEv>
     c72:	68 2f       	mov	r22, r24
     c74:	f8 01       	movw	r30, r16
     c76:	86 81       	ldd	r24, Z+6	; 0x06
     c78:	97 81       	ldd	r25, Z+7	; 0x07
     c7a:	f7 01       	movw	r30, r14
     c7c:	19 95       	eicall
     c7e:	98 c0       	rjmp	.+304    	; 0xdb0 <_ZN9task_user3runEv+0x234>

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// In state 1, we're in command mode, so when the user types characters, the
			// characters are interpreted as commands to do something
			case (1):
				if (p_serial->check_for_char ())				// If the user typed a
     c80:	86 81       	ldd	r24, Z+6	; 0x06
     c82:	97 81       	ldd	r25, Z+7	; 0x07
     c84:	dc 01       	movw	r26, r24
     c86:	ed 91       	ld	r30, X+
     c88:	fc 91       	ld	r31, X
     c8a:	04 80       	ldd	r0, Z+4	; 0x04
     c8c:	f5 81       	ldd	r31, Z+5	; 0x05
     c8e:	e0 2d       	mov	r30, r0
     c90:	19 95       	eicall
     c92:	88 23       	and	r24, r24
     c94:	09 f4       	brne	.+2      	; 0xc98 <_ZN9task_user3runEv+0x11c>
     c96:	8c c0       	rjmp	.+280    	; 0xdb0 <_ZN9task_user3runEv+0x234>
				{											// character, read
					char_in = p_serial->getchar ();			// the character
     c98:	f8 01       	movw	r30, r16
     c9a:	86 81       	ldd	r24, Z+6	; 0x06
     c9c:	97 81       	ldd	r25, Z+7	; 0x07
     c9e:	dc 01       	movw	r26, r24
     ca0:	ed 91       	ld	r30, X+
     ca2:	fc 91       	ld	r31, X
     ca4:	06 80       	ldd	r0, Z+6	; 0x06
     ca6:	f7 81       	ldd	r31, Z+7	; 0x07
     ca8:	e0 2d       	mov	r30, r0
     caa:	19 95       	eicall

					// In this switch statement, we respond to different characters as
					// commands typed in by the user
					switch (char_in)
     cac:	9c 01       	movw	r18, r24
     cae:	33 27       	eor	r19, r19
     cb0:	28 36       	cpi	r18, 0x68	; 104
     cb2:	31 05       	cpc	r19, r1
     cb4:	59 f1       	breq	.+86     	; 0xd0c <_ZN9task_user3runEv+0x190>
     cb6:	3c f4       	brge	.+14     	; 0xcc6 <_ZN9task_user3runEv+0x14a>
     cb8:	2b 31       	cpi	r18, 0x1B	; 27
     cba:	31 05       	cpc	r19, r1
     cbc:	59 f1       	breq	.+86     	; 0xd14 <_ZN9task_user3runEv+0x198>
     cbe:	25 36       	cpi	r18, 0x65	; 101
     cc0:	31 05       	cpc	r19, r1
     cc2:	41 f1       	breq	.+80     	; 0xd14 <_ZN9task_user3runEv+0x198>
     cc4:	3b c0       	rjmp	.+118    	; 0xd3c <_ZN9task_user3runEv+0x1c0>
     cc6:	23 37       	cpi	r18, 0x73	; 115
     cc8:	31 05       	cpc	r19, r1
     cca:	c1 f0       	breq	.+48     	; 0xcfc <_ZN9task_user3runEv+0x180>
     ccc:	26 37       	cpi	r18, 0x76	; 118
     cce:	31 05       	cpc	r19, r1
     cd0:	89 f0       	breq	.+34     	; 0xcf4 <_ZN9task_user3runEv+0x178>
     cd2:	2e 36       	cpi	r18, 0x6E	; 110
     cd4:	31 05       	cpc	r19, r1
     cd6:	91 f5       	brne	.+100    	; 0xd3c <_ZN9task_user3runEv+0x1c0>
					{
						// The 'n' command asks what time it is right now
						case ('n'):
							*p_serial << (a_time.set_to_now ()) << endl;
     cd8:	ce 01       	movw	r24, r28
     cda:	01 96       	adiw	r24, 0x01	; 1
     cdc:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <_ZN10time_stamp10set_to_nowEv>
     ce0:	bc 01       	movw	r22, r24
     ce2:	f8 01       	movw	r30, r16
     ce4:	86 81       	ldd	r24, Z+6	; 0x06
     ce6:	97 81       	ldd	r25, Z+7	; 0x07
     ce8:	0e 94 95 15 	call	0x2b2a	; 0x2b2a <_ZlsR8emstreamR10time_stamp>
     cec:	66 e0       	ldi	r22, 0x06	; 6
     cee:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
							break;
     cf2:	5e c0       	rjmp	.+188    	; 0xdb0 <_ZN9task_user3runEv+0x234>

						// The 'v' command asks for version and status information
						case ('v'):
							show_status ();
     cf4:	c8 01       	movw	r24, r16
     cf6:	0e 94 33 05 	call	0xa66	; 0xa66 <_ZN9task_user11show_statusEv>
							break;
     cfa:	5a c0       	rjmp	.+180    	; 0xdb0 <_ZN9task_user3runEv+0x234>

						// The 's' command has all the tasks dump their stacks
						case ('s'):
							print_task_stacks (p_serial);
     cfc:	d8 01       	movw	r26, r16
     cfe:	16 96       	adiw	r26, 0x06	; 6
     d00:	8d 91       	ld	r24, X+
     d02:	9c 91       	ld	r25, X
     d04:	17 97       	sbiw	r26, 0x07	; 7
     d06:	0e 94 55 13 	call	0x26aa	; 0x26aa <_Z17print_task_stacksP8emstream>
							break;
     d0a:	52 c0       	rjmp	.+164    	; 0xdb0 <_ZN9task_user3runEv+0x234>

						// The 'h' command is a plea for help
						case ('h'):
							print_help_message ();
     d0c:	c8 01       	movw	r24, r16
     d0e:	0e 94 8b 04 	call	0x916	; 0x916 <_ZN9task_user18print_help_messageEv>
							break;
     d12:	4e c0       	rjmp	.+156    	; 0xdb0 <_ZN9task_user3runEv+0x234>

						// The escape key or 'e' key go back to non-command mode
						case (27):
						case ('e'):
							*p_serial << PMS ("Exit command mode") << endl;
     d14:	6a e0       	ldi	r22, 0x0A	; 10
     d16:	f8 01       	movw	r30, r16
     d18:	86 81       	ldd	r24, Z+6	; 0x06
     d1a:	97 81       	ldd	r25, Z+7	; 0x07
     d1c:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     d20:	7c 01       	movw	r14, r24
     d22:	66 e1       	ldi	r22, 0x16	; 22
     d24:	74 e0       	ldi	r23, 0x04	; 4
     d26:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     d2a:	66 e0       	ldi	r22, 0x06	; 6
     d2c:	c7 01       	movw	r24, r14
     d2e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
							transition_to (0);
     d32:	60 e0       	ldi	r22, 0x00	; 0
     d34:	c8 01       	movw	r24, r16
     d36:	0e 94 3c 12 	call	0x2478	; 0x2478 <_ZN8frt_task13transition_toEh>
							break;
     d3a:	3a c0       	rjmp	.+116    	; 0xdb0 <_ZN9task_user3runEv+0x234>

						// If the character isn't recognized, ask: What's That Function?
						default:
							p_serial->putchar (char_in);
     d3c:	f8 01       	movw	r30, r16
     d3e:	a6 81       	ldd	r26, Z+6	; 0x06
     d40:	b7 81       	ldd	r27, Z+7	; 0x07
     d42:	ed 91       	ld	r30, X+
     d44:	fc 91       	ld	r31, X
     d46:	11 97       	sbiw	r26, 0x01	; 1
     d48:	02 80       	ldd	r0, Z+2	; 0x02
     d4a:	f3 81       	ldd	r31, Z+3	; 0x03
     d4c:	e0 2d       	mov	r30, r0
     d4e:	68 2f       	mov	r22, r24
     d50:	cd 01       	movw	r24, r26
     d52:	19 95       	eicall
							*p_serial << PMS (":WTF?") << endl;
     d54:	6a e0       	ldi	r22, 0x0A	; 10
     d56:	d8 01       	movw	r26, r16
     d58:	16 96       	adiw	r26, 0x06	; 6
     d5a:	8d 91       	ld	r24, X+
     d5c:	9c 91       	ld	r25, X
     d5e:	17 97       	sbiw	r26, 0x07	; 7
     d60:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     d64:	7c 01       	movw	r14, r24
     d66:	60 e1       	ldi	r22, 0x10	; 16
     d68:	74 e0       	ldi	r23, 0x04	; 4
     d6a:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     d6e:	66 e0       	ldi	r22, 0x06	; 6
     d70:	c7 01       	movw	r24, r14
     d72:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
							break;
     d76:	1c c0       	rjmp	.+56     	; 0xdb0 <_ZN9task_user3runEv+0x234>
				break; // End of state 1

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// We should never get to the default state. If we do, complain and restart
			default:
				*p_serial << PMS ("Illegal state! Resetting AVR") << endl;
     d78:	6a e0       	ldi	r22, 0x0A	; 10
     d7a:	f8 01       	movw	r30, r16
     d7c:	86 81       	ldd	r24, Z+6	; 0x06
     d7e:	97 81       	ldd	r25, Z+7	; 0x07
     d80:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
     d84:	8c 01       	movw	r16, r24
     d86:	63 ef       	ldi	r22, 0xF3	; 243
     d88:	73 e0       	ldi	r23, 0x03	; 3
     d8a:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
     d8e:	66 e0       	ldi	r22, 0x06	; 6
     d90:	c8 01       	movw	r24, r16
     d92:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
				wdt_enable (WDTO_120MS);
     d96:	93 e0       	ldi	r25, 0x03	; 3
     d98:	88 ed       	ldi	r24, 0xD8	; 216
     d9a:	08 b6       	in	r0, 0x38	; 56
     d9c:	18 be       	out	0x38, r1	; 56
     d9e:	84 bf       	out	0x34, r24	; 52
     da0:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
     da4:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <__TEXT_REGION_LENGTH__+0x700082>
     da8:	81 fd       	sbrc	r24, 1
     daa:	fc cf       	rjmp	.-8      	; 0xda4 <_ZN9task_user3runEv+0x228>
     dac:	08 be       	out	0x38, r0	; 56
     dae:	ff cf       	rjmp	.-2      	; 0xdae <_ZN9task_user3runEv+0x232>
				for (;;);
				break;

		} // End switch state

		runs++;                             // Increment counter for debugging
     db0:	f8 01       	movw	r30, r16
     db2:	86 85       	ldd	r24, Z+14	; 0x0e
     db4:	97 85       	ldd	r25, Z+15	; 0x0f
     db6:	a0 89       	ldd	r26, Z+16	; 0x10
     db8:	b1 89       	ldd	r27, Z+17	; 0x11
     dba:	01 96       	adiw	r24, 0x01	; 1
     dbc:	a1 1d       	adc	r26, r1
     dbe:	b1 1d       	adc	r27, r1
     dc0:	86 87       	std	Z+14, r24	; 0x0e
     dc2:	97 87       	std	Z+15, r25	; 0x0f
     dc4:	a0 8b       	std	Z+16, r26	; 0x10
     dc6:	b1 8b       	std	Z+17, r27	; 0x11

		// No matter the state, wait for approximately a millisecond before we 
		// run the loop again. This gives lower priority tasks a chance to run
		vTaskDelay (configMS_TO_TICKS (1));
     dc8:	61 e0       	ldi	r22, 0x01	; 1
     dca:	70 e0       	ldi	r23, 0x00	; 0
     dcc:	80 e0       	ldi	r24, 0x00	; 0
     dce:	90 e0       	ldi	r25, 0x00	; 0
     dd0:	0e 94 10 10 	call	0x2020	; 0x2020 <vTaskDelay>
	// task does interesting things such as diagnostic printouts
	*p_serial << PMS ("Press Ctrl-A for command mode") << endl;

	// This is an infinite loop; it runs until the power is turned off. There is one 
	// such loop inside the code for each task
	for (;;)
     dd4:	f1 ce       	rjmp	.-542    	; 0xbb8 <_ZN9task_user3runEv+0x3c>

00000dd6 <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     dd6:	0f 93       	push	r16
     dd8:	1f 93       	push	r17
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
     dde:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     de0:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     de4:	80 91 e8 20 	lds	r24, 0x20E8	; 0x8020e8 <__data_end>
     de8:	81 11       	cpse	r24, r1
     dea:	1d c0       	rjmp	.+58     	; 0xe26 <pvPortMalloc+0x50>
		{
			prvHeapInit();
     dec:	ad ee       	ldi	r26, 0xED	; 237
     dee:	b0 e2       	ldi	r27, 0x20	; 32
     df0:	e1 ef       	ldi	r30, 0xF1	; 241
     df2:	f0 e2       	ldi	r31, 0x20	; 32
     df4:	ed 93       	st	X+, r30
     df6:	fc 93       	st	X, r31
     df8:	11 97       	sbiw	r26, 0x01	; 1
     dfa:	12 96       	adiw	r26, 0x02	; 2
     dfc:	1d 92       	st	X+, r1
     dfe:	1c 92       	st	X, r1
     e00:	13 97       	sbiw	r26, 0x03	; 3
     e02:	a9 ee       	ldi	r26, 0xE9	; 233
     e04:	b0 e2       	ldi	r27, 0x20	; 32
     e06:	8f ef       	ldi	r24, 0xFF	; 255
     e08:	9f e0       	ldi	r25, 0x0F	; 15
     e0a:	12 96       	adiw	r26, 0x02	; 2
     e0c:	8d 93       	st	X+, r24
     e0e:	9c 93       	st	X, r25
     e10:	13 97       	sbiw	r26, 0x03	; 3
     e12:	1d 92       	st	X+, r1
     e14:	1c 92       	st	X, r1
     e16:	11 97       	sbiw	r26, 0x01	; 1
     e18:	82 83       	std	Z+2, r24	; 0x02
     e1a:	93 83       	std	Z+3, r25	; 0x03
     e1c:	a0 83       	st	Z, r26
     e1e:	b1 83       	std	Z+1, r27	; 0x01
			xHeapHasBeenInitialised = pdTRUE;
     e20:	81 e0       	ldi	r24, 0x01	; 1
     e22:	80 93 e8 20 	sts	0x20E8, r24	; 0x8020e8 <__data_end>
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     e26:	20 97       	sbiw	r28, 0x00	; 0
     e28:	09 f4       	brne	.+2      	; 0xe2c <pvPortMalloc+0x56>
     e2a:	5f c0       	rjmp	.+190    	; 0xeea <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     e2c:	9e 01       	movw	r18, r28
     e2e:	2b 5f       	subi	r18, 0xFB	; 251
     e30:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
     e32:	24 96       	adiw	r28, 0x04	; 4
     e34:	ce 3f       	cpi	r28, 0xFE	; 254
     e36:	df 40       	sbci	r29, 0x0F	; 15
     e38:	08 f0       	brcs	.+2      	; 0xe3c <pvPortMalloc+0x66>
     e3a:	5a c0       	rjmp	.+180    	; 0xef0 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     e3c:	e0 91 ed 20 	lds	r30, 0x20ED	; 0x8020ed <xStart>
     e40:	f0 91 ee 20 	lds	r31, 0x20EE	; 0x8020ee <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     e44:	ad ee       	ldi	r26, 0xED	; 237
     e46:	b0 e2       	ldi	r27, 0x20	; 32
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     e48:	02 c0       	rjmp	.+4      	; 0xe4e <pvPortMalloc+0x78>
     e4a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     e4c:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
     e4e:	82 81       	ldd	r24, Z+2	; 0x02
     e50:	93 81       	ldd	r25, Z+3	; 0x03
     e52:	82 17       	cp	r24, r18
     e54:	93 07       	cpc	r25, r19
     e56:	20 f4       	brcc	.+8      	; 0xe60 <pvPortMalloc+0x8a>
     e58:	80 81       	ld	r24, Z
     e5a:	91 81       	ldd	r25, Z+1	; 0x01
     e5c:	00 97       	sbiw	r24, 0x00	; 0
     e5e:	a9 f7       	brne	.-22     	; 0xe4a <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     e60:	c0 e2       	ldi	r28, 0x20	; 32
     e62:	e9 3e       	cpi	r30, 0xE9	; 233
     e64:	fc 07       	cpc	r31, r28
     e66:	09 f4       	brne	.+2      	; 0xe6a <pvPortMalloc+0x94>
     e68:	46 c0       	rjmp	.+140    	; 0xef6 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     e6a:	cd 91       	ld	r28, X+
     e6c:	dc 91       	ld	r29, X
     e6e:	11 97       	sbiw	r26, 0x01	; 1
     e70:	8e 01       	movw	r16, r28
     e72:	0b 5f       	subi	r16, 0xFB	; 251
     e74:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     e76:	80 81       	ld	r24, Z
     e78:	91 81       	ldd	r25, Z+1	; 0x01
     e7a:	8d 93       	st	X+, r24
     e7c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     e7e:	82 81       	ldd	r24, Z+2	; 0x02
     e80:	93 81       	ldd	r25, Z+3	; 0x03
     e82:	82 1b       	sub	r24, r18
     e84:	93 0b       	sbc	r25, r19
     e86:	8b 30       	cpi	r24, 0x0B	; 11
     e88:	91 05       	cpc	r25, r1
     e8a:	10 f1       	brcs	.+68     	; 0xed0 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
     e8c:	bf 01       	movw	r22, r30
     e8e:	62 0f       	add	r22, r18
     e90:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     e92:	db 01       	movw	r26, r22
     e94:	12 96       	adiw	r26, 0x02	; 2
     e96:	8d 93       	st	X+, r24
     e98:	9c 93       	st	X, r25
     e9a:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
     e9c:	22 83       	std	Z+2, r18	; 0x02
     e9e:	33 83       	std	Z+3, r19	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     ea0:	12 96       	adiw	r26, 0x02	; 2
     ea2:	4d 91       	ld	r20, X+
     ea4:	5c 91       	ld	r21, X
     ea6:	13 97       	sbiw	r26, 0x03	; 3
     ea8:	8d ee       	ldi	r24, 0xED	; 237
     eaa:	90 e2       	ldi	r25, 0x20	; 32
     eac:	01 c0       	rjmp	.+2      	; 0xeb0 <pvPortMalloc+0xda>
     eae:	cd 01       	movw	r24, r26
     eb0:	ec 01       	movw	r28, r24
     eb2:	a8 81       	ld	r26, Y
     eb4:	b9 81       	ldd	r27, Y+1	; 0x01
     eb6:	12 96       	adiw	r26, 0x02	; 2
     eb8:	2d 91       	ld	r18, X+
     eba:	3c 91       	ld	r19, X
     ebc:	13 97       	sbiw	r26, 0x03	; 3
     ebe:	24 17       	cp	r18, r20
     ec0:	35 07       	cpc	r19, r21
     ec2:	a8 f3       	brcs	.-22     	; 0xeae <pvPortMalloc+0xd8>
     ec4:	eb 01       	movw	r28, r22
     ec6:	a8 83       	st	Y, r26
     ec8:	b9 83       	std	Y+1, r27	; 0x01
     eca:	dc 01       	movw	r26, r24
     ecc:	6d 93       	st	X+, r22
     ece:	7c 93       	st	X, r23
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
     ed0:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
     ed4:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
     ed8:	22 81       	ldd	r18, Z+2	; 0x02
     eda:	33 81       	ldd	r19, Z+3	; 0x03
     edc:	82 1b       	sub	r24, r18
     ede:	93 0b       	sbc	r25, r19
     ee0:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__DATA_REGION_ORIGIN__>
     ee4:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
     ee8:	08 c0       	rjmp	.+16     	; 0xefa <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     eea:	00 e0       	ldi	r16, 0x00	; 0
     eec:	10 e0       	ldi	r17, 0x00	; 0
     eee:	05 c0       	rjmp	.+10     	; 0xefa <pvPortMalloc+0x124>
     ef0:	00 e0       	ldi	r16, 0x00	; 0
     ef2:	10 e0       	ldi	r17, 0x00	; 0
     ef4:	02 c0       	rjmp	.+4      	; 0xefa <pvPortMalloc+0x124>
     ef6:	00 e0       	ldi	r16, 0x00	; 0
     ef8:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
     efa:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     efe:	c8 01       	movw	r24, r16
     f00:	df 91       	pop	r29
     f02:	cf 91       	pop	r28
     f04:	1f 91       	pop	r17
     f06:	0f 91       	pop	r16
     f08:	08 95       	ret

00000f0a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f0a:	0f 93       	push	r16
     f0c:	1f 93       	push	r17
     f0e:	cf 93       	push	r28
     f10:	df 93       	push	r29
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
     f12:	00 97       	sbiw	r24, 0x00	; 0
     f14:	41 f1       	breq	.+80     	; 0xf66 <vPortFree+0x5c>
     f16:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     f18:	8c 01       	movw	r16, r24
     f1a:	05 50       	subi	r16, 0x05	; 5
     f1c:	11 09       	sbc	r17, r1

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     f1e:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
     f22:	f8 01       	movw	r30, r16
     f24:	42 81       	ldd	r20, Z+2	; 0x02
     f26:	53 81       	ldd	r21, Z+3	; 0x03
     f28:	ad ee       	ldi	r26, 0xED	; 237
     f2a:	b0 e2       	ldi	r27, 0x20	; 32
     f2c:	01 c0       	rjmp	.+2      	; 0xf30 <vPortFree+0x26>
     f2e:	df 01       	movw	r26, r30
     f30:	ed 91       	ld	r30, X+
     f32:	fc 91       	ld	r31, X
     f34:	11 97       	sbiw	r26, 0x01	; 1
     f36:	22 81       	ldd	r18, Z+2	; 0x02
     f38:	33 81       	ldd	r19, Z+3	; 0x03
     f3a:	24 17       	cp	r18, r20
     f3c:	35 07       	cpc	r19, r21
     f3e:	b8 f3       	brcs	.-18     	; 0xf2e <vPortFree+0x24>
     f40:	25 97       	sbiw	r28, 0x05	; 5
     f42:	e8 83       	st	Y, r30
     f44:	f9 83       	std	Y+1, r31	; 0x01
     f46:	0d 93       	st	X+, r16
     f48:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     f4a:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
     f4e:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
     f52:	8a 81       	ldd	r24, Y+2	; 0x02
     f54:	9b 81       	ldd	r25, Y+3	; 0x03
     f56:	82 0f       	add	r24, r18
     f58:	93 1f       	adc	r25, r19
     f5a:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__DATA_REGION_ORIGIN__>
     f5e:	90 93 01 20 	sts	0x2001, r25	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
		}
		xTaskResumeAll();
     f62:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
	}
}
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	1f 91       	pop	r17
     f6c:	0f 91       	pop	r16
     f6e:	08 95       	ret

00000f70 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     f70:	80 91 00 20 	lds	r24, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
     f74:	90 91 01 20 	lds	r25, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
     f78:	08 95       	ret

00000f7a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     f7a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     f7c:	03 96       	adiw	r24, 0x03	; 3
     f7e:	81 83       	std	Z+1, r24	; 0x01
     f80:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     f82:	4f ef       	ldi	r20, 0xFF	; 255
     f84:	5f ef       	ldi	r21, 0xFF	; 255
     f86:	ba 01       	movw	r22, r20
     f88:	43 83       	std	Z+3, r20	; 0x03
     f8a:	54 83       	std	Z+4, r21	; 0x04
     f8c:	65 83       	std	Z+5, r22	; 0x05
     f8e:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     f90:	87 83       	std	Z+7, r24	; 0x07
     f92:	90 87       	std	Z+8, r25	; 0x08
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     f94:	81 87       	std	Z+9, r24	; 0x09
     f96:	92 87       	std	Z+10, r25	; 0x0a

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     f98:	10 82       	st	Z, r1
     f9a:	08 95       	ret

00000f9c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     f9c:	fc 01       	movw	r30, r24
     f9e:	12 86       	std	Z+10, r1	; 0x0a
     fa0:	13 86       	std	Z+11, r1	; 0x0b
     fa2:	08 95       	ret

00000fa4 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	fc 01       	movw	r30, r24
     faa:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     fac:	21 81       	ldd	r18, Z+1	; 0x01
     fae:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     fb0:	e9 01       	movw	r28, r18
     fb2:	8c 81       	ldd	r24, Y+4	; 0x04
     fb4:	9d 81       	ldd	r25, Y+5	; 0x05
     fb6:	14 96       	adiw	r26, 0x04	; 4
     fb8:	8d 93       	st	X+, r24
     fba:	9c 93       	st	X, r25
     fbc:	15 97       	sbiw	r26, 0x05	; 5
	pxNewListItem->pxPrevious = pxList->pxIndex;
     fbe:	81 81       	ldd	r24, Z+1	; 0x01
     fc0:	92 81       	ldd	r25, Z+2	; 0x02
     fc2:	16 96       	adiw	r26, 0x06	; 6
     fc4:	8d 93       	st	X+, r24
     fc6:	9c 93       	st	X, r25
     fc8:	17 97       	sbiw	r26, 0x07	; 7
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     fca:	8c 81       	ldd	r24, Y+4	; 0x04
     fcc:	9d 81       	ldd	r25, Y+5	; 0x05
     fce:	ec 01       	movw	r28, r24
     fd0:	6e 83       	std	Y+6, r22	; 0x06
     fd2:	7f 83       	std	Y+7, r23	; 0x07
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     fd4:	e9 01       	movw	r28, r18
     fd6:	6c 83       	std	Y+4, r22	; 0x04
     fd8:	7d 83       	std	Y+5, r23	; 0x05
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     fda:	61 83       	std	Z+1, r22	; 0x01
     fdc:	72 83       	std	Z+2, r23	; 0x02

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     fde:	1a 96       	adiw	r26, 0x0a	; 10
     fe0:	ed 93       	st	X+, r30
     fe2:	fc 93       	st	X, r31
     fe4:	1b 97       	sbiw	r26, 0x0b	; 11

	( pxList->uxNumberOfItems )++;
     fe6:	80 81       	ld	r24, Z
     fe8:	8f 5f       	subi	r24, 0xFF	; 255
     fea:	80 83       	st	Z, r24
}
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	08 95       	ret

00000ff2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     ff2:	0f 93       	push	r16
     ff4:	1f 93       	push	r17
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     ffc:	08 81       	ld	r16, Y
     ffe:	19 81       	ldd	r17, Y+1	; 0x01
    1000:	2a 81       	ldd	r18, Y+2	; 0x02
    1002:	3b 81       	ldd	r19, Y+3	; 0x03
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1004:	0f 3f       	cpi	r16, 0xFF	; 255
    1006:	4f ef       	ldi	r20, 0xFF	; 255
    1008:	14 07       	cpc	r17, r20
    100a:	24 07       	cpc	r18, r20
    100c:	34 07       	cpc	r19, r20
    100e:	31 f4       	brne	.+12     	; 0x101c <vListInsert+0x2a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1010:	dc 01       	movw	r26, r24
    1012:	19 96       	adiw	r26, 0x09	; 9
    1014:	ed 91       	ld	r30, X+
    1016:	fc 91       	ld	r31, X
    1018:	1a 97       	sbiw	r26, 0x0a	; 10
    101a:	1f c0       	rjmp	.+62     	; 0x105a <vListInsert+0x68>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    101c:	fc 01       	movw	r30, r24
    101e:	33 96       	adiw	r30, 0x03	; 3
    1020:	dc 01       	movw	r26, r24
    1022:	17 96       	adiw	r26, 0x07	; 7
    1024:	4d 91       	ld	r20, X+
    1026:	5c 91       	ld	r21, X
    1028:	18 97       	sbiw	r26, 0x08	; 8
    102a:	da 01       	movw	r26, r20
    102c:	4d 91       	ld	r20, X+
    102e:	5d 91       	ld	r21, X+
    1030:	6d 91       	ld	r22, X+
    1032:	7c 91       	ld	r23, X
    1034:	04 17       	cp	r16, r20
    1036:	15 07       	cpc	r17, r21
    1038:	26 07       	cpc	r18, r22
    103a:	37 07       	cpc	r19, r23
    103c:	70 f0       	brcs	.+28     	; 0x105a <vListInsert+0x68>
    103e:	04 80       	ldd	r0, Z+4	; 0x04
    1040:	f5 81       	ldd	r31, Z+5	; 0x05
    1042:	e0 2d       	mov	r30, r0
    1044:	a4 81       	ldd	r26, Z+4	; 0x04
    1046:	b5 81       	ldd	r27, Z+5	; 0x05
    1048:	4d 91       	ld	r20, X+
    104a:	5d 91       	ld	r21, X+
    104c:	6d 91       	ld	r22, X+
    104e:	7c 91       	ld	r23, X
    1050:	04 17       	cp	r16, r20
    1052:	15 07       	cpc	r17, r21
    1054:	26 07       	cpc	r18, r22
    1056:	37 07       	cpc	r19, r23
    1058:	90 f7       	brcc	.-28     	; 0x103e <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    105a:	a4 81       	ldd	r26, Z+4	; 0x04
    105c:	b5 81       	ldd	r27, Z+5	; 0x05
    105e:	ac 83       	std	Y+4, r26	; 0x04
    1060:	bd 83       	std	Y+5, r27	; 0x05
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1062:	16 96       	adiw	r26, 0x06	; 6
    1064:	cd 93       	st	X+, r28
    1066:	dc 93       	st	X, r29
    1068:	17 97       	sbiw	r26, 0x07	; 7
	pxNewListItem->pxPrevious = pxIterator;
    106a:	ee 83       	std	Y+6, r30	; 0x06
    106c:	ff 83       	std	Y+7, r31	; 0x07
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    106e:	c4 83       	std	Z+4, r28	; 0x04
    1070:	d5 83       	std	Z+5, r29	; 0x05

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1072:	8a 87       	std	Y+10, r24	; 0x0a
    1074:	9b 87       	std	Y+11, r25	; 0x0b

	( pxList->uxNumberOfItems )++;
    1076:	fc 01       	movw	r30, r24
    1078:	20 81       	ld	r18, Z
    107a:	2f 5f       	subi	r18, 0xFF	; 255
    107c:	20 83       	st	Z, r18
}
    107e:	df 91       	pop	r29
    1080:	cf 91       	pop	r28
    1082:	1f 91       	pop	r17
    1084:	0f 91       	pop	r16
    1086:	08 95       	ret

00001088 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1088:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    108a:	a4 81       	ldd	r26, Z+4	; 0x04
    108c:	b5 81       	ldd	r27, Z+5	; 0x05
    108e:	86 81       	ldd	r24, Z+6	; 0x06
    1090:	97 81       	ldd	r25, Z+7	; 0x07
    1092:	16 96       	adiw	r26, 0x06	; 6
    1094:	8d 93       	st	X+, r24
    1096:	9c 93       	st	X, r25
    1098:	17 97       	sbiw	r26, 0x07	; 7
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    109a:	a6 81       	ldd	r26, Z+6	; 0x06
    109c:	b7 81       	ldd	r27, Z+7	; 0x07
    109e:	84 81       	ldd	r24, Z+4	; 0x04
    10a0:	95 81       	ldd	r25, Z+5	; 0x05
    10a2:	14 96       	adiw	r26, 0x04	; 4
    10a4:	8d 93       	st	X+, r24
    10a6:	9c 93       	st	X, r25
    10a8:	15 97       	sbiw	r26, 0x05	; 5
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    10aa:	a2 85       	ldd	r26, Z+10	; 0x0a
    10ac:	b3 85       	ldd	r27, Z+11	; 0x0b

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    10ae:	11 96       	adiw	r26, 0x01	; 1
    10b0:	8d 91       	ld	r24, X+
    10b2:	9c 91       	ld	r25, X
    10b4:	12 97       	sbiw	r26, 0x02	; 2
    10b6:	e8 17       	cp	r30, r24
    10b8:	f9 07       	cpc	r31, r25
    10ba:	31 f4       	brne	.+12     	; 0x10c8 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    10bc:	86 81       	ldd	r24, Z+6	; 0x06
    10be:	97 81       	ldd	r25, Z+7	; 0x07
    10c0:	11 96       	adiw	r26, 0x01	; 1
    10c2:	8d 93       	st	X+, r24
    10c4:	9c 93       	st	X, r25
    10c6:	12 97       	sbiw	r26, 0x02	; 2
	}

	pxItemToRemove->pvContainer = NULL;
    10c8:	12 86       	std	Z+10, r1	; 0x0a
    10ca:	13 86       	std	Z+11, r1	; 0x0b
	( pxList->uxNumberOfItems )--;
    10cc:	8c 91       	ld	r24, X
    10ce:	81 50       	subi	r24, 0x01	; 1
    10d0:	8c 93       	st	X, r24
    10d2:	08 95       	ret

000010d4 <pxPortInitialiseStack>:
}

/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    10d4:	80 93 82 31 	sts	0x3182, r24	; 0x803182 <portStackTopForTask>
    10d8:	90 93 83 31 	sts	0x3183, r25	; 0x803183 <portStackTopForTask+0x1>
    10dc:	31 e1       	ldi	r19, 0x11	; 17
    10de:	fc 01       	movw	r30, r24
    10e0:	30 83       	st	Z, r19
    10e2:	31 97       	sbiw	r30, 0x01	; 1
    10e4:	22 e2       	ldi	r18, 0x22	; 34
    10e6:	20 83       	st	Z, r18
    10e8:	31 97       	sbiw	r30, 0x01	; 1
    10ea:	a3 e3       	ldi	r26, 0x33	; 51
    10ec:	a0 83       	st	Z, r26
    10ee:	31 97       	sbiw	r30, 0x01	; 1
    10f0:	60 83       	st	Z, r22
    10f2:	31 97       	sbiw	r30, 0x01	; 1
    10f4:	70 83       	st	Z, r23
    10f6:	31 97       	sbiw	r30, 0x01	; 1
    10f8:	10 82       	st	Z, r1
    10fa:	31 97       	sbiw	r30, 0x01	; 1
    10fc:	10 82       	st	Z, r1
    10fe:	31 97       	sbiw	r30, 0x01	; 1
    1100:	60 e8       	ldi	r22, 0x80	; 128
    1102:	60 83       	st	Z, r22
    1104:	31 97       	sbiw	r30, 0x01	; 1
    1106:	10 82       	st	Z, r1
    1108:	31 97       	sbiw	r30, 0x01	; 1
    110a:	10 82       	st	Z, r1
    110c:	31 97       	sbiw	r30, 0x01	; 1
    110e:	10 82       	st	Z, r1
    1110:	31 97       	sbiw	r30, 0x01	; 1
    1112:	62 e0       	ldi	r22, 0x02	; 2
    1114:	60 83       	st	Z, r22
    1116:	31 97       	sbiw	r30, 0x01	; 1
    1118:	63 e0       	ldi	r22, 0x03	; 3
    111a:	60 83       	st	Z, r22
    111c:	31 97       	sbiw	r30, 0x01	; 1
    111e:	64 e0       	ldi	r22, 0x04	; 4
    1120:	60 83       	st	Z, r22
    1122:	31 97       	sbiw	r30, 0x01	; 1
    1124:	65 e0       	ldi	r22, 0x05	; 5
    1126:	60 83       	st	Z, r22
    1128:	31 97       	sbiw	r30, 0x01	; 1
    112a:	66 e0       	ldi	r22, 0x06	; 6
    112c:	60 83       	st	Z, r22
    112e:	31 97       	sbiw	r30, 0x01	; 1
    1130:	67 e0       	ldi	r22, 0x07	; 7
    1132:	60 83       	st	Z, r22
    1134:	31 97       	sbiw	r30, 0x01	; 1
    1136:	68 e0       	ldi	r22, 0x08	; 8
    1138:	60 83       	st	Z, r22
    113a:	31 97       	sbiw	r30, 0x01	; 1
    113c:	69 e0       	ldi	r22, 0x09	; 9
    113e:	60 83       	st	Z, r22
    1140:	31 97       	sbiw	r30, 0x01	; 1
    1142:	60 e1       	ldi	r22, 0x10	; 16
    1144:	60 83       	st	Z, r22
    1146:	31 97       	sbiw	r30, 0x01	; 1
    1148:	30 83       	st	Z, r19
    114a:	31 97       	sbiw	r30, 0x01	; 1
    114c:	32 e1       	ldi	r19, 0x12	; 18
    114e:	30 83       	st	Z, r19
    1150:	31 97       	sbiw	r30, 0x01	; 1
    1152:	33 e1       	ldi	r19, 0x13	; 19
    1154:	30 83       	st	Z, r19
    1156:	31 97       	sbiw	r30, 0x01	; 1
    1158:	34 e1       	ldi	r19, 0x14	; 20
    115a:	30 83       	st	Z, r19
    115c:	31 97       	sbiw	r30, 0x01	; 1
    115e:	35 e1       	ldi	r19, 0x15	; 21
    1160:	30 83       	st	Z, r19
    1162:	31 97       	sbiw	r30, 0x01	; 1
    1164:	36 e1       	ldi	r19, 0x16	; 22
    1166:	30 83       	st	Z, r19
    1168:	31 97       	sbiw	r30, 0x01	; 1
    116a:	37 e1       	ldi	r19, 0x17	; 23
    116c:	30 83       	st	Z, r19
    116e:	31 97       	sbiw	r30, 0x01	; 1
    1170:	38 e1       	ldi	r19, 0x18	; 24
    1172:	30 83       	st	Z, r19
    1174:	31 97       	sbiw	r30, 0x01	; 1
    1176:	39 e1       	ldi	r19, 0x19	; 25
    1178:	30 83       	st	Z, r19
    117a:	31 97       	sbiw	r30, 0x01	; 1
    117c:	30 e2       	ldi	r19, 0x20	; 32
    117e:	30 83       	st	Z, r19
    1180:	31 97       	sbiw	r30, 0x01	; 1
    1182:	31 e2       	ldi	r19, 0x21	; 33
    1184:	30 83       	st	Z, r19
    1186:	31 97       	sbiw	r30, 0x01	; 1
    1188:	20 83       	st	Z, r18
    118a:	31 97       	sbiw	r30, 0x01	; 1
    118c:	23 e2       	ldi	r18, 0x23	; 35
    118e:	20 83       	st	Z, r18
    1190:	31 97       	sbiw	r30, 0x01	; 1
    1192:	40 83       	st	Z, r20
    1194:	31 97       	sbiw	r30, 0x01	; 1
    1196:	50 83       	st	Z, r21
    1198:	31 97       	sbiw	r30, 0x01	; 1
    119a:	26 e2       	ldi	r18, 0x26	; 38
    119c:	20 83       	st	Z, r18
    119e:	31 97       	sbiw	r30, 0x01	; 1
    11a0:	27 e2       	ldi	r18, 0x27	; 39
    11a2:	20 83       	st	Z, r18
    11a4:	31 97       	sbiw	r30, 0x01	; 1
    11a6:	28 e2       	ldi	r18, 0x28	; 40
    11a8:	20 83       	st	Z, r18
    11aa:	31 97       	sbiw	r30, 0x01	; 1
    11ac:	29 e2       	ldi	r18, 0x29	; 41
    11ae:	20 83       	st	Z, r18
    11b0:	31 97       	sbiw	r30, 0x01	; 1
    11b2:	20 e3       	ldi	r18, 0x30	; 48
    11b4:	20 83       	st	Z, r18
    11b6:	31 97       	sbiw	r30, 0x01	; 1
    11b8:	21 e3       	ldi	r18, 0x31	; 49
    11ba:	20 83       	st	Z, r18
    11bc:	89 97       	sbiw	r24, 0x29	; 41
    11be:	08 95       	ret

000011c0 <xPortStartScheduler>:
    11c0:	8c e7       	ldi	r24, 0x7C	; 124
    11c2:	80 93 29 0a 	sts	0x0A29, r24	; 0x800a29 <__TEXT_REGION_LENGTH__+0x700a29>
    11c6:	8f ef       	ldi	r24, 0xFF	; 255
    11c8:	80 93 28 0a 	sts	0x0A28, r24	; 0x800a28 <__TEXT_REGION_LENGTH__+0x700a28>
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	80 93 00 0a 	sts	0x0A00, r24	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
    11d2:	91 e1       	ldi	r25, 0x11	; 17
    11d4:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x700a01>
    11d8:	80 93 07 0a 	sts	0x0A07, r24	; 0x800a07 <__TEXT_REGION_LENGTH__+0x700a07>
    11dc:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    11e0:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    11e4:	cd 91       	ld	r28, X+
    11e6:	cd bf       	out	0x3d, r28	; 61
    11e8:	dd 91       	ld	r29, X+
    11ea:	de bf       	out	0x3e, r29	; 62
    11ec:	ff 91       	pop	r31
    11ee:	ef 91       	pop	r30
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	bf 91       	pop	r27
    11f6:	af 91       	pop	r26
    11f8:	9f 91       	pop	r25
    11fa:	8f 91       	pop	r24
    11fc:	7f 91       	pop	r23
    11fe:	6f 91       	pop	r22
    1200:	5f 91       	pop	r21
    1202:	4f 91       	pop	r20
    1204:	3f 91       	pop	r19
    1206:	2f 91       	pop	r18
    1208:	1f 91       	pop	r17
    120a:	0f 91       	pop	r16
    120c:	ff 90       	pop	r15
    120e:	ef 90       	pop	r14
    1210:	df 90       	pop	r13
    1212:	cf 90       	pop	r12
    1214:	bf 90       	pop	r11
    1216:	af 90       	pop	r10
    1218:	9f 90       	pop	r9
    121a:	8f 90       	pop	r8
    121c:	7f 90       	pop	r7
    121e:	6f 90       	pop	r6
    1220:	5f 90       	pop	r5
    1222:	4f 90       	pop	r4
    1224:	3f 90       	pop	r3
    1226:	2f 90       	pop	r2
    1228:	1f 90       	pop	r1
    122a:	0f 90       	pop	r0
    122c:	0c be       	out	0x3c, r0	; 60
    122e:	0f 90       	pop	r0
    1230:	0b be       	out	0x3b, r0	; 59
    1232:	0f 90       	pop	r0
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	0f 90       	pop	r0
    1238:	08 95       	ret
    123a:	08 95       	ret

0000123c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    123c:	0f 92       	push	r0
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	0f 92       	push	r0
    1244:	0b b6       	in	r0, 0x3b	; 59
    1246:	0f 92       	push	r0
    1248:	0c b6       	in	r0, 0x3c	; 60
    124a:	0f 92       	push	r0
    124c:	1f 92       	push	r1
    124e:	11 24       	eor	r1, r1
    1250:	2f 92       	push	r2
    1252:	3f 92       	push	r3
    1254:	4f 92       	push	r4
    1256:	5f 92       	push	r5
    1258:	6f 92       	push	r6
    125a:	7f 92       	push	r7
    125c:	8f 92       	push	r8
    125e:	9f 92       	push	r9
    1260:	af 92       	push	r10
    1262:	bf 92       	push	r11
    1264:	cf 92       	push	r12
    1266:	df 92       	push	r13
    1268:	ef 92       	push	r14
    126a:	ff 92       	push	r15
    126c:	0f 93       	push	r16
    126e:	1f 93       	push	r17
    1270:	2f 93       	push	r18
    1272:	3f 93       	push	r19
    1274:	4f 93       	push	r20
    1276:	5f 93       	push	r21
    1278:	6f 93       	push	r22
    127a:	7f 93       	push	r23
    127c:	8f 93       	push	r24
    127e:	9f 93       	push	r25
    1280:	af 93       	push	r26
    1282:	bf 93       	push	r27
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	ef 93       	push	r30
    128a:	ff 93       	push	r31
    128c:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    1290:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1294:	0d b6       	in	r0, 0x3d	; 61
    1296:	0d 92       	st	X+, r0
    1298:	0e b6       	in	r0, 0x3e	; 62
    129a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    129c:	0e 94 3e 10 	call	0x207c	; 0x207c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    12a0:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    12a4:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    12a8:	cd 91       	ld	r28, X+
    12aa:	cd bf       	out	0x3d, r28	; 61
    12ac:	dd 91       	ld	r29, X+
    12ae:	de bf       	out	0x3e, r29	; 62
    12b0:	ff 91       	pop	r31
    12b2:	ef 91       	pop	r30
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	bf 91       	pop	r27
    12ba:	af 91       	pop	r26
    12bc:	9f 91       	pop	r25
    12be:	8f 91       	pop	r24
    12c0:	7f 91       	pop	r23
    12c2:	6f 91       	pop	r22
    12c4:	5f 91       	pop	r21
    12c6:	4f 91       	pop	r20
    12c8:	3f 91       	pop	r19
    12ca:	2f 91       	pop	r18
    12cc:	1f 91       	pop	r17
    12ce:	0f 91       	pop	r16
    12d0:	ff 90       	pop	r15
    12d2:	ef 90       	pop	r14
    12d4:	df 90       	pop	r13
    12d6:	cf 90       	pop	r12
    12d8:	bf 90       	pop	r11
    12da:	af 90       	pop	r10
    12dc:	9f 90       	pop	r9
    12de:	8f 90       	pop	r8
    12e0:	7f 90       	pop	r7
    12e2:	6f 90       	pop	r6
    12e4:	5f 90       	pop	r5
    12e6:	4f 90       	pop	r4
    12e8:	3f 90       	pop	r3
    12ea:	2f 90       	pop	r2
    12ec:	1f 90       	pop	r1
    12ee:	0f 90       	pop	r0
    12f0:	0c be       	out	0x3c, r0	; 60
    12f2:	0f 90       	pop	r0
    12f4:	0b be       	out	0x3b, r0	; 59
    12f6:	0f 90       	pop	r0
    12f8:	0f be       	out	0x3f, r0	; 63
    12fa:	0f 90       	pop	r0

	asm volatile ( "ret" );
    12fc:	08 95       	ret

000012fe <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    12fe:	0f 92       	push	r0
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	0f 92       	push	r0
    1306:	0b b6       	in	r0, 0x3b	; 59
    1308:	0f 92       	push	r0
    130a:	0c b6       	in	r0, 0x3c	; 60
    130c:	0f 92       	push	r0
    130e:	1f 92       	push	r1
    1310:	11 24       	eor	r1, r1
    1312:	2f 92       	push	r2
    1314:	3f 92       	push	r3
    1316:	4f 92       	push	r4
    1318:	5f 92       	push	r5
    131a:	6f 92       	push	r6
    131c:	7f 92       	push	r7
    131e:	8f 92       	push	r8
    1320:	9f 92       	push	r9
    1322:	af 92       	push	r10
    1324:	bf 92       	push	r11
    1326:	cf 92       	push	r12
    1328:	df 92       	push	r13
    132a:	ef 92       	push	r14
    132c:	ff 92       	push	r15
    132e:	0f 93       	push	r16
    1330:	1f 93       	push	r17
    1332:	2f 93       	push	r18
    1334:	3f 93       	push	r19
    1336:	4f 93       	push	r20
    1338:	5f 93       	push	r21
    133a:	6f 93       	push	r22
    133c:	7f 93       	push	r23
    133e:	8f 93       	push	r24
    1340:	9f 93       	push	r25
    1342:	af 93       	push	r26
    1344:	bf 93       	push	r27
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	ef 93       	push	r30
    134c:	ff 93       	push	r31
    134e:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    1352:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1356:	0d b6       	in	r0, 0x3d	; 61
    1358:	0d 92       	st	X+, r0
    135a:	0e b6       	in	r0, 0x3e	; 62
    135c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    135e:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <vTaskIncrementTick>
	vTaskSwitchContext();
    1362:	0e 94 3e 10 	call	0x207c	; 0x207c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1366:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    136a:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    136e:	cd 91       	ld	r28, X+
    1370:	cd bf       	out	0x3d, r28	; 61
    1372:	dd 91       	ld	r29, X+
    1374:	de bf       	out	0x3e, r29	; 62
    1376:	ff 91       	pop	r31
    1378:	ef 91       	pop	r30
    137a:	df 91       	pop	r29
    137c:	cf 91       	pop	r28
    137e:	bf 91       	pop	r27
    1380:	af 91       	pop	r26
    1382:	9f 91       	pop	r25
    1384:	8f 91       	pop	r24
    1386:	7f 91       	pop	r23
    1388:	6f 91       	pop	r22
    138a:	5f 91       	pop	r21
    138c:	4f 91       	pop	r20
    138e:	3f 91       	pop	r19
    1390:	2f 91       	pop	r18
    1392:	1f 91       	pop	r17
    1394:	0f 91       	pop	r16
    1396:	ff 90       	pop	r15
    1398:	ef 90       	pop	r14
    139a:	df 90       	pop	r13
    139c:	cf 90       	pop	r12
    139e:	bf 90       	pop	r11
    13a0:	af 90       	pop	r10
    13a2:	9f 90       	pop	r9
    13a4:	8f 90       	pop	r8
    13a6:	7f 90       	pop	r7
    13a8:	6f 90       	pop	r6
    13aa:	5f 90       	pop	r5
    13ac:	4f 90       	pop	r4
    13ae:	3f 90       	pop	r3
    13b0:	2f 90       	pop	r2
    13b2:	1f 90       	pop	r1
    13b4:	0f 90       	pop	r0
    13b6:	0c be       	out	0x3c, r0	; 60
    13b8:	0f 90       	pop	r0
    13ba:	0b be       	out	0x3b, r0	; 59
    13bc:	0f 90       	pop	r0
    13be:	0f be       	out	0x3f, r0	; 63
    13c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    13c2:	08 95       	ret

000013c4 <__vector_49>:
void RT_VECT (void) __attribute__ ((signal, naked));
void RT_VECT (void)
{
	// For the preemptive scheduler, enable a context switch
	#if configUSE_PREEMPTION == 1
		vPortYieldFromTick ();
    13c4:	0e 94 7f 09 	call	0x12fe	; 0x12fe <vPortYieldFromTick>
		asm volatile ( "reti" );
    13c8:	18 95       	reti

000013ca <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    13ca:	cf 93       	push	r28
    13cc:	df 93       	push	r29
    13ce:	ec 01       	movw	r28, r24
    13d0:	88 a1       	ldd	r24, Y+32	; 0x20
    13d2:	81 11       	cpse	r24, r1
    13d4:	0b c0       	rjmp	.+22     	; 0x13ec <prvCopyDataToQueue+0x22>
    13d6:	88 81       	ld	r24, Y
    13d8:	99 81       	ldd	r25, Y+1	; 0x01
    13da:	89 2b       	or	r24, r25
    13dc:	e1 f5       	brne	.+120    	; 0x1456 <prvCopyDataToQueue+0x8c>
    13de:	8a 81       	ldd	r24, Y+2	; 0x02
    13e0:	9b 81       	ldd	r25, Y+3	; 0x03
    13e2:	0e 94 f9 11 	call	0x23f2	; 0x23f2 <vTaskPriorityDisinherit>
    13e6:	1a 82       	std	Y+2, r1	; 0x02
    13e8:	1b 82       	std	Y+3, r1	; 0x03
    13ea:	35 c0       	rjmp	.+106    	; 0x1456 <prvCopyDataToQueue+0x8c>
    13ec:	41 11       	cpse	r20, r1
    13ee:	17 c0       	rjmp	.+46     	; 0x141e <prvCopyDataToQueue+0x54>
    13f0:	48 2f       	mov	r20, r24
    13f2:	50 e0       	ldi	r21, 0x00	; 0
    13f4:	8c 81       	ldd	r24, Y+4	; 0x04
    13f6:	9d 81       	ldd	r25, Y+5	; 0x05
    13f8:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <memcpy>
    13fc:	28 a1       	ldd	r18, Y+32	; 0x20
    13fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1400:	9d 81       	ldd	r25, Y+5	; 0x05
    1402:	82 0f       	add	r24, r18
    1404:	91 1d       	adc	r25, r1
    1406:	8c 83       	std	Y+4, r24	; 0x04
    1408:	9d 83       	std	Y+5, r25	; 0x05
    140a:	2a 81       	ldd	r18, Y+2	; 0x02
    140c:	3b 81       	ldd	r19, Y+3	; 0x03
    140e:	82 17       	cp	r24, r18
    1410:	93 07       	cpc	r25, r19
    1412:	08 f1       	brcs	.+66     	; 0x1456 <prvCopyDataToQueue+0x8c>
    1414:	88 81       	ld	r24, Y
    1416:	99 81       	ldd	r25, Y+1	; 0x01
    1418:	8c 83       	std	Y+4, r24	; 0x04
    141a:	9d 83       	std	Y+5, r25	; 0x05
    141c:	1c c0       	rjmp	.+56     	; 0x1456 <prvCopyDataToQueue+0x8c>
    141e:	48 2f       	mov	r20, r24
    1420:	50 e0       	ldi	r21, 0x00	; 0
    1422:	8e 81       	ldd	r24, Y+6	; 0x06
    1424:	9f 81       	ldd	r25, Y+7	; 0x07
    1426:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <memcpy>
    142a:	88 a1       	ldd	r24, Y+32	; 0x20
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	91 95       	neg	r25
    1430:	81 95       	neg	r24
    1432:	91 09       	sbc	r25, r1
    1434:	2e 81       	ldd	r18, Y+6	; 0x06
    1436:	3f 81       	ldd	r19, Y+7	; 0x07
    1438:	28 0f       	add	r18, r24
    143a:	39 1f       	adc	r19, r25
    143c:	2e 83       	std	Y+6, r18	; 0x06
    143e:	3f 83       	std	Y+7, r19	; 0x07
    1440:	48 81       	ld	r20, Y
    1442:	59 81       	ldd	r21, Y+1	; 0x01
    1444:	24 17       	cp	r18, r20
    1446:	35 07       	cpc	r19, r21
    1448:	30 f4       	brcc	.+12     	; 0x1456 <prvCopyDataToQueue+0x8c>
    144a:	2a 81       	ldd	r18, Y+2	; 0x02
    144c:	3b 81       	ldd	r19, Y+3	; 0x03
    144e:	82 0f       	add	r24, r18
    1450:	93 1f       	adc	r25, r19
    1452:	8e 83       	std	Y+6, r24	; 0x06
    1454:	9f 83       	std	Y+7, r25	; 0x07
    1456:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1458:	8f 5f       	subi	r24, 0xFF	; 255
    145a:	8e 8f       	std	Y+30, r24	; 0x1e
    145c:	df 91       	pop	r29
    145e:	cf 91       	pop	r28
    1460:	08 95       	ret

00001462 <prvCopyDataFromQueue>:
    1462:	fc 01       	movw	r30, r24
    1464:	80 81       	ld	r24, Z
    1466:	91 81       	ldd	r25, Z+1	; 0x01
    1468:	00 97       	sbiw	r24, 0x00	; 0
    146a:	a1 f0       	breq	.+40     	; 0x1494 <prvCopyDataFromQueue+0x32>
    146c:	40 a1       	ldd	r20, Z+32	; 0x20
    146e:	50 e0       	ldi	r21, 0x00	; 0
    1470:	26 81       	ldd	r18, Z+6	; 0x06
    1472:	37 81       	ldd	r19, Z+7	; 0x07
    1474:	24 0f       	add	r18, r20
    1476:	35 1f       	adc	r19, r21
    1478:	26 83       	std	Z+6, r18	; 0x06
    147a:	37 83       	std	Z+7, r19	; 0x07
    147c:	a2 81       	ldd	r26, Z+2	; 0x02
    147e:	b3 81       	ldd	r27, Z+3	; 0x03
    1480:	2a 17       	cp	r18, r26
    1482:	3b 07       	cpc	r19, r27
    1484:	10 f0       	brcs	.+4      	; 0x148a <prvCopyDataFromQueue+0x28>
    1486:	86 83       	std	Z+6, r24	; 0x06
    1488:	97 83       	std	Z+7, r25	; 0x07
    148a:	cb 01       	movw	r24, r22
    148c:	66 81       	ldd	r22, Z+6	; 0x06
    148e:	77 81       	ldd	r23, Z+7	; 0x07
    1490:	0e 94 dd 1c 	call	0x39ba	; 0x39ba <memcpy>
    1494:	08 95       	ret

00001496 <prvUnlockQueue>:
    1496:	0f 93       	push	r16
    1498:	1f 93       	push	r17
    149a:	cf 93       	push	r28
    149c:	df 93       	push	r29
    149e:	ec 01       	movw	r28, r24
    14a0:	0f b6       	in	r0, 0x3f	; 63
    14a2:	f8 94       	cli
    14a4:	0f 92       	push	r0
    14a6:	8a a1       	ldd	r24, Y+34	; 0x22
    14a8:	18 16       	cp	r1, r24
    14aa:	b4 f4       	brge	.+44     	; 0x14d8 <prvUnlockQueue+0x42>
    14ac:	8b 89       	ldd	r24, Y+19	; 0x13
    14ae:	81 11       	cpse	r24, r1
    14b0:	05 c0       	rjmp	.+10     	; 0x14bc <prvUnlockQueue+0x26>
    14b2:	12 c0       	rjmp	.+36     	; 0x14d8 <prvUnlockQueue+0x42>
    14b4:	8b 89       	ldd	r24, Y+19	; 0x13
    14b6:	81 11       	cpse	r24, r1
    14b8:	04 c0       	rjmp	.+8      	; 0x14c2 <prvUnlockQueue+0x2c>
    14ba:	0e c0       	rjmp	.+28     	; 0x14d8 <prvUnlockQueue+0x42>
    14bc:	8e 01       	movw	r16, r28
    14be:	0d 5e       	subi	r16, 0xED	; 237
    14c0:	1f 4f       	sbci	r17, 0xFF	; 255
    14c2:	c8 01       	movw	r24, r16
    14c4:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskRemoveFromEventList>
    14c8:	81 11       	cpse	r24, r1
    14ca:	0e 94 82 11 	call	0x2304	; 0x2304 <vTaskMissedYield>
    14ce:	8a a1       	ldd	r24, Y+34	; 0x22
    14d0:	81 50       	subi	r24, 0x01	; 1
    14d2:	8a a3       	std	Y+34, r24	; 0x22
    14d4:	18 16       	cp	r1, r24
    14d6:	74 f3       	brlt	.-36     	; 0x14b4 <prvUnlockQueue+0x1e>
    14d8:	8f ef       	ldi	r24, 0xFF	; 255
    14da:	8a a3       	std	Y+34, r24	; 0x22
    14dc:	0f 90       	pop	r0
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	0f 92       	push	r0
    14e6:	89 a1       	ldd	r24, Y+33	; 0x21
    14e8:	18 16       	cp	r1, r24
    14ea:	b4 f4       	brge	.+44     	; 0x1518 <prvUnlockQueue+0x82>
    14ec:	88 85       	ldd	r24, Y+8	; 0x08
    14ee:	81 11       	cpse	r24, r1
    14f0:	05 c0       	rjmp	.+10     	; 0x14fc <prvUnlockQueue+0x66>
    14f2:	12 c0       	rjmp	.+36     	; 0x1518 <prvUnlockQueue+0x82>
    14f4:	88 85       	ldd	r24, Y+8	; 0x08
    14f6:	81 11       	cpse	r24, r1
    14f8:	04 c0       	rjmp	.+8      	; 0x1502 <prvUnlockQueue+0x6c>
    14fa:	0e c0       	rjmp	.+28     	; 0x1518 <prvUnlockQueue+0x82>
    14fc:	8e 01       	movw	r16, r28
    14fe:	08 5f       	subi	r16, 0xF8	; 248
    1500:	1f 4f       	sbci	r17, 0xFF	; 255
    1502:	c8 01       	movw	r24, r16
    1504:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskRemoveFromEventList>
    1508:	81 11       	cpse	r24, r1
    150a:	0e 94 82 11 	call	0x2304	; 0x2304 <vTaskMissedYield>
    150e:	89 a1       	ldd	r24, Y+33	; 0x21
    1510:	81 50       	subi	r24, 0x01	; 1
    1512:	89 a3       	std	Y+33, r24	; 0x21
    1514:	18 16       	cp	r1, r24
    1516:	74 f3       	brlt	.-36     	; 0x14f4 <prvUnlockQueue+0x5e>
    1518:	8f ef       	ldi	r24, 0xFF	; 255
    151a:	89 a3       	std	Y+33, r24	; 0x21
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	1f 91       	pop	r17
    1526:	0f 91       	pop	r16
    1528:	08 95       	ret

0000152a <xQueueGenericReset>:
    152a:	1f 93       	push	r17
    152c:	cf 93       	push	r28
    152e:	df 93       	push	r29
    1530:	61 30       	cpi	r22, 0x01	; 1
    1532:	59 f0       	breq	.+22     	; 0x154a <xQueueGenericReset+0x20>
    1534:	fc 01       	movw	r30, r24
    1536:	23 89       	ldd	r18, Z+19	; 0x13
    1538:	30 85       	ldd	r19, Z+8	; 0x08
    153a:	31 11       	cpse	r19, r1
    153c:	2c c0       	rjmp	.+88     	; 0x1596 <xQueueGenericReset+0x6c>
    153e:	11 e0       	ldi	r17, 0x01	; 1
    1540:	21 11       	cpse	r18, r1
    1542:	10 e0       	ldi	r17, 0x00	; 0
    1544:	21 11       	cpse	r18, r1
    1546:	28 c0       	rjmp	.+80     	; 0x1598 <xQueueGenericReset+0x6e>
    1548:	01 c0       	rjmp	.+2      	; 0x154c <xQueueGenericReset+0x22>
    154a:	11 e0       	ldi	r17, 0x01	; 1
    154c:	ec 01       	movw	r28, r24
    154e:	48 81       	ld	r20, Y
    1550:	59 81       	ldd	r21, Y+1	; 0x01
    1552:	28 a1       	ldd	r18, Y+32	; 0x20
    1554:	30 e0       	ldi	r19, 0x00	; 0
    1556:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1558:	62 9f       	mul	r22, r18
    155a:	c0 01       	movw	r24, r0
    155c:	63 9f       	mul	r22, r19
    155e:	90 0d       	add	r25, r0
    1560:	11 24       	eor	r1, r1
    1562:	ba 01       	movw	r22, r20
    1564:	68 0f       	add	r22, r24
    1566:	79 1f       	adc	r23, r25
    1568:	6a 83       	std	Y+2, r22	; 0x02
    156a:	7b 83       	std	Y+3, r23	; 0x03
    156c:	1e 8e       	std	Y+30, r1	; 0x1e
    156e:	4c 83       	std	Y+4, r20	; 0x04
    1570:	5d 83       	std	Y+5, r21	; 0x05
    1572:	82 1b       	sub	r24, r18
    1574:	93 0b       	sbc	r25, r19
    1576:	84 0f       	add	r24, r20
    1578:	95 1f       	adc	r25, r21
    157a:	8e 83       	std	Y+6, r24	; 0x06
    157c:	9f 83       	std	Y+7, r25	; 0x07
    157e:	8f ef       	ldi	r24, 0xFF	; 255
    1580:	89 a3       	std	Y+33, r24	; 0x21
    1582:	8a a3       	std	Y+34, r24	; 0x22
    1584:	ce 01       	movw	r24, r28
    1586:	08 96       	adiw	r24, 0x08	; 8
    1588:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    158c:	ce 01       	movw	r24, r28
    158e:	43 96       	adiw	r24, 0x13	; 19
    1590:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1594:	01 c0       	rjmp	.+2      	; 0x1598 <xQueueGenericReset+0x6e>
    1596:	10 e0       	ldi	r17, 0x00	; 0
    1598:	81 2f       	mov	r24, r17
    159a:	df 91       	pop	r29
    159c:	cf 91       	pop	r28
    159e:	1f 91       	pop	r17
    15a0:	08 95       	ret

000015a2 <xQueueGenericCreate>:
    15a2:	0f 93       	push	r16
    15a4:	1f 93       	push	r17
    15a6:	cf 93       	push	r28
    15a8:	df 93       	push	r29
    15aa:	88 23       	and	r24, r24
    15ac:	01 f1       	breq	.+64     	; 0x15ee <xQueueGenericCreate+0x4c>
    15ae:	06 2f       	mov	r16, r22
    15b0:	18 2f       	mov	r17, r24
    15b2:	83 e2       	ldi	r24, 0x23	; 35
    15b4:	90 e0       	ldi	r25, 0x00	; 0
    15b6:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pvPortMalloc>
    15ba:	ec 01       	movw	r28, r24
    15bc:	89 2b       	or	r24, r25
    15be:	c9 f0       	breq	.+50     	; 0x15f2 <xQueueGenericCreate+0x50>
    15c0:	10 9f       	mul	r17, r16
    15c2:	c0 01       	movw	r24, r0
    15c4:	11 24       	eor	r1, r1
    15c6:	01 96       	adiw	r24, 0x01	; 1
    15c8:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pvPortMalloc>
    15cc:	88 83       	st	Y, r24
    15ce:	99 83       	std	Y+1, r25	; 0x01
    15d0:	89 2b       	or	r24, r25
    15d2:	39 f0       	breq	.+14     	; 0x15e2 <xQueueGenericCreate+0x40>
    15d4:	1f 8f       	std	Y+31, r17	; 0x1f
    15d6:	08 a3       	std	Y+32, r16	; 0x20
    15d8:	61 e0       	ldi	r22, 0x01	; 1
    15da:	ce 01       	movw	r24, r28
    15dc:	0e 94 95 0a 	call	0x152a	; 0x152a <xQueueGenericReset>
    15e0:	08 c0       	rjmp	.+16     	; 0x15f2 <xQueueGenericCreate+0x50>
    15e2:	ce 01       	movw	r24, r28
    15e4:	0e 94 85 07 	call	0xf0a	; 0xf0a <vPortFree>
    15e8:	c0 e0       	ldi	r28, 0x00	; 0
    15ea:	d0 e0       	ldi	r29, 0x00	; 0
    15ec:	02 c0       	rjmp	.+4      	; 0x15f2 <xQueueGenericCreate+0x50>
    15ee:	c0 e0       	ldi	r28, 0x00	; 0
    15f0:	d0 e0       	ldi	r29, 0x00	; 0
    15f2:	ce 01       	movw	r24, r28
    15f4:	df 91       	pop	r29
    15f6:	cf 91       	pop	r28
    15f8:	1f 91       	pop	r17
    15fa:	0f 91       	pop	r16
    15fc:	08 95       	ret

000015fe <xQueueGenericSend>:
    15fe:	af 92       	push	r10
    1600:	bf 92       	push	r11
    1602:	cf 92       	push	r12
    1604:	df 92       	push	r13
    1606:	ef 92       	push	r14
    1608:	ff 92       	push	r15
    160a:	0f 93       	push	r16
    160c:	1f 93       	push	r17
    160e:	cf 93       	push	r28
    1610:	df 93       	push	r29
    1612:	cd b7       	in	r28, 0x3d	; 61
    1614:	de b7       	in	r29, 0x3e	; 62
    1616:	29 97       	sbiw	r28, 0x09	; 9
    1618:	cd bf       	out	0x3d, r28	; 61
    161a:	de bf       	out	0x3e, r29	; 62
    161c:	7c 01       	movw	r14, r24
    161e:	5b 01       	movw	r10, r22
    1620:	2e 83       	std	Y+6, r18	; 0x06
    1622:	3f 83       	std	Y+7, r19	; 0x07
    1624:	48 87       	std	Y+8, r20	; 0x08
    1626:	59 87       	std	Y+9, r21	; 0x09
    1628:	10 e0       	ldi	r17, 0x00	; 0
    162a:	6c 01       	movw	r12, r24
    162c:	88 e0       	ldi	r24, 0x08	; 8
    162e:	c8 0e       	add	r12, r24
    1630:	d1 1c       	adc	r13, r1
    1632:	0f b6       	in	r0, 0x3f	; 63
    1634:	f8 94       	cli
    1636:	0f 92       	push	r0
    1638:	f7 01       	movw	r30, r14
    163a:	96 8d       	ldd	r25, Z+30	; 0x1e
    163c:	87 8d       	ldd	r24, Z+31	; 0x1f
    163e:	98 17       	cp	r25, r24
    1640:	a8 f4       	brcc	.+42     	; 0x166c <xQueueGenericSend+0x6e>
    1642:	40 2f       	mov	r20, r16
    1644:	b5 01       	movw	r22, r10
    1646:	c7 01       	movw	r24, r14
    1648:	0e 94 e5 09 	call	0x13ca	; 0x13ca <prvCopyDataToQueue>
    164c:	f7 01       	movw	r30, r14
    164e:	83 89       	ldd	r24, Z+19	; 0x13
    1650:	88 23       	and	r24, r24
    1652:	41 f0       	breq	.+16     	; 0x1664 <xQueueGenericSend+0x66>
    1654:	c7 01       	movw	r24, r14
    1656:	43 96       	adiw	r24, 0x13	; 19
    1658:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskRemoveFromEventList>
    165c:	81 30       	cpi	r24, 0x01	; 1
    165e:	11 f4       	brne	.+4      	; 0x1664 <xQueueGenericSend+0x66>
    1660:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    1664:	0f 90       	pop	r0
    1666:	0f be       	out	0x3f, r0	; 63
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	56 c0       	rjmp	.+172    	; 0x1718 <xQueueGenericSend+0x11a>
    166c:	8e 81       	ldd	r24, Y+6	; 0x06
    166e:	9f 81       	ldd	r25, Y+7	; 0x07
    1670:	a8 85       	ldd	r26, Y+8	; 0x08
    1672:	b9 85       	ldd	r27, Y+9	; 0x09
    1674:	89 2b       	or	r24, r25
    1676:	8a 2b       	or	r24, r26
    1678:	8b 2b       	or	r24, r27
    167a:	21 f4       	brne	.+8      	; 0x1684 <xQueueGenericSend+0x86>
    167c:	0f 90       	pop	r0
    167e:	0f be       	out	0x3f, r0	; 63
    1680:	80 e0       	ldi	r24, 0x00	; 0
    1682:	4a c0       	rjmp	.+148    	; 0x1718 <xQueueGenericSend+0x11a>
    1684:	11 11       	cpse	r17, r1
    1686:	05 c0       	rjmp	.+10     	; 0x1692 <xQueueGenericSend+0x94>
    1688:	ce 01       	movw	r24, r28
    168a:	01 96       	adiw	r24, 0x01	; 1
    168c:	0e 94 04 11 	call	0x2208	; 0x2208 <vTaskSetTimeOutState>
    1690:	11 e0       	ldi	r17, 0x01	; 1
    1692:	0f 90       	pop	r0
    1694:	0f be       	out	0x3f, r0	; 63
    1696:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <vTaskSuspendAll>
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	0f 92       	push	r0
    16a0:	f7 01       	movw	r30, r14
    16a2:	81 a1       	ldd	r24, Z+33	; 0x21
    16a4:	8f 3f       	cpi	r24, 0xFF	; 255
    16a6:	09 f4       	brne	.+2      	; 0x16aa <xQueueGenericSend+0xac>
    16a8:	11 a2       	std	Z+33, r1	; 0x21
    16aa:	f7 01       	movw	r30, r14
    16ac:	82 a1       	ldd	r24, Z+34	; 0x22
    16ae:	8f 3f       	cpi	r24, 0xFF	; 255
    16b0:	09 f4       	brne	.+2      	; 0x16b4 <xQueueGenericSend+0xb6>
    16b2:	12 a2       	std	Z+34, r1	; 0x22
    16b4:	0f 90       	pop	r0
    16b6:	0f be       	out	0x3f, r0	; 63
    16b8:	be 01       	movw	r22, r28
    16ba:	6a 5f       	subi	r22, 0xFA	; 250
    16bc:	7f 4f       	sbci	r23, 0xFF	; 255
    16be:	ce 01       	movw	r24, r28
    16c0:	01 96       	adiw	r24, 0x01	; 1
    16c2:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskCheckForTimeOut>
    16c6:	81 11       	cpse	r24, r1
    16c8:	21 c0       	rjmp	.+66     	; 0x170c <xQueueGenericSend+0x10e>
    16ca:	0f b6       	in	r0, 0x3f	; 63
    16cc:	f8 94       	cli
    16ce:	0f 92       	push	r0
    16d0:	f7 01       	movw	r30, r14
    16d2:	96 8d       	ldd	r25, Z+30	; 0x1e
    16d4:	0f 90       	pop	r0
    16d6:	0f be       	out	0x3f, r0	; 63
    16d8:	87 8d       	ldd	r24, Z+31	; 0x1f
    16da:	98 13       	cpse	r25, r24
    16dc:	11 c0       	rjmp	.+34     	; 0x1700 <xQueueGenericSend+0x102>
    16de:	4e 81       	ldd	r20, Y+6	; 0x06
    16e0:	5f 81       	ldd	r21, Y+7	; 0x07
    16e2:	68 85       	ldd	r22, Y+8	; 0x08
    16e4:	79 85       	ldd	r23, Y+9	; 0x09
    16e6:	c6 01       	movw	r24, r12
    16e8:	0e 94 9b 10 	call	0x2136	; 0x2136 <vTaskPlaceOnEventList>
    16ec:	c7 01       	movw	r24, r14
    16ee:	0e 94 4b 0a 	call	0x1496	; 0x1496 <prvUnlockQueue>
    16f2:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
    16f6:	81 11       	cpse	r24, r1
    16f8:	9c cf       	rjmp	.-200    	; 0x1632 <xQueueGenericSend+0x34>
    16fa:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    16fe:	99 cf       	rjmp	.-206    	; 0x1632 <xQueueGenericSend+0x34>
    1700:	c7 01       	movw	r24, r14
    1702:	0e 94 4b 0a 	call	0x1496	; 0x1496 <prvUnlockQueue>
    1706:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
    170a:	93 cf       	rjmp	.-218    	; 0x1632 <xQueueGenericSend+0x34>
    170c:	c7 01       	movw	r24, r14
    170e:	0e 94 4b 0a 	call	0x1496	; 0x1496 <prvUnlockQueue>
    1712:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
    1716:	80 e0       	ldi	r24, 0x00	; 0
    1718:	29 96       	adiw	r28, 0x09	; 9
    171a:	cd bf       	out	0x3d, r28	; 61
    171c:	de bf       	out	0x3e, r29	; 62
    171e:	df 91       	pop	r29
    1720:	cf 91       	pop	r28
    1722:	1f 91       	pop	r17
    1724:	0f 91       	pop	r16
    1726:	ff 90       	pop	r15
    1728:	ef 90       	pop	r14
    172a:	df 90       	pop	r13
    172c:	cf 90       	pop	r12
    172e:	bf 90       	pop	r11
    1730:	af 90       	pop	r10
    1732:	08 95       	ret

00001734 <xQueueGenericReceive>:
    1734:	af 92       	push	r10
    1736:	bf 92       	push	r11
    1738:	cf 92       	push	r12
    173a:	df 92       	push	r13
    173c:	ef 92       	push	r14
    173e:	ff 92       	push	r15
    1740:	0f 93       	push	r16
    1742:	1f 93       	push	r17
    1744:	cf 93       	push	r28
    1746:	df 93       	push	r29
    1748:	cd b7       	in	r28, 0x3d	; 61
    174a:	de b7       	in	r29, 0x3e	; 62
    174c:	29 97       	sbiw	r28, 0x09	; 9
    174e:	cd bf       	out	0x3d, r28	; 61
    1750:	de bf       	out	0x3e, r29	; 62
    1752:	7c 01       	movw	r14, r24
    1754:	5b 01       	movw	r10, r22
    1756:	2e 83       	std	Y+6, r18	; 0x06
    1758:	3f 83       	std	Y+7, r19	; 0x07
    175a:	48 87       	std	Y+8, r20	; 0x08
    175c:	59 87       	std	Y+9, r21	; 0x09
    175e:	10 e0       	ldi	r17, 0x00	; 0
    1760:	6c 01       	movw	r12, r24
    1762:	83 e1       	ldi	r24, 0x13	; 19
    1764:	c8 0e       	add	r12, r24
    1766:	d1 1c       	adc	r13, r1
    1768:	0f b6       	in	r0, 0x3f	; 63
    176a:	f8 94       	cli
    176c:	0f 92       	push	r0
    176e:	f7 01       	movw	r30, r14
    1770:	86 8d       	ldd	r24, Z+30	; 0x1e
    1772:	88 23       	and	r24, r24
    1774:	99 f1       	breq	.+102    	; 0x17dc <xQueueGenericReceive+0xa8>
    1776:	c6 80       	ldd	r12, Z+6	; 0x06
    1778:	d7 80       	ldd	r13, Z+7	; 0x07
    177a:	b5 01       	movw	r22, r10
    177c:	c7 01       	movw	r24, r14
    177e:	0e 94 31 0a 	call	0x1462	; 0x1462 <prvCopyDataFromQueue>
    1782:	01 11       	cpse	r16, r1
    1784:	1a c0       	rjmp	.+52     	; 0x17ba <xQueueGenericReceive+0x86>
    1786:	f7 01       	movw	r30, r14
    1788:	86 8d       	ldd	r24, Z+30	; 0x1e
    178a:	81 50       	subi	r24, 0x01	; 1
    178c:	86 8f       	std	Z+30, r24	; 0x1e
    178e:	80 81       	ld	r24, Z
    1790:	91 81       	ldd	r25, Z+1	; 0x01
    1792:	89 2b       	or	r24, r25
    1794:	29 f4       	brne	.+10     	; 0x17a0 <xQueueGenericReceive+0x6c>
    1796:	0e 94 9f 11 	call	0x233e	; 0x233e <xTaskGetCurrentTaskHandle>
    179a:	f7 01       	movw	r30, r14
    179c:	82 83       	std	Z+2, r24	; 0x02
    179e:	93 83       	std	Z+3, r25	; 0x03
    17a0:	f7 01       	movw	r30, r14
    17a2:	80 85       	ldd	r24, Z+8	; 0x08
    17a4:	88 23       	and	r24, r24
    17a6:	b1 f0       	breq	.+44     	; 0x17d4 <xQueueGenericReceive+0xa0>
    17a8:	c7 01       	movw	r24, r14
    17aa:	08 96       	adiw	r24, 0x08	; 8
    17ac:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskRemoveFromEventList>
    17b0:	81 30       	cpi	r24, 0x01	; 1
    17b2:	81 f4       	brne	.+32     	; 0x17d4 <xQueueGenericReceive+0xa0>
    17b4:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    17b8:	0d c0       	rjmp	.+26     	; 0x17d4 <xQueueGenericReceive+0xa0>
    17ba:	f7 01       	movw	r30, r14
    17bc:	c6 82       	std	Z+6, r12	; 0x06
    17be:	d7 82       	std	Z+7, r13	; 0x07
    17c0:	83 89       	ldd	r24, Z+19	; 0x13
    17c2:	88 23       	and	r24, r24
    17c4:	39 f0       	breq	.+14     	; 0x17d4 <xQueueGenericReceive+0xa0>
    17c6:	c7 01       	movw	r24, r14
    17c8:	43 96       	adiw	r24, 0x13	; 19
    17ca:	0e 94 c5 10 	call	0x218a	; 0x218a <xTaskRemoveFromEventList>
    17ce:	81 11       	cpse	r24, r1
    17d0:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	62 c0       	rjmp	.+196    	; 0x18a0 <xQueueGenericReceive+0x16c>
    17dc:	8e 81       	ldd	r24, Y+6	; 0x06
    17de:	9f 81       	ldd	r25, Y+7	; 0x07
    17e0:	a8 85       	ldd	r26, Y+8	; 0x08
    17e2:	b9 85       	ldd	r27, Y+9	; 0x09
    17e4:	89 2b       	or	r24, r25
    17e6:	8a 2b       	or	r24, r26
    17e8:	8b 2b       	or	r24, r27
    17ea:	21 f4       	brne	.+8      	; 0x17f4 <xQueueGenericReceive+0xc0>
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
    17f0:	80 e0       	ldi	r24, 0x00	; 0
    17f2:	56 c0       	rjmp	.+172    	; 0x18a0 <xQueueGenericReceive+0x16c>
    17f4:	11 11       	cpse	r17, r1
    17f6:	05 c0       	rjmp	.+10     	; 0x1802 <xQueueGenericReceive+0xce>
    17f8:	ce 01       	movw	r24, r28
    17fa:	01 96       	adiw	r24, 0x01	; 1
    17fc:	0e 94 04 11 	call	0x2208	; 0x2208 <vTaskSetTimeOutState>
    1800:	11 e0       	ldi	r17, 0x01	; 1
    1802:	0f 90       	pop	r0
    1804:	0f be       	out	0x3f, r0	; 63
    1806:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <vTaskSuspendAll>
    180a:	0f b6       	in	r0, 0x3f	; 63
    180c:	f8 94       	cli
    180e:	0f 92       	push	r0
    1810:	f7 01       	movw	r30, r14
    1812:	81 a1       	ldd	r24, Z+33	; 0x21
    1814:	8f 3f       	cpi	r24, 0xFF	; 255
    1816:	09 f4       	brne	.+2      	; 0x181a <xQueueGenericReceive+0xe6>
    1818:	11 a2       	std	Z+33, r1	; 0x21
    181a:	f7 01       	movw	r30, r14
    181c:	82 a1       	ldd	r24, Z+34	; 0x22
    181e:	8f 3f       	cpi	r24, 0xFF	; 255
    1820:	09 f4       	brne	.+2      	; 0x1824 <xQueueGenericReceive+0xf0>
    1822:	12 a2       	std	Z+34, r1	; 0x22
    1824:	0f 90       	pop	r0
    1826:	0f be       	out	0x3f, r0	; 63
    1828:	be 01       	movw	r22, r28
    182a:	6a 5f       	subi	r22, 0xFA	; 250
    182c:	7f 4f       	sbci	r23, 0xFF	; 255
    182e:	ce 01       	movw	r24, r28
    1830:	01 96       	adiw	r24, 0x01	; 1
    1832:	0e 94 15 11 	call	0x222a	; 0x222a <xTaskCheckForTimeOut>
    1836:	81 11       	cpse	r24, r1
    1838:	2d c0       	rjmp	.+90     	; 0x1894 <xQueueGenericReceive+0x160>
    183a:	0f b6       	in	r0, 0x3f	; 63
    183c:	f8 94       	cli
    183e:	0f 92       	push	r0
    1840:	f7 01       	movw	r30, r14
    1842:	86 8d       	ldd	r24, Z+30	; 0x1e
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63
    1848:	81 11       	cpse	r24, r1
    184a:	1e c0       	rjmp	.+60     	; 0x1888 <xQueueGenericReceive+0x154>
    184c:	80 81       	ld	r24, Z
    184e:	91 81       	ldd	r25, Z+1	; 0x01
    1850:	89 2b       	or	r24, r25
    1852:	49 f4       	brne	.+18     	; 0x1866 <xQueueGenericReceive+0x132>
    1854:	0f b6       	in	r0, 0x3f	; 63
    1856:	f8 94       	cli
    1858:	0f 92       	push	r0
    185a:	82 81       	ldd	r24, Z+2	; 0x02
    185c:	93 81       	ldd	r25, Z+3	; 0x03
    185e:	0e 94 a4 11 	call	0x2348	; 0x2348 <vTaskPriorityInherit>
    1862:	0f 90       	pop	r0
    1864:	0f be       	out	0x3f, r0	; 63
    1866:	4e 81       	ldd	r20, Y+6	; 0x06
    1868:	5f 81       	ldd	r21, Y+7	; 0x07
    186a:	68 85       	ldd	r22, Y+8	; 0x08
    186c:	79 85       	ldd	r23, Y+9	; 0x09
    186e:	c6 01       	movw	r24, r12
    1870:	0e 94 9b 10 	call	0x2136	; 0x2136 <vTaskPlaceOnEventList>
    1874:	c7 01       	movw	r24, r14
    1876:	0e 94 4b 0a 	call	0x1496	; 0x1496 <prvUnlockQueue>
    187a:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
    187e:	81 11       	cpse	r24, r1
    1880:	73 cf       	rjmp	.-282    	; 0x1768 <xQueueGenericReceive+0x34>
    1882:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    1886:	70 cf       	rjmp	.-288    	; 0x1768 <xQueueGenericReceive+0x34>
    1888:	c7 01       	movw	r24, r14
    188a:	0e 94 4b 0a 	call	0x1496	; 0x1496 <prvUnlockQueue>
    188e:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
    1892:	6a cf       	rjmp	.-300    	; 0x1768 <xQueueGenericReceive+0x34>
    1894:	c7 01       	movw	r24, r14
    1896:	0e 94 4b 0a 	call	0x1496	; 0x1496 <prvUnlockQueue>
    189a:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	29 96       	adiw	r28, 0x09	; 9
    18a2:	cd bf       	out	0x3d, r28	; 61
    18a4:	de bf       	out	0x3e, r29	; 62
    18a6:	df 91       	pop	r29
    18a8:	cf 91       	pop	r28
    18aa:	1f 91       	pop	r17
    18ac:	0f 91       	pop	r16
    18ae:	ff 90       	pop	r15
    18b0:	ef 90       	pop	r14
    18b2:	df 90       	pop	r13
    18b4:	cf 90       	pop	r12
    18b6:	bf 90       	pop	r11
    18b8:	af 90       	pop	r10
    18ba:	08 95       	ret

000018bc <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    18bc:	0f b6       	in	r0, 0x3f	; 63
    18be:	f8 94       	cli
    18c0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    18c2:	fc 01       	movw	r30, r24
    18c4:	86 8d       	ldd	r24, Z+30	; 0x1e
	taskEXIT_CRITICAL();
    18c6:	0f 90       	pop	r0
    18c8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    18ca:	08 95       	ret

000018cc <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
    18cc:	c4 e2       	ldi	r28, 0x24	; 36
    18ce:	d1 e3       	ldi	r29, 0x31	; 49
    18d0:	88 81       	ld	r24, Y
    18d2:	82 30       	cpi	r24, 0x02	; 2
    18d4:	e8 f3       	brcs	.-6      	; 0x18d0 <prvIdleTask+0x4>
    18d6:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    18da:	fa cf       	rjmp	.-12     	; 0x18d0 <prvIdleTask+0x4>

000018dc <prvAddCurrentTaskToDelayedList>:
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	6b 01       	movw	r12, r22
    18e6:	7c 01       	movw	r14, r24
    18e8:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <pxCurrentTCB>
    18ec:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    18f0:	62 83       	std	Z+2, r22	; 0x02
    18f2:	73 83       	std	Z+3, r23	; 0x03
    18f4:	84 83       	std	Z+4, r24	; 0x04
    18f6:	95 83       	std	Z+5, r25	; 0x05
    18f8:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    18fc:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1900:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1904:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1908:	c8 16       	cp	r12, r24
    190a:	d9 06       	cpc	r13, r25
    190c:	ea 06       	cpc	r14, r26
    190e:	fb 06       	cpc	r15, r27
    1910:	68 f4       	brcc	.+26     	; 0x192c <prvAddCurrentTaskToDelayedList+0x50>
    1912:	60 91 50 31 	lds	r22, 0x3150	; 0x803150 <pxCurrentTCB>
    1916:	70 91 51 31 	lds	r23, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    191a:	80 91 0a 31 	lds	r24, 0x310A	; 0x80310a <pxOverflowDelayedTaskList>
    191e:	90 91 0b 31 	lds	r25, 0x310B	; 0x80310b <pxOverflowDelayedTaskList+0x1>
    1922:	6e 5f       	subi	r22, 0xFE	; 254
    1924:	7f 4f       	sbci	r23, 0xFF	; 255
    1926:	0e 94 f9 07 	call	0xff2	; 0xff2 <vListInsert>
    192a:	21 c0       	rjmp	.+66     	; 0x196e <prvAddCurrentTaskToDelayedList+0x92>
    192c:	60 91 50 31 	lds	r22, 0x3150	; 0x803150 <pxCurrentTCB>
    1930:	70 91 51 31 	lds	r23, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1934:	80 91 0c 31 	lds	r24, 0x310C	; 0x80310c <pxDelayedTaskList>
    1938:	90 91 0d 31 	lds	r25, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    193c:	6e 5f       	subi	r22, 0xFE	; 254
    193e:	7f 4f       	sbci	r23, 0xFF	; 255
    1940:	0e 94 f9 07 	call	0xff2	; 0xff2 <vListInsert>
    1944:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1948:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    194c:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1950:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1954:	c8 16       	cp	r12, r24
    1956:	d9 06       	cpc	r13, r25
    1958:	ea 06       	cpc	r14, r26
    195a:	fb 06       	cpc	r15, r27
    195c:	40 f4       	brcc	.+16     	; 0x196e <prvAddCurrentTaskToDelayedList+0x92>
    195e:	c0 92 02 20 	sts	0x2002, r12	; 0x802002 <xNextTaskUnblockTime>
    1962:	d0 92 03 20 	sts	0x2003, r13	; 0x802003 <xNextTaskUnblockTime+0x1>
    1966:	e0 92 04 20 	sts	0x2004, r14	; 0x802004 <xNextTaskUnblockTime+0x2>
    196a:	f0 92 05 20 	sts	0x2005, r15	; 0x802005 <xNextTaskUnblockTime+0x3>
    196e:	ff 90       	pop	r15
    1970:	ef 90       	pop	r14
    1972:	df 90       	pop	r13
    1974:	cf 90       	pop	r12
    1976:	08 95       	ret

00001978 <xTaskGenericCreate>:
    1978:	4f 92       	push	r4
    197a:	5f 92       	push	r5
    197c:	6f 92       	push	r6
    197e:	7f 92       	push	r7
    1980:	8f 92       	push	r8
    1982:	9f 92       	push	r9
    1984:	af 92       	push	r10
    1986:	bf 92       	push	r11
    1988:	cf 92       	push	r12
    198a:	df 92       	push	r13
    198c:	ef 92       	push	r14
    198e:	ff 92       	push	r15
    1990:	0f 93       	push	r16
    1992:	1f 93       	push	r17
    1994:	cf 93       	push	r28
    1996:	df 93       	push	r29
    1998:	5c 01       	movw	r10, r24
    199a:	4b 01       	movw	r8, r22
    199c:	3a 01       	movw	r6, r20
    199e:	29 01       	movw	r4, r18
    19a0:	88 e2       	ldi	r24, 0x28	; 40
    19a2:	90 e0       	ldi	r25, 0x00	; 0
    19a4:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pvPortMalloc>
    19a8:	ec 01       	movw	r28, r24
    19aa:	89 2b       	or	r24, r25
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <xTaskGenericCreate+0x38>
    19ae:	d4 c0       	rjmp	.+424    	; 0x1b58 <xTaskGenericCreate+0x1e0>
    19b0:	c1 14       	cp	r12, r1
    19b2:	d1 04       	cpc	r13, r1
    19b4:	09 f0       	breq	.+2      	; 0x19b8 <xTaskGenericCreate+0x40>
    19b6:	cc c0       	rjmp	.+408    	; 0x1b50 <xTaskGenericCreate+0x1d8>
    19b8:	c3 01       	movw	r24, r6
    19ba:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pvPortMalloc>
    19be:	8b 8f       	std	Y+27, r24	; 0x1b
    19c0:	9c 8f       	std	Y+28, r25	; 0x1c
    19c2:	00 97       	sbiw	r24, 0x00	; 0
    19c4:	21 f4       	brne	.+8      	; 0x19ce <xTaskGenericCreate+0x56>
    19c6:	ce 01       	movw	r24, r28
    19c8:	0e 94 85 07 	call	0xf0a	; 0xf0a <vPortFree>
    19cc:	c5 c0       	rjmp	.+394    	; 0x1b58 <xTaskGenericCreate+0x1e0>
    19ce:	a3 01       	movw	r20, r6
    19d0:	61 e1       	ldi	r22, 0x11	; 17
    19d2:	70 e0       	ldi	r23, 0x00	; 0
    19d4:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <memset>
    19d8:	93 01       	movw	r18, r6
    19da:	21 50       	subi	r18, 0x01	; 1
    19dc:	31 09       	sbc	r19, r1
    19de:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19e0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    19e2:	3c 01       	movw	r6, r24
    19e4:	62 0e       	add	r6, r18
    19e6:	73 1e       	adc	r7, r19
    19e8:	4a e0       	ldi	r20, 0x0A	; 10
    19ea:	50 e0       	ldi	r21, 0x00	; 0
    19ec:	b4 01       	movw	r22, r8
    19ee:	ce 01       	movw	r24, r28
    19f0:	4d 96       	adiw	r24, 0x1d	; 29
    19f2:	0e 94 ed 1c 	call	0x39da	; 0x39da <strncpy>
    19f6:	1e a2       	std	Y+38, r1	; 0x26
    19f8:	10 2f       	mov	r17, r16
    19fa:	04 30       	cpi	r16, 0x04	; 4
    19fc:	08 f0       	brcs	.+2      	; 0x1a00 <xTaskGenericCreate+0x88>
    19fe:	13 e0       	ldi	r17, 0x03	; 3
    1a00:	1a 8f       	std	Y+26, r17	; 0x1a
    1a02:	1f a3       	std	Y+39, r17	; 0x27
    1a04:	6e 01       	movw	r12, r28
    1a06:	22 e0       	ldi	r18, 0x02	; 2
    1a08:	c2 0e       	add	r12, r18
    1a0a:	d1 1c       	adc	r13, r1
    1a0c:	c6 01       	movw	r24, r12
    1a0e:	0e 94 ce 07 	call	0xf9c	; 0xf9c <vListInitialiseItem>
    1a12:	ce 01       	movw	r24, r28
    1a14:	0e 96       	adiw	r24, 0x0e	; 14
    1a16:	0e 94 ce 07 	call	0xf9c	; 0xf9c <vListInitialiseItem>
    1a1a:	ca 87       	std	Y+10, r28	; 0x0a
    1a1c:	db 87       	std	Y+11, r29	; 0x0b
    1a1e:	84 e0       	ldi	r24, 0x04	; 4
    1a20:	90 e0       	ldi	r25, 0x00	; 0
    1a22:	a0 e0       	ldi	r26, 0x00	; 0
    1a24:	b0 e0       	ldi	r27, 0x00	; 0
    1a26:	81 1b       	sub	r24, r17
    1a28:	91 09       	sbc	r25, r1
    1a2a:	a1 09       	sbc	r26, r1
    1a2c:	b1 09       	sbc	r27, r1
    1a2e:	8e 87       	std	Y+14, r24	; 0x0e
    1a30:	9f 87       	std	Y+15, r25	; 0x0f
    1a32:	a8 8b       	std	Y+16, r26	; 0x10
    1a34:	b9 8b       	std	Y+17, r27	; 0x11
    1a36:	ce 8b       	std	Y+22, r28	; 0x16
    1a38:	df 8b       	std	Y+23, r29	; 0x17
    1a3a:	a2 01       	movw	r20, r4
    1a3c:	b5 01       	movw	r22, r10
    1a3e:	c3 01       	movw	r24, r6
    1a40:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <pxPortInitialiseStack>
    1a44:	88 83       	st	Y, r24
    1a46:	99 83       	std	Y+1, r25	; 0x01
    1a48:	e1 14       	cp	r14, r1
    1a4a:	f1 04       	cpc	r15, r1
    1a4c:	19 f0       	breq	.+6      	; 0x1a54 <xTaskGenericCreate+0xdc>
    1a4e:	f7 01       	movw	r30, r14
    1a50:	c0 83       	st	Z, r28
    1a52:	d1 83       	std	Z+1, r29	; 0x01
    1a54:	0f b6       	in	r0, 0x3f	; 63
    1a56:	f8 94       	cli
    1a58:	0f 92       	push	r0
    1a5a:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <uxCurrentNumberOfTasks>
    1a5e:	8f 5f       	subi	r24, 0xFF	; 255
    1a60:	80 93 fc 30 	sts	0x30FC, r24	; 0x8030fc <uxCurrentNumberOfTasks>
    1a64:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    1a68:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1a6c:	89 2b       	or	r24, r25
    1a6e:	89 f5       	brne	.+98     	; 0x1ad2 <xTaskGenericCreate+0x15a>
    1a70:	c0 93 50 31 	sts	0x3150, r28	; 0x803150 <pxCurrentTCB>
    1a74:	d0 93 51 31 	sts	0x3151, r29	; 0x803151 <pxCurrentTCB+0x1>
    1a78:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <uxCurrentNumberOfTasks>
    1a7c:	81 30       	cpi	r24, 0x01	; 1
    1a7e:	c1 f5       	brne	.+112    	; 0x1af0 <xTaskGenericCreate+0x178>
    1a80:	84 e2       	ldi	r24, 0x24	; 36
    1a82:	91 e3       	ldi	r25, 0x31	; 49
    1a84:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1a88:	8f e2       	ldi	r24, 0x2F	; 47
    1a8a:	91 e3       	ldi	r25, 0x31	; 49
    1a8c:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1a90:	8a e3       	ldi	r24, 0x3A	; 58
    1a92:	91 e3       	ldi	r25, 0x31	; 49
    1a94:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1a98:	85 e4       	ldi	r24, 0x45	; 69
    1a9a:	91 e3       	ldi	r25, 0x31	; 49
    1a9c:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1aa0:	89 e1       	ldi	r24, 0x19	; 25
    1aa2:	91 e3       	ldi	r25, 0x31	; 49
    1aa4:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1aa8:	8e e0       	ldi	r24, 0x0E	; 14
    1aaa:	91 e3       	ldi	r25, 0x31	; 49
    1aac:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1ab0:	8f ef       	ldi	r24, 0xFF	; 255
    1ab2:	90 e3       	ldi	r25, 0x30	; 48
    1ab4:	0e 94 bd 07 	call	0xf7a	; 0xf7a <vListInitialise>
    1ab8:	89 e1       	ldi	r24, 0x19	; 25
    1aba:	91 e3       	ldi	r25, 0x31	; 49
    1abc:	80 93 0c 31 	sts	0x310C, r24	; 0x80310c <pxDelayedTaskList>
    1ac0:	90 93 0d 31 	sts	0x310D, r25	; 0x80310d <pxDelayedTaskList+0x1>
    1ac4:	8e e0       	ldi	r24, 0x0E	; 14
    1ac6:	91 e3       	ldi	r25, 0x31	; 49
    1ac8:	80 93 0a 31 	sts	0x310A, r24	; 0x80310a <pxOverflowDelayedTaskList>
    1acc:	90 93 0b 31 	sts	0x310B, r25	; 0x80310b <pxOverflowDelayedTaskList+0x1>
    1ad0:	0f c0       	rjmp	.+30     	; 0x1af0 <xTaskGenericCreate+0x178>
    1ad2:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <xSchedulerRunning>
    1ad6:	81 11       	cpse	r24, r1
    1ad8:	0b c0       	rjmp	.+22     	; 0x1af0 <xTaskGenericCreate+0x178>
    1ada:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <pxCurrentTCB>
    1ade:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1ae2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ae4:	08 17       	cp	r16, r24
    1ae6:	20 f0       	brcs	.+8      	; 0x1af0 <xTaskGenericCreate+0x178>
    1ae8:	c0 93 50 31 	sts	0x3150, r28	; 0x803150 <pxCurrentTCB>
    1aec:	d0 93 51 31 	sts	0x3151, r29	; 0x803151 <pxCurrentTCB+0x1>
    1af0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1af2:	90 91 f7 30 	lds	r25, 0x30F7	; 0x8030f7 <uxTopUsedPriority>
    1af6:	98 17       	cp	r25, r24
    1af8:	10 f4       	brcc	.+4      	; 0x1afe <xTaskGenericCreate+0x186>
    1afa:	80 93 f7 30 	sts	0x30F7, r24	; 0x8030f7 <uxTopUsedPriority>
    1afe:	90 91 f0 30 	lds	r25, 0x30F0	; 0x8030f0 <uxTaskNumber>
    1b02:	9f 5f       	subi	r25, 0xFF	; 255
    1b04:	90 93 f0 30 	sts	0x30F0, r25	; 0x8030f0 <uxTaskNumber>
    1b08:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    1b0c:	98 17       	cp	r25, r24
    1b0e:	10 f4       	brcc	.+4      	; 0x1b14 <xTaskGenericCreate+0x19c>
    1b10:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
    1b14:	fb e0       	ldi	r31, 0x0B	; 11
    1b16:	8f 9f       	mul	r24, r31
    1b18:	c0 01       	movw	r24, r0
    1b1a:	11 24       	eor	r1, r1
    1b1c:	b6 01       	movw	r22, r12
    1b1e:	8c 5d       	subi	r24, 0xDC	; 220
    1b20:	9e 4c       	sbci	r25, 0xCE	; 206
    1b22:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>
    1b26:	0f 90       	pop	r0
    1b28:	0f be       	out	0x3f, r0	; 63
    1b2a:	80 91 f5 30 	lds	r24, 0x30F5	; 0x8030f5 <xSchedulerRunning>
    1b2e:	88 23       	and	r24, r24
    1b30:	59 f0       	breq	.+22     	; 0x1b48 <xTaskGenericCreate+0x1d0>
    1b32:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <pxCurrentTCB>
    1b36:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1b3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b3c:	80 17       	cp	r24, r16
    1b3e:	30 f4       	brcc	.+12     	; 0x1b4c <xTaskGenericCreate+0x1d4>
    1b40:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
    1b44:	81 e0       	ldi	r24, 0x01	; 1
    1b46:	09 c0       	rjmp	.+18     	; 0x1b5a <xTaskGenericCreate+0x1e2>
    1b48:	81 e0       	ldi	r24, 0x01	; 1
    1b4a:	07 c0       	rjmp	.+14     	; 0x1b5a <xTaskGenericCreate+0x1e2>
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
    1b4e:	05 c0       	rjmp	.+10     	; 0x1b5a <xTaskGenericCreate+0x1e2>
    1b50:	cb 8e       	std	Y+27, r12	; 0x1b
    1b52:	dc 8e       	std	Y+28, r13	; 0x1c
    1b54:	c6 01       	movw	r24, r12
    1b56:	3b cf       	rjmp	.-394    	; 0x19ce <xTaskGenericCreate+0x56>
    1b58:	8f ef       	ldi	r24, 0xFF	; 255
    1b5a:	df 91       	pop	r29
    1b5c:	cf 91       	pop	r28
    1b5e:	1f 91       	pop	r17
    1b60:	0f 91       	pop	r16
    1b62:	ff 90       	pop	r15
    1b64:	ef 90       	pop	r14
    1b66:	df 90       	pop	r13
    1b68:	cf 90       	pop	r12
    1b6a:	bf 90       	pop	r11
    1b6c:	af 90       	pop	r10
    1b6e:	9f 90       	pop	r9
    1b70:	8f 90       	pop	r8
    1b72:	7f 90       	pop	r7
    1b74:	6f 90       	pop	r6
    1b76:	5f 90       	pop	r5
    1b78:	4f 90       	pop	r4
    1b7a:	08 95       	ret

00001b7c <uxTaskPriorityGet>:
    1b7c:	0f b6       	in	r0, 0x3f	; 63
    1b7e:	f8 94       	cli
    1b80:	0f 92       	push	r0
    1b82:	00 97       	sbiw	r24, 0x00	; 0
    1b84:	21 f4       	brne	.+8      	; 0x1b8e <uxTaskPriorityGet+0x12>
    1b86:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    1b8a:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1b8e:	0f 90       	pop	r0
    1b90:	0f be       	out	0x3f, r0	; 63
    1b92:	fc 01       	movw	r30, r24
    1b94:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b96:	08 95       	ret

00001b98 <vTaskStartScheduler>:
    1b98:	af 92       	push	r10
    1b9a:	bf 92       	push	r11
    1b9c:	cf 92       	push	r12
    1b9e:	df 92       	push	r13
    1ba0:	ef 92       	push	r14
    1ba2:	ff 92       	push	r15
    1ba4:	0f 93       	push	r16
    1ba6:	a1 2c       	mov	r10, r1
    1ba8:	b1 2c       	mov	r11, r1
    1baa:	c1 2c       	mov	r12, r1
    1bac:	d1 2c       	mov	r13, r1
    1bae:	0f 2e       	mov	r0, r31
    1bb0:	fd ef       	ldi	r31, 0xFD	; 253
    1bb2:	ef 2e       	mov	r14, r31
    1bb4:	f0 e3       	ldi	r31, 0x30	; 48
    1bb6:	ff 2e       	mov	r15, r31
    1bb8:	f0 2d       	mov	r31, r0
    1bba:	00 e0       	ldi	r16, 0x00	; 0
    1bbc:	20 e0       	ldi	r18, 0x00	; 0
    1bbe:	30 e0       	ldi	r19, 0x00	; 0
    1bc0:	44 e6       	ldi	r20, 0x64	; 100
    1bc2:	50 e0       	ldi	r21, 0x00	; 0
    1bc4:	6e e4       	ldi	r22, 0x4E	; 78
    1bc6:	70 e2       	ldi	r23, 0x20	; 32
    1bc8:	86 e6       	ldi	r24, 0x66	; 102
    1bca:	9c e0       	ldi	r25, 0x0C	; 12
    1bcc:	0e 94 bc 0c 	call	0x1978	; 0x1978 <xTaskGenericCreate>
    1bd0:	81 30       	cpi	r24, 0x01	; 1
    1bd2:	69 f4       	brne	.+26     	; 0x1bee <vTaskStartScheduler+0x56>
    1bd4:	f8 94       	cli
    1bd6:	80 93 f5 30 	sts	0x30F5, r24	; 0x8030f5 <xSchedulerRunning>
    1bda:	10 92 f8 30 	sts	0x30F8, r1	; 0x8030f8 <xTickCount>
    1bde:	10 92 f9 30 	sts	0x30F9, r1	; 0x8030f9 <xTickCount+0x1>
    1be2:	10 92 fa 30 	sts	0x30FA, r1	; 0x8030fa <xTickCount+0x2>
    1be6:	10 92 fb 30 	sts	0x30FB, r1	; 0x8030fb <xTickCount+0x3>
    1bea:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <xPortStartScheduler>
    1bee:	0f 91       	pop	r16
    1bf0:	ff 90       	pop	r15
    1bf2:	ef 90       	pop	r14
    1bf4:	df 90       	pop	r13
    1bf6:	cf 90       	pop	r12
    1bf8:	bf 90       	pop	r11
    1bfa:	af 90       	pop	r10
    1bfc:	08 95       	ret

00001bfe <vTaskSuspendAll>:
    1bfe:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxSchedulerSuspended>
    1c02:	8f 5f       	subi	r24, 0xFF	; 255
    1c04:	80 93 f4 30 	sts	0x30F4, r24	; 0x8030f4 <uxSchedulerSuspended>
    1c08:	08 95       	ret

00001c0a <xTaskGetTickCount>:
    1c0a:	0f b6       	in	r0, 0x3f	; 63
    1c0c:	f8 94       	cli
    1c0e:	0f 92       	push	r0
    1c10:	60 91 f8 30 	lds	r22, 0x30F8	; 0x8030f8 <xTickCount>
    1c14:	70 91 f9 30 	lds	r23, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1c18:	80 91 fa 30 	lds	r24, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1c1c:	90 91 fb 30 	lds	r25, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63
    1c24:	08 95       	ret

00001c26 <pcTaskGetTaskName>:
	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
	{
	tskTCB *pxTCB;

		/* If null is passed in here then the name of the calling task is being queried. */
		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    1c26:	00 97       	sbiw	r24, 0x00	; 0
    1c28:	21 f4       	brne	.+8      	; 0x1c32 <pcTaskGetTaskName+0xc>
    1c2a:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    1c2e:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
		configASSERT( pxTCB );
		return &( pxTCB->pcTaskName[ 0 ] );
	}
    1c32:	4d 96       	adiw	r24, 0x1d	; 29
    1c34:	08 95       	ret

00001c36 <xTaskGetIdleTaskHandle>:
	{
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
		return xIdleTaskHandle;
	}
    1c36:	80 91 fd 30 	lds	r24, 0x30FD	; 0x8030fd <xIdleTaskHandle>
    1c3a:	90 91 fe 30 	lds	r25, 0x30FE	; 0x8030fe <xIdleTaskHandle+0x1>
    1c3e:	08 95       	ret

00001c40 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1c40:	ff 92       	push	r15
    1c42:	0f 93       	push	r16
    1c44:	1f 93       	push	r17
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1c4a:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxSchedulerSuspended>
    1c4e:	81 11       	cpse	r24, r1
    1c50:	ed c0       	rjmp	.+474    	; 0x1e2c <vTaskIncrementTick+0x1ec>
	{
		++xTickCount;
    1c52:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    1c56:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1c5a:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1c5e:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1c62:	01 96       	adiw	r24, 0x01	; 1
    1c64:	a1 1d       	adc	r26, r1
    1c66:	b1 1d       	adc	r27, r1
    1c68:	80 93 f8 30 	sts	0x30F8, r24	; 0x8030f8 <xTickCount>
    1c6c:	90 93 f9 30 	sts	0x30F9, r25	; 0x8030f9 <xTickCount+0x1>
    1c70:	a0 93 fa 30 	sts	0x30FA, r26	; 0x8030fa <xTickCount+0x2>
    1c74:	b0 93 fb 30 	sts	0x30FB, r27	; 0x8030fb <xTickCount+0x3>
		if( xTickCount == ( portTickType ) 0U )
    1c78:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    1c7c:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1c80:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1c84:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1c88:	89 2b       	or	r24, r25
    1c8a:	8a 2b       	or	r24, r26
    1c8c:	8b 2b       	or	r24, r27
    1c8e:	f1 f5       	brne	.+124    	; 0x1d0c <vTaskIncrementTick+0xcc>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1c90:	80 91 0c 31 	lds	r24, 0x310C	; 0x80310c <pxDelayedTaskList>
    1c94:	90 91 0d 31 	lds	r25, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1c98:	20 91 0a 31 	lds	r18, 0x310A	; 0x80310a <pxOverflowDelayedTaskList>
    1c9c:	30 91 0b 31 	lds	r19, 0x310B	; 0x80310b <pxOverflowDelayedTaskList+0x1>
    1ca0:	20 93 0c 31 	sts	0x310C, r18	; 0x80310c <pxDelayedTaskList>
    1ca4:	30 93 0d 31 	sts	0x310D, r19	; 0x80310d <pxDelayedTaskList+0x1>
			pxOverflowDelayedTaskList = pxTemp;
    1ca8:	80 93 0a 31 	sts	0x310A, r24	; 0x80310a <pxOverflowDelayedTaskList>
    1cac:	90 93 0b 31 	sts	0x310B, r25	; 0x80310b <pxOverflowDelayedTaskList+0x1>
			xNumOfOverflows++;
    1cb0:	80 91 f1 30 	lds	r24, 0x30F1	; 0x8030f1 <xNumOfOverflows>
    1cb4:	8f 5f       	subi	r24, 0xFF	; 255
    1cb6:	80 93 f1 30 	sts	0x30F1, r24	; 0x8030f1 <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1cba:	e0 91 0c 31 	lds	r30, 0x310C	; 0x80310c <pxDelayedTaskList>
    1cbe:	f0 91 0d 31 	lds	r31, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    1cc2:	80 81       	ld	r24, Z
    1cc4:	81 11       	cpse	r24, r1
    1cc6:	0c c0       	rjmp	.+24     	; 0x1ce0 <vTaskIncrementTick+0xa0>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1cc8:	8f ef       	ldi	r24, 0xFF	; 255
    1cca:	9f ef       	ldi	r25, 0xFF	; 255
    1ccc:	dc 01       	movw	r26, r24
    1cce:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1cd2:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1cd6:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1cda:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1cde:	16 c0       	rjmp	.+44     	; 0x1d0c <vTaskIncrementTick+0xcc>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1ce0:	e0 91 0c 31 	lds	r30, 0x310C	; 0x80310c <pxDelayedTaskList>
    1ce4:	f0 91 0d 31 	lds	r31, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    1ce8:	07 80       	ldd	r0, Z+7	; 0x07
    1cea:	f0 85       	ldd	r31, Z+8	; 0x08
    1cec:	e0 2d       	mov	r30, r0
    1cee:	00 84       	ldd	r0, Z+8	; 0x08
    1cf0:	f1 85       	ldd	r31, Z+9	; 0x09
    1cf2:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1cf4:	82 81       	ldd	r24, Z+2	; 0x02
    1cf6:	93 81       	ldd	r25, Z+3	; 0x03
    1cf8:	a4 81       	ldd	r26, Z+4	; 0x04
    1cfa:	b5 81       	ldd	r27, Z+5	; 0x05
    1cfc:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1d00:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d04:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d08:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1d0c:	40 91 f8 30 	lds	r20, 0x30F8	; 0x8030f8 <xTickCount>
    1d10:	50 91 f9 30 	lds	r21, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1d14:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1d18:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1d1c:	80 91 02 20 	lds	r24, 0x2002	; 0x802002 <xNextTaskUnblockTime>
    1d20:	90 91 03 20 	lds	r25, 0x2003	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d24:	a0 91 04 20 	lds	r26, 0x2004	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d28:	b0 91 05 20 	lds	r27, 0x2005	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d2c:	48 17       	cp	r20, r24
    1d2e:	59 07       	cpc	r21, r25
    1d30:	6a 07       	cpc	r22, r26
    1d32:	7b 07       	cpc	r23, r27
    1d34:	08 f4       	brcc	.+2      	; 0x1d38 <vTaskIncrementTick+0xf8>
    1d36:	7f c0       	rjmp	.+254    	; 0x1e36 <vTaskIncrementTick+0x1f6>
    1d38:	e0 91 0c 31 	lds	r30, 0x310C	; 0x80310c <pxDelayedTaskList>
    1d3c:	f0 91 0d 31 	lds	r31, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    1d40:	80 81       	ld	r24, Z
    1d42:	88 23       	and	r24, r24
    1d44:	f9 f0       	breq	.+62     	; 0x1d84 <vTaskIncrementTick+0x144>
    1d46:	e0 91 0c 31 	lds	r30, 0x310C	; 0x80310c <pxDelayedTaskList>
    1d4a:	f0 91 0d 31 	lds	r31, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    1d4e:	07 80       	ldd	r0, Z+7	; 0x07
    1d50:	f0 85       	ldd	r31, Z+8	; 0x08
    1d52:	e0 2d       	mov	r30, r0
    1d54:	c0 85       	ldd	r28, Z+8	; 0x08
    1d56:	d1 85       	ldd	r29, Z+9	; 0x09
    1d58:	8a 81       	ldd	r24, Y+2	; 0x02
    1d5a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d5c:	ac 81       	ldd	r26, Y+4	; 0x04
    1d5e:	bd 81       	ldd	r27, Y+5	; 0x05
    1d60:	40 91 f8 30 	lds	r20, 0x30F8	; 0x8030f8 <xTickCount>
    1d64:	50 91 f9 30 	lds	r21, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1d68:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1d6c:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1d70:	48 17       	cp	r20, r24
    1d72:	59 07       	cpc	r21, r25
    1d74:	6a 07       	cpc	r22, r26
    1d76:	7b 07       	cpc	r23, r27
    1d78:	58 f1       	brcs	.+86     	; 0x1dd0 <vTaskIncrementTick+0x190>
    1d7a:	0f 2e       	mov	r0, r31
    1d7c:	fb e0       	ldi	r31, 0x0B	; 11
    1d7e:	ff 2e       	mov	r15, r31
    1d80:	f0 2d       	mov	r31, r0
    1d82:	2f c0       	rjmp	.+94     	; 0x1de2 <vTaskIncrementTick+0x1a2>
    1d84:	8f ef       	ldi	r24, 0xFF	; 255
    1d86:	9f ef       	ldi	r25, 0xFF	; 255
    1d88:	dc 01       	movw	r26, r24
    1d8a:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1d8e:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1d92:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1d96:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1d9a:	4d c0       	rjmp	.+154    	; 0x1e36 <vTaskIncrementTick+0x1f6>
    1d9c:	e0 91 0c 31 	lds	r30, 0x310C	; 0x80310c <pxDelayedTaskList>
    1da0:	f0 91 0d 31 	lds	r31, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    1da4:	07 80       	ldd	r0, Z+7	; 0x07
    1da6:	f0 85       	ldd	r31, Z+8	; 0x08
    1da8:	e0 2d       	mov	r30, r0
    1daa:	c0 85       	ldd	r28, Z+8	; 0x08
    1dac:	d1 85       	ldd	r29, Z+9	; 0x09
    1dae:	8a 81       	ldd	r24, Y+2	; 0x02
    1db0:	9b 81       	ldd	r25, Y+3	; 0x03
    1db2:	ac 81       	ldd	r26, Y+4	; 0x04
    1db4:	bd 81       	ldd	r27, Y+5	; 0x05
    1db6:	40 91 f8 30 	lds	r20, 0x30F8	; 0x8030f8 <xTickCount>
    1dba:	50 91 f9 30 	lds	r21, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1dbe:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1dc2:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1dc6:	48 17       	cp	r20, r24
    1dc8:	59 07       	cpc	r21, r25
    1dca:	6a 07       	cpc	r22, r26
    1dcc:	7b 07       	cpc	r23, r27
    1dce:	48 f4       	brcc	.+18     	; 0x1de2 <vTaskIncrementTick+0x1a2>
    1dd0:	80 93 02 20 	sts	0x2002, r24	; 0x802002 <xNextTaskUnblockTime>
    1dd4:	90 93 03 20 	sts	0x2003, r25	; 0x802003 <xNextTaskUnblockTime+0x1>
    1dd8:	a0 93 04 20 	sts	0x2004, r26	; 0x802004 <xNextTaskUnblockTime+0x2>
    1ddc:	b0 93 05 20 	sts	0x2005, r27	; 0x802005 <xNextTaskUnblockTime+0x3>
    1de0:	2a c0       	rjmp	.+84     	; 0x1e36 <vTaskIncrementTick+0x1f6>
    1de2:	8e 01       	movw	r16, r28
    1de4:	0e 5f       	subi	r16, 0xFE	; 254
    1de6:	1f 4f       	sbci	r17, 0xFF	; 255
    1de8:	c8 01       	movw	r24, r16
    1dea:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
    1dee:	88 8d       	ldd	r24, Y+24	; 0x18
    1df0:	99 8d       	ldd	r25, Y+25	; 0x19
    1df2:	89 2b       	or	r24, r25
    1df4:	21 f0       	breq	.+8      	; 0x1dfe <vTaskIncrementTick+0x1be>
    1df6:	ce 01       	movw	r24, r28
    1df8:	0e 96       	adiw	r24, 0x0e	; 14
    1dfa:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
    1dfe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e00:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    1e04:	98 17       	cp	r25, r24
    1e06:	10 f4       	brcc	.+4      	; 0x1e0c <vTaskIncrementTick+0x1cc>
    1e08:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
    1e0c:	f8 9e       	mul	r15, r24
    1e0e:	c0 01       	movw	r24, r0
    1e10:	11 24       	eor	r1, r1
    1e12:	b8 01       	movw	r22, r16
    1e14:	8c 5d       	subi	r24, 0xDC	; 220
    1e16:	9e 4c       	sbci	r25, 0xCE	; 206
    1e18:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>
    1e1c:	e0 91 0c 31 	lds	r30, 0x310C	; 0x80310c <pxDelayedTaskList>
    1e20:	f0 91 0d 31 	lds	r31, 0x310D	; 0x80310d <pxDelayedTaskList+0x1>
    1e24:	80 81       	ld	r24, Z
    1e26:	81 11       	cpse	r24, r1
    1e28:	b9 cf       	rjmp	.-142    	; 0x1d9c <vTaskIncrementTick+0x15c>
    1e2a:	ac cf       	rjmp	.-168    	; 0x1d84 <vTaskIncrementTick+0x144>
	}
	else
	{
		++uxMissedTicks;
    1e2c:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <uxMissedTicks>
    1e30:	8f 5f       	subi	r24, 0xFF	; 255
    1e32:	80 93 f3 30 	sts	0x30F3, r24	; 0x8030f3 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    1e36:	df 91       	pop	r29
    1e38:	cf 91       	pop	r28
    1e3a:	1f 91       	pop	r17
    1e3c:	0f 91       	pop	r16
    1e3e:	ff 90       	pop	r15
    1e40:	08 95       	ret

00001e42 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1e42:	cf 92       	push	r12
    1e44:	df 92       	push	r13
    1e46:	ef 92       	push	r14
    1e48:	ff 92       	push	r15
    1e4a:	0f 93       	push	r16
    1e4c:	1f 93       	push	r17
    1e4e:	cf 93       	push	r28
    1e50:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1e52:	0f b6       	in	r0, 0x3f	; 63
    1e54:	f8 94       	cli
    1e56:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1e58:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxSchedulerSuspended>
    1e5c:	81 50       	subi	r24, 0x01	; 1
    1e5e:	80 93 f4 30 	sts	0x30F4, r24	; 0x8030f4 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e62:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxSchedulerSuspended>
    1e66:	81 11       	cpse	r24, r1
    1e68:	60 c0       	rjmp	.+192    	; 0x1f2a <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1e6a:	80 91 fc 30 	lds	r24, 0x30FC	; 0x8030fc <uxCurrentNumberOfTasks>
    1e6e:	81 11       	cpse	r24, r1
    1e70:	2c c0       	rjmp	.+88     	; 0x1eca <xTaskResumeAll+0x88>
    1e72:	5e c0       	rjmp	.+188    	; 0x1f30 <xTaskResumeAll+0xee>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1e74:	d7 01       	movw	r26, r14
    1e76:	17 96       	adiw	r26, 0x07	; 7
    1e78:	ed 91       	ld	r30, X+
    1e7a:	fc 91       	ld	r31, X
    1e7c:	18 97       	sbiw	r26, 0x08	; 8
    1e7e:	c0 85       	ldd	r28, Z+8	; 0x08
    1e80:	d1 85       	ldd	r29, Z+9	; 0x09
					vListRemove( &( pxTCB->xEventListItem ) );
    1e82:	ce 01       	movw	r24, r28
    1e84:	0e 96       	adiw	r24, 0x0e	; 14
    1e86:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e8a:	8e 01       	movw	r16, r28
    1e8c:	0e 5f       	subi	r16, 0xFE	; 254
    1e8e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e90:	c8 01       	movw	r24, r16
    1e92:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e96:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e98:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    1e9c:	98 17       	cp	r25, r24
    1e9e:	10 f4       	brcc	.+4      	; 0x1ea4 <xTaskResumeAll+0x62>
    1ea0:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
    1ea4:	d8 9e       	mul	r13, r24
    1ea6:	c0 01       	movw	r24, r0
    1ea8:	11 24       	eor	r1, r1
    1eaa:	b8 01       	movw	r22, r16
    1eac:	8c 5d       	subi	r24, 0xDC	; 220
    1eae:	9e 4c       	sbci	r25, 0xCE	; 206
    1eb0:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1eb4:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <pxCurrentTCB>
    1eb8:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1ebc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ebe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec0:	98 17       	cp	r25, r24
    1ec2:	70 f0       	brcs	.+28     	; 0x1ee0 <xTaskResumeAll+0x9e>
					{
						xYieldRequired = pdTRUE;
    1ec4:	cc 24       	eor	r12, r12
    1ec6:	c3 94       	inc	r12
    1ec8:	0b c0       	rjmp	.+22     	; 0x1ee0 <xTaskResumeAll+0x9e>
    1eca:	c1 2c       	mov	r12, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1ecc:	0f 2e       	mov	r0, r31
    1ece:	ff ef       	ldi	r31, 0xFF	; 255
    1ed0:	ef 2e       	mov	r14, r31
    1ed2:	f0 e3       	ldi	r31, 0x30	; 48
    1ed4:	ff 2e       	mov	r15, r31
    1ed6:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
    1ed8:	0f 2e       	mov	r0, r31
    1eda:	fb e0       	ldi	r31, 0x0B	; 11
    1edc:	df 2e       	mov	r13, r31
    1ede:	f0 2d       	mov	r31, r0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1ee0:	f7 01       	movw	r30, r14
    1ee2:	80 81       	ld	r24, Z
    1ee4:	81 11       	cpse	r24, r1
    1ee6:	c6 cf       	rjmp	.-116    	; 0x1e74 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ee8:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <uxMissedTicks>
    1eec:	88 23       	and	r24, r24
    1eee:	81 f0       	breq	.+32     	; 0x1f10 <xTaskResumeAll+0xce>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ef0:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <uxMissedTicks>
    1ef4:	88 23       	and	r24, r24
    1ef6:	99 f0       	breq	.+38     	; 0x1f1e <xTaskResumeAll+0xdc>
					{
						vTaskIncrementTick();
    1ef8:	0e 94 20 0e 	call	0x1c40	; 0x1c40 <vTaskIncrementTick>
						--uxMissedTicks;
    1efc:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <uxMissedTicks>
    1f00:	81 50       	subi	r24, 0x01	; 1
    1f02:	80 93 f3 30 	sts	0x30F3, r24	; 0x8030f3 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f06:	80 91 f3 30 	lds	r24, 0x30F3	; 0x8030f3 <uxMissedTicks>
    1f0a:	81 11       	cpse	r24, r1
    1f0c:	f5 cf       	rjmp	.-22     	; 0x1ef8 <xTaskResumeAll+0xb6>
    1f0e:	07 c0       	rjmp	.+14     	; 0x1f1e <xTaskResumeAll+0xdc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1f10:	f1 e0       	ldi	r31, 0x01	; 1
    1f12:	cf 16       	cp	r12, r31
    1f14:	21 f0       	breq	.+8      	; 0x1f1e <xTaskResumeAll+0xdc>
    1f16:	80 91 f2 30 	lds	r24, 0x30F2	; 0x8030f2 <xMissedYield>
    1f1a:	81 30       	cpi	r24, 0x01	; 1
    1f1c:	41 f4       	brne	.+16     	; 0x1f2e <xTaskResumeAll+0xec>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    1f1e:	10 92 f2 30 	sts	0x30F2, r1	; 0x8030f2 <xMissedYield>
					portYIELD_WITHIN_API();
    1f22:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    1f26:	81 e0       	ldi	r24, 0x01	; 1
    1f28:	03 c0       	rjmp	.+6      	; 0x1f30 <xTaskResumeAll+0xee>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1f2a:	80 e0       	ldi	r24, 0x00	; 0
    1f2c:	01 c0       	rjmp	.+2      	; 0x1f30 <xTaskResumeAll+0xee>
    1f2e:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1f30:	0f 90       	pop	r0
    1f32:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1f34:	df 91       	pop	r29
    1f36:	cf 91       	pop	r28
    1f38:	1f 91       	pop	r17
    1f3a:	0f 91       	pop	r16
    1f3c:	ff 90       	pop	r15
    1f3e:	ef 90       	pop	r14
    1f40:	df 90       	pop	r13
    1f42:	cf 90       	pop	r12
    1f44:	08 95       	ret

00001f46 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1f46:	cf 92       	push	r12
    1f48:	df 92       	push	r13
    1f4a:	ef 92       	push	r14
    1f4c:	ff 92       	push	r15
    1f4e:	cf 93       	push	r28
    1f50:	df 93       	push	r29
    1f52:	ec 01       	movw	r28, r24
    1f54:	6a 01       	movw	r12, r20
    1f56:	7b 01       	movw	r14, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1f58:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1f5c:	88 81       	ld	r24, Y
    1f5e:	99 81       	ldd	r25, Y+1	; 0x01
    1f60:	aa 81       	ldd	r26, Y+2	; 0x02
    1f62:	bb 81       	ldd	r27, Y+3	; 0x03
    1f64:	c8 0e       	add	r12, r24
    1f66:	d9 1e       	adc	r13, r25
    1f68:	ea 1e       	adc	r14, r26
    1f6a:	fb 1e       	adc	r15, r27

			if( xTickCount < *pxPreviousWakeTime )
    1f6c:	40 91 f8 30 	lds	r20, 0x30F8	; 0x8030f8 <xTickCount>
    1f70:	50 91 f9 30 	lds	r21, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1f74:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1f78:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1f7c:	48 17       	cp	r20, r24
    1f7e:	59 07       	cpc	r21, r25
    1f80:	6a 07       	cpc	r22, r26
    1f82:	7b 07       	cpc	r23, r27
    1f84:	b8 f4       	brcc	.+46     	; 0x1fb4 <vTaskDelayUntil+0x6e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1f86:	c8 16       	cp	r12, r24
    1f88:	d9 06       	cpc	r13, r25
    1f8a:	ea 06       	cpc	r14, r26
    1f8c:	fb 06       	cpc	r15, r27
    1f8e:	e0 f5       	brcc	.+120    	; 0x2008 <vTaskDelayUntil+0xc2>
    1f90:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    1f94:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1f98:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1f9c:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1fa0:	c8 82       	st	Y, r12
    1fa2:	d9 82       	std	Y+1, r13	; 0x01
    1fa4:	ea 82       	std	Y+2, r14	; 0x02
    1fa6:	fb 82       	std	Y+3, r15	; 0x03

			if( xShouldDelay != pdFALSE )
    1fa8:	8c 15       	cp	r24, r12
    1faa:	9d 05       	cpc	r25, r13
    1fac:	ae 05       	cpc	r26, r14
    1fae:	bf 05       	cpc	r27, r15
    1fb0:	f8 f4       	brcc	.+62     	; 0x1ff0 <vTaskDelayUntil+0xaa>
    1fb2:	13 c0       	rjmp	.+38     	; 0x1fda <vTaskDelayUntil+0x94>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1fb4:	c8 16       	cp	r12, r24
    1fb6:	d9 06       	cpc	r13, r25
    1fb8:	ea 06       	cpc	r14, r26
    1fba:	fb 06       	cpc	r15, r27
    1fbc:	00 f1       	brcs	.+64     	; 0x1ffe <vTaskDelayUntil+0xb8>
    1fbe:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    1fc2:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    1fc6:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    1fca:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    1fce:	8c 15       	cp	r24, r12
    1fd0:	9d 05       	cpc	r25, r13
    1fd2:	ae 05       	cpc	r26, r14
    1fd4:	bf 05       	cpc	r27, r15
    1fd6:	98 f0       	brcs	.+38     	; 0x1ffe <vTaskDelayUntil+0xb8>
    1fd8:	17 c0       	rjmp	.+46     	; 0x2008 <vTaskDelayUntil+0xc2>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1fda:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    1fde:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    1fe2:	02 96       	adiw	r24, 0x02	; 2
    1fe4:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1fe8:	c7 01       	movw	r24, r14
    1fea:	b6 01       	movw	r22, r12
    1fec:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1ff0:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ff4:	81 11       	cpse	r24, r1
    1ff6:	0d c0       	rjmp	.+26     	; 0x2012 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
    1ff8:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
		}
	}
    1ffc:	0a c0       	rjmp	.+20     	; 0x2012 <vTaskDelayUntil+0xcc>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1ffe:	c8 82       	st	Y, r12
    2000:	d9 82       	std	Y+1, r13	; 0x01
    2002:	ea 82       	std	Y+2, r14	; 0x02
    2004:	fb 82       	std	Y+3, r15	; 0x03
    2006:	e9 cf       	rjmp	.-46     	; 0x1fda <vTaskDelayUntil+0x94>
    2008:	c8 82       	st	Y, r12
    200a:	d9 82       	std	Y+1, r13	; 0x01
    200c:	ea 82       	std	Y+2, r14	; 0x02
    200e:	fb 82       	std	Y+3, r15	; 0x03
    2010:	ef cf       	rjmp	.-34     	; 0x1ff0 <vTaskDelayUntil+0xaa>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	ff 90       	pop	r15
    2018:	ef 90       	pop	r14
    201a:	df 90       	pop	r13
    201c:	cf 90       	pop	r12
    201e:	08 95       	ret

00002020 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2020:	cf 92       	push	r12
    2022:	df 92       	push	r13
    2024:	ef 92       	push	r14
    2026:	ff 92       	push	r15
    2028:	6b 01       	movw	r12, r22
    202a:	7c 01       	movw	r14, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    202c:	67 2b       	or	r22, r23
    202e:	68 2b       	or	r22, r24
    2030:	69 2b       	or	r22, r25
    2032:	e9 f0       	breq	.+58     	; 0x206e <vTaskDelay+0x4e>
		{
			vTaskSuspendAll();
    2034:	0e 94 ff 0d 	call	0x1bfe	; 0x1bfe <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2038:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    203c:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    2040:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    2044:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    2048:	c8 0e       	add	r12, r24
    204a:	d9 1e       	adc	r13, r25
    204c:	ea 1e       	adc	r14, r26
    204e:	fb 1e       	adc	r15, r27

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2050:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    2054:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    2058:	02 96       	adiw	r24, 0x02	; 2
    205a:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    205e:	c7 01       	movw	r24, r14
    2060:	b6 01       	movw	r22, r12
    2062:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2066:	0e 94 21 0f 	call	0x1e42	; 0x1e42 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    206a:	81 11       	cpse	r24, r1
    206c:	02 c0       	rjmp	.+4      	; 0x2072 <vTaskDelay+0x52>
		{
			portYIELD_WITHIN_API();
    206e:	0e 94 1e 09 	call	0x123c	; 0x123c <vPortYield>
		}
	}
    2072:	ff 90       	pop	r15
    2074:	ef 90       	pop	r14
    2076:	df 90       	pop	r13
    2078:	cf 90       	pop	r12
    207a:	08 95       	ret

0000207c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    207c:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxSchedulerSuspended>
    2080:	81 11       	cpse	r24, r1
    2082:	0c c0       	rjmp	.+24     	; 0x209c <vTaskSwitchContext+0x20>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    2084:	e0 91 f6 30 	lds	r30, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    2088:	4b e0       	ldi	r20, 0x0B	; 11
    208a:	e4 9f       	mul	r30, r20
    208c:	f0 01       	movw	r30, r0
    208e:	11 24       	eor	r1, r1
    2090:	ec 5d       	subi	r30, 0xDC	; 220
    2092:	fe 4c       	sbci	r31, 0xCE	; 206
    2094:	80 81       	ld	r24, Z
    2096:	88 23       	and	r24, r24
    2098:	29 f0       	breq	.+10     	; 0x20a4 <vTaskSwitchContext+0x28>
    209a:	14 c0       	rjmp	.+40     	; 0x20c4 <vTaskSwitchContext+0x48>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    209c:	81 e0       	ldi	r24, 0x01	; 1
    209e:	80 93 f2 30 	sts	0x30F2, r24	; 0x8030f2 <xMissedYield>
    20a2:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20a4:	9b e0       	ldi	r25, 0x0B	; 11
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    20a6:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    20aa:	81 50       	subi	r24, 0x01	; 1
    20ac:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20b0:	e0 91 f6 30 	lds	r30, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    20b4:	9e 9f       	mul	r25, r30
    20b6:	f0 01       	movw	r30, r0
    20b8:	11 24       	eor	r1, r1
    20ba:	ec 5d       	subi	r30, 0xDC	; 220
    20bc:	fe 4c       	sbci	r31, 0xCE	; 206
    20be:	80 81       	ld	r24, Z
    20c0:	88 23       	and	r24, r24
    20c2:	89 f3       	breq	.-30     	; 0x20a6 <vTaskSwitchContext+0x2a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    20c4:	80 91 f6 30 	lds	r24, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    20c8:	28 2f       	mov	r18, r24
    20ca:	30 e0       	ldi	r19, 0x00	; 0
    20cc:	4b e0       	ldi	r20, 0x0B	; 11
    20ce:	84 9f       	mul	r24, r20
    20d0:	c0 01       	movw	r24, r0
    20d2:	11 24       	eor	r1, r1
    20d4:	dc 01       	movw	r26, r24
    20d6:	ac 5d       	subi	r26, 0xDC	; 220
    20d8:	be 4c       	sbci	r27, 0xCE	; 206
    20da:	11 96       	adiw	r26, 0x01	; 1
    20dc:	ed 91       	ld	r30, X+
    20de:	fc 91       	ld	r31, X
    20e0:	12 97       	sbiw	r26, 0x02	; 2
    20e2:	04 80       	ldd	r0, Z+4	; 0x04
    20e4:	f5 81       	ldd	r31, Z+5	; 0x05
    20e6:	e0 2d       	mov	r30, r0
    20e8:	11 96       	adiw	r26, 0x01	; 1
    20ea:	ed 93       	st	X+, r30
    20ec:	fc 93       	st	X, r31
    20ee:	12 97       	sbiw	r26, 0x02	; 2
    20f0:	89 5d       	subi	r24, 0xD9	; 217
    20f2:	9e 4c       	sbci	r25, 0xCE	; 206
    20f4:	e8 17       	cp	r30, r24
    20f6:	f9 07       	cpc	r31, r25
    20f8:	61 f4       	brne	.+24     	; 0x2112 <vTaskSwitchContext+0x96>
    20fa:	84 81       	ldd	r24, Z+4	; 0x04
    20fc:	95 81       	ldd	r25, Z+5	; 0x05
    20fe:	4b e0       	ldi	r20, 0x0B	; 11
    2100:	42 9f       	mul	r20, r18
    2102:	f0 01       	movw	r30, r0
    2104:	43 9f       	mul	r20, r19
    2106:	f0 0d       	add	r31, r0
    2108:	11 24       	eor	r1, r1
    210a:	ec 5d       	subi	r30, 0xDC	; 220
    210c:	fe 4c       	sbci	r31, 0xCE	; 206
    210e:	81 83       	std	Z+1, r24	; 0x01
    2110:	92 83       	std	Z+2, r25	; 0x02
    2112:	8b e0       	ldi	r24, 0x0B	; 11
    2114:	82 9f       	mul	r24, r18
    2116:	f0 01       	movw	r30, r0
    2118:	83 9f       	mul	r24, r19
    211a:	f0 0d       	add	r31, r0
    211c:	11 24       	eor	r1, r1
    211e:	ec 5d       	subi	r30, 0xDC	; 220
    2120:	fe 4c       	sbci	r31, 0xCE	; 206
    2122:	01 80       	ldd	r0, Z+1	; 0x01
    2124:	f2 81       	ldd	r31, Z+2	; 0x02
    2126:	e0 2d       	mov	r30, r0
    2128:	80 85       	ldd	r24, Z+8	; 0x08
    212a:	91 85       	ldd	r25, Z+9	; 0x09
    212c:	80 93 50 31 	sts	0x3150, r24	; 0x803150 <pxCurrentTCB>
    2130:	90 93 51 31 	sts	0x3151, r25	; 0x803151 <pxCurrentTCB+0x1>
    2134:	08 95       	ret

00002136 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2136:	cf 92       	push	r12
    2138:	df 92       	push	r13
    213a:	ef 92       	push	r14
    213c:	ff 92       	push	r15
    213e:	6a 01       	movw	r12, r20
    2140:	7b 01       	movw	r14, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2142:	60 91 50 31 	lds	r22, 0x3150	; 0x803150 <pxCurrentTCB>
    2146:	70 91 51 31 	lds	r23, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    214a:	62 5f       	subi	r22, 0xF2	; 242
    214c:	7f 4f       	sbci	r23, 0xFF	; 255
    214e:	0e 94 f9 07 	call	0xff2	; 0xff2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2152:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    2156:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    215a:	02 96       	adiw	r24, 0x02	; 2
    215c:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2160:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    2164:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    2168:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    216c:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2170:	bc 01       	movw	r22, r24
    2172:	cd 01       	movw	r24, r26
    2174:	6c 0d       	add	r22, r12
    2176:	7d 1d       	adc	r23, r13
    2178:	8e 1d       	adc	r24, r14
    217a:	9f 1d       	adc	r25, r15
    217c:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2180:	ff 90       	pop	r15
    2182:	ef 90       	pop	r14
    2184:	df 90       	pop	r13
    2186:	cf 90       	pop	r12
    2188:	08 95       	ret

0000218a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    218a:	0f 93       	push	r16
    218c:	1f 93       	push	r17
    218e:	cf 93       	push	r28
    2190:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2192:	dc 01       	movw	r26, r24
    2194:	17 96       	adiw	r26, 0x07	; 7
    2196:	ed 91       	ld	r30, X+
    2198:	fc 91       	ld	r31, X
    219a:	18 97       	sbiw	r26, 0x08	; 8
    219c:	c0 85       	ldd	r28, Z+8	; 0x08
    219e:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    21a0:	8e 01       	movw	r16, r28
    21a2:	02 5f       	subi	r16, 0xF2	; 242
    21a4:	1f 4f       	sbci	r17, 0xFF	; 255
    21a6:	c8 01       	movw	r24, r16
    21a8:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21ac:	80 91 f4 30 	lds	r24, 0x30F4	; 0x8030f4 <uxSchedulerSuspended>
    21b0:	81 11       	cpse	r24, r1
    21b2:	16 c0       	rjmp	.+44     	; 0x21e0 <xTaskRemoveFromEventList+0x56>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    21b4:	0c 50       	subi	r16, 0x0C	; 12
    21b6:	11 09       	sbc	r17, r1
    21b8:	c8 01       	movw	r24, r16
    21ba:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    21be:	8a 8d       	ldd	r24, Y+26	; 0x1a
    21c0:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    21c4:	98 17       	cp	r25, r24
    21c6:	10 f4       	brcc	.+4      	; 0x21cc <xTaskRemoveFromEventList+0x42>
    21c8:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
    21cc:	bb e0       	ldi	r27, 0x0B	; 11
    21ce:	8b 9f       	mul	r24, r27
    21d0:	c0 01       	movw	r24, r0
    21d2:	11 24       	eor	r1, r1
    21d4:	b8 01       	movw	r22, r16
    21d6:	8c 5d       	subi	r24, 0xDC	; 220
    21d8:	9e 4c       	sbci	r25, 0xCE	; 206
    21da:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>
    21de:	05 c0       	rjmp	.+10     	; 0x21ea <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    21e0:	b8 01       	movw	r22, r16
    21e2:	8f ef       	ldi	r24, 0xFF	; 255
    21e4:	90 e3       	ldi	r25, 0x30	; 48
    21e6:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    21ea:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <pxCurrentTCB>
    21ee:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    21f2:	81 e0       	ldi	r24, 0x01	; 1
    21f4:	2a 8d       	ldd	r18, Y+26	; 0x1a
    21f6:	92 8d       	ldd	r25, Z+26	; 0x1a
    21f8:	29 17       	cp	r18, r25
    21fa:	08 f4       	brcc	.+2      	; 0x21fe <xTaskRemoveFromEventList+0x74>
    21fc:	80 e0       	ldi	r24, 0x00	; 0
}
    21fe:	df 91       	pop	r29
    2200:	cf 91       	pop	r28
    2202:	1f 91       	pop	r17
    2204:	0f 91       	pop	r16
    2206:	08 95       	ret

00002208 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2208:	20 91 f1 30 	lds	r18, 0x30F1	; 0x8030f1 <xNumOfOverflows>
    220c:	fc 01       	movw	r30, r24
    220e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2210:	40 91 f8 30 	lds	r20, 0x30F8	; 0x8030f8 <xTickCount>
    2214:	50 91 f9 30 	lds	r21, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    2218:	60 91 fa 30 	lds	r22, 0x30FA	; 0x8030fa <xTickCount+0x2>
    221c:	70 91 fb 30 	lds	r23, 0x30FB	; 0x8030fb <xTickCount+0x3>
    2220:	41 83       	std	Z+1, r20	; 0x01
    2222:	52 83       	std	Z+2, r21	; 0x02
    2224:	63 83       	std	Z+3, r22	; 0x03
    2226:	74 83       	std	Z+4, r23	; 0x04
    2228:	08 95       	ret

0000222a <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    222a:	8f 92       	push	r8
    222c:	9f 92       	push	r9
    222e:	af 92       	push	r10
    2230:	bf 92       	push	r11
    2232:	cf 92       	push	r12
    2234:	df 92       	push	r13
    2236:	ef 92       	push	r14
    2238:	ff 92       	push	r15
    223a:	0f 93       	push	r16
    223c:	1f 93       	push	r17
    223e:	cf 93       	push	r28
    2240:	df 93       	push	r29
    2242:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2244:	0f b6       	in	r0, 0x3f	; 63
    2246:	f8 94       	cli
    2248:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    224a:	80 91 f1 30 	lds	r24, 0x30F1	; 0x8030f1 <xNumOfOverflows>
    224e:	90 81       	ld	r25, Z
    2250:	98 17       	cp	r25, r24
    2252:	89 f0       	breq	.+34     	; 0x2276 <xTaskCheckForTimeOut+0x4c>
    2254:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    2258:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    225c:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    2260:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    2264:	01 81       	ldd	r16, Z+1	; 0x01
    2266:	12 81       	ldd	r17, Z+2	; 0x02
    2268:	23 81       	ldd	r18, Z+3	; 0x03
    226a:	34 81       	ldd	r19, Z+4	; 0x04
    226c:	80 17       	cp	r24, r16
    226e:	91 07       	cpc	r25, r17
    2270:	a2 07       	cpc	r26, r18
    2272:	b3 07       	cpc	r27, r19
    2274:	a8 f5       	brcc	.+106    	; 0x22e0 <xTaskCheckForTimeOut+0xb6>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2276:	80 91 f8 30 	lds	r24, 0x30F8	; 0x8030f8 <xTickCount>
    227a:	90 91 f9 30 	lds	r25, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    227e:	a0 91 fa 30 	lds	r26, 0x30FA	; 0x8030fa <xTickCount+0x2>
    2282:	b0 91 fb 30 	lds	r27, 0x30FB	; 0x8030fb <xTickCount+0x3>
    2286:	c1 80       	ldd	r12, Z+1	; 0x01
    2288:	d2 80       	ldd	r13, Z+2	; 0x02
    228a:	e3 80       	ldd	r14, Z+3	; 0x03
    228c:	f4 80       	ldd	r15, Z+4	; 0x04
    228e:	eb 01       	movw	r28, r22
    2290:	08 81       	ld	r16, Y
    2292:	19 81       	ldd	r17, Y+1	; 0x01
    2294:	2a 81       	ldd	r18, Y+2	; 0x02
    2296:	3b 81       	ldd	r19, Y+3	; 0x03
    2298:	8c 19       	sub	r24, r12
    229a:	9d 09       	sbc	r25, r13
    229c:	ae 09       	sbc	r26, r14
    229e:	bf 09       	sbc	r27, r15
    22a0:	80 17       	cp	r24, r16
    22a2:	91 07       	cpc	r25, r17
    22a4:	a2 07       	cpc	r26, r18
    22a6:	b3 07       	cpc	r27, r19
    22a8:	e8 f4       	brcc	.+58     	; 0x22e4 <xTaskCheckForTimeOut+0xba>
    22aa:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    22ac:	80 90 f8 30 	lds	r8, 0x30F8	; 0x8030f8 <xTickCount>
    22b0:	90 90 f9 30 	lds	r9, 0x30F9	; 0x8030f9 <xTickCount+0x1>
    22b4:	a0 90 fa 30 	lds	r10, 0x30FA	; 0x8030fa <xTickCount+0x2>
    22b8:	b0 90 fb 30 	lds	r11, 0x30FB	; 0x8030fb <xTickCount+0x3>
    22bc:	b5 01       	movw	r22, r10
    22be:	a4 01       	movw	r20, r8
    22c0:	4c 19       	sub	r20, r12
    22c2:	5d 09       	sbc	r21, r13
    22c4:	6e 09       	sbc	r22, r14
    22c6:	7f 09       	sbc	r23, r15
    22c8:	04 1b       	sub	r16, r20
    22ca:	15 0b       	sbc	r17, r21
    22cc:	26 0b       	sbc	r18, r22
    22ce:	37 0b       	sbc	r19, r23
    22d0:	08 83       	st	Y, r16
    22d2:	19 83       	std	Y+1, r17	; 0x01
    22d4:	2a 83       	std	Y+2, r18	; 0x02
    22d6:	3b 83       	std	Y+3, r19	; 0x03
			vTaskSetTimeOutState( pxTimeOut );
    22d8:	0e 94 04 11 	call	0x2208	; 0x2208 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    22dc:	80 e0       	ldi	r24, 0x00	; 0
    22de:	03 c0       	rjmp	.+6      	; 0x22e6 <xTaskCheckForTimeOut+0xbc>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    22e0:	81 e0       	ldi	r24, 0x01	; 1
    22e2:	01 c0       	rjmp	.+2      	; 0x22e6 <xTaskCheckForTimeOut+0xbc>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    22e4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    22e6:	0f 90       	pop	r0
    22e8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    22ea:	df 91       	pop	r29
    22ec:	cf 91       	pop	r28
    22ee:	1f 91       	pop	r17
    22f0:	0f 91       	pop	r16
    22f2:	ff 90       	pop	r15
    22f4:	ef 90       	pop	r14
    22f6:	df 90       	pop	r13
    22f8:	cf 90       	pop	r12
    22fa:	bf 90       	pop	r11
    22fc:	af 90       	pop	r10
    22fe:	9f 90       	pop	r9
    2300:	8f 90       	pop	r8
    2302:	08 95       	ret

00002304 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2304:	81 e0       	ldi	r24, 0x01	; 1
    2306:	80 93 f2 30 	sts	0x30F2, r24	; 0x8030f2 <xMissedYield>
    230a:	08 95       	ret

0000230c <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    230c:	00 97       	sbiw	r24, 0x00	; 0
    230e:	21 f4       	brne	.+8      	; 0x2318 <uxTaskGetStackHighWaterMark+0xc>
    2310:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    2314:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    2318:	dc 01       	movw	r26, r24
    231a:	5b 96       	adiw	r26, 0x1b	; 27
    231c:	ed 91       	ld	r30, X+
    231e:	fc 91       	ld	r31, X
    2320:	5c 97       	sbiw	r26, 0x1c	; 28

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2322:	80 81       	ld	r24, Z
    2324:	81 31       	cpi	r24, 0x11	; 17
    2326:	41 f4       	brne	.+16     	; 0x2338 <uxTaskGetStackHighWaterMark+0x2c>
    2328:	31 96       	adiw	r30, 0x01	; 1
    232a:	80 e0       	ldi	r24, 0x00	; 0
    232c:	90 e0       	ldi	r25, 0x00	; 0
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    232e:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    2330:	21 91       	ld	r18, Z+
    2332:	21 31       	cpi	r18, 0x11	; 17
    2334:	e1 f3       	breq	.-8      	; 0x232e <uxTaskGetStackHighWaterMark+0x22>
    2336:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    2338:	80 e0       	ldi	r24, 0x00	; 0
    233a:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    233c:	08 95       	ret

0000233e <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    233e:	80 91 50 31 	lds	r24, 0x3150	; 0x803150 <pxCurrentTCB>
    2342:	90 91 51 31 	lds	r25, 0x3151	; 0x803151 <pxCurrentTCB+0x1>

		return xReturn;
	}
    2346:	08 95       	ret

00002348 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    2348:	0f 93       	push	r16
    234a:	1f 93       	push	r17
    234c:	cf 93       	push	r28
    234e:	df 93       	push	r29
    2350:	fc 01       	movw	r30, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    2352:	22 8d       	ldd	r18, Z+26	; 0x1a
    2354:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    2358:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    235c:	5a 96       	adiw	r26, 0x1a	; 26
    235e:	8c 91       	ld	r24, X
    2360:	28 17       	cp	r18, r24
    2362:	08 f0       	brcs	.+2      	; 0x2366 <vTaskPriorityInherit+0x1e>
    2364:	41 c0       	rjmp	.+130    	; 0x23e8 <vTaskPriorityInherit+0xa0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    2366:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    236a:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    236e:	5a 96       	adiw	r26, 0x1a	; 26
    2370:	3c 91       	ld	r19, X
    2372:	84 e0       	ldi	r24, 0x04	; 4
    2374:	90 e0       	ldi	r25, 0x00	; 0
    2376:	a0 e0       	ldi	r26, 0x00	; 0
    2378:	b0 e0       	ldi	r27, 0x00	; 0
    237a:	83 1b       	sub	r24, r19
    237c:	91 09       	sbc	r25, r1
    237e:	a1 09       	sbc	r26, r1
    2380:	b1 09       	sbc	r27, r1
    2382:	86 87       	std	Z+14, r24	; 0x0e
    2384:	97 87       	std	Z+15, r25	; 0x0f
    2386:	a0 8b       	std	Z+16, r26	; 0x10
    2388:	b1 8b       	std	Z+17, r27	; 0x11

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    238a:	8b e0       	ldi	r24, 0x0B	; 11
    238c:	28 9f       	mul	r18, r24
    238e:	90 01       	movw	r18, r0
    2390:	11 24       	eor	r1, r1
    2392:	2c 5d       	subi	r18, 0xDC	; 220
    2394:	3e 4c       	sbci	r19, 0xCE	; 206
    2396:	84 85       	ldd	r24, Z+12	; 0x0c
    2398:	95 85       	ldd	r25, Z+13	; 0x0d
    239a:	82 17       	cp	r24, r18
    239c:	93 07       	cpc	r25, r19
    239e:	e9 f4       	brne	.+58     	; 0x23da <vTaskPriorityInherit+0x92>
    23a0:	8f 01       	movw	r16, r30
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
    23a2:	ef 01       	movw	r28, r30
    23a4:	22 96       	adiw	r28, 0x02	; 2
    23a6:	ce 01       	movw	r24, r28
    23a8:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    23ac:	e0 91 50 31 	lds	r30, 0x3150	; 0x803150 <pxCurrentTCB>
    23b0:	f0 91 51 31 	lds	r31, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    23b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    23b6:	f8 01       	movw	r30, r16
    23b8:	82 8f       	std	Z+26, r24	; 0x1a
				prvAddTaskToReadyQueue( pxTCB );
    23ba:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    23be:	98 17       	cp	r25, r24
    23c0:	10 f4       	brcc	.+4      	; 0x23c6 <vTaskPriorityInherit+0x7e>
    23c2:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
    23c6:	fb e0       	ldi	r31, 0x0B	; 11
    23c8:	8f 9f       	mul	r24, r31
    23ca:	c0 01       	movw	r24, r0
    23cc:	11 24       	eor	r1, r1
    23ce:	be 01       	movw	r22, r28
    23d0:	8c 5d       	subi	r24, 0xDC	; 220
    23d2:	9e 4c       	sbci	r25, 0xCE	; 206
    23d4:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>
    23d8:	07 c0       	rjmp	.+14     	; 0x23e8 <vTaskPriorityInherit+0xa0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    23da:	a0 91 50 31 	lds	r26, 0x3150	; 0x803150 <pxCurrentTCB>
    23de:	b0 91 51 31 	lds	r27, 0x3151	; 0x803151 <pxCurrentTCB+0x1>
    23e2:	5a 96       	adiw	r26, 0x1a	; 26
    23e4:	8c 91       	ld	r24, X
    23e6:	82 8f       	std	Z+26, r24	; 0x1a
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	08 95       	ret

000023f2 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    23f2:	0f 93       	push	r16
    23f4:	1f 93       	push	r17
    23f6:	cf 93       	push	r28
    23f8:	df 93       	push	r29
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    23fa:	00 97       	sbiw	r24, 0x00	; 0
    23fc:	49 f1       	breq	.+82     	; 0x2450 <vTaskPriorityDisinherit+0x5e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    23fe:	fc 01       	movw	r30, r24
    2400:	32 8d       	ldd	r19, Z+26	; 0x1a
    2402:	27 a1       	ldd	r18, Z+39	; 0x27
    2404:	32 17       	cp	r19, r18
    2406:	21 f1       	breq	.+72     	; 0x2450 <vTaskPriorityDisinherit+0x5e>
    2408:	ec 01       	movw	r28, r24
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
    240a:	8c 01       	movw	r16, r24
    240c:	0e 5f       	subi	r16, 0xFE	; 254
    240e:	1f 4f       	sbci	r17, 0xFF	; 255
    2410:	c8 01       	movw	r24, r16
    2412:	0e 94 44 08 	call	0x1088	; 0x1088 <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    2416:	8f a1       	ldd	r24, Y+39	; 0x27
    2418:	8a 8f       	std	Y+26, r24	; 0x1a
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    241a:	44 e0       	ldi	r20, 0x04	; 4
    241c:	50 e0       	ldi	r21, 0x00	; 0
    241e:	60 e0       	ldi	r22, 0x00	; 0
    2420:	70 e0       	ldi	r23, 0x00	; 0
    2422:	48 1b       	sub	r20, r24
    2424:	51 09       	sbc	r21, r1
    2426:	61 09       	sbc	r22, r1
    2428:	71 09       	sbc	r23, r1
    242a:	4e 87       	std	Y+14, r20	; 0x0e
    242c:	5f 87       	std	Y+15, r21	; 0x0f
    242e:	68 8b       	std	Y+16, r22	; 0x10
    2430:	79 8b       	std	Y+17, r23	; 0x11
				prvAddTaskToReadyQueue( pxTCB );
    2432:	90 91 f6 30 	lds	r25, 0x30F6	; 0x8030f6 <uxTopReadyPriority>
    2436:	98 17       	cp	r25, r24
    2438:	10 f4       	brcc	.+4      	; 0x243e <vTaskPriorityDisinherit+0x4c>
    243a:	80 93 f6 30 	sts	0x30F6, r24	; 0x8030f6 <uxTopReadyPriority>
    243e:	fb e0       	ldi	r31, 0x0B	; 11
    2440:	8f 9f       	mul	r24, r31
    2442:	c0 01       	movw	r24, r0
    2444:	11 24       	eor	r1, r1
    2446:	b8 01       	movw	r22, r16
    2448:	8c 5d       	subi	r24, 0xDC	; 220
    244a:	9e 4c       	sbci	r25, 0xCE	; 206
    244c:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <vListInsertEnd>
			}
		}
	}
    2450:	df 91       	pop	r29
    2452:	cf 91       	pop	r28
    2454:	1f 91       	pop	r17
    2456:	0f 91       	pop	r16
    2458:	08 95       	ret

0000245a <_ZN8frt_task22_call_users_run_methodEPS_>:
 *  the scheduler.
 *  @param p_task A pointer to the task (this task) whose run method is to be called
 */

void frt_task::_call_users_run_method (frt_task* p_task)
{
    245a:	ec 01       	movw	r28, r24
	// If we're not using setup() and loop(), call the user's run() function instead.
	// This version is more similar to the typical RTOS implementation but not quite
	// as easy to use for execution time profiling
	#else
		// This is where the user's run() method is actually called
		p_task->run ();
    245c:	e8 81       	ld	r30, Y
    245e:	f9 81       	ldd	r31, Y+1	; 0x01
    2460:	01 90       	ld	r0, Z+
    2462:	f0 81       	ld	r31, Z
    2464:	e0 2d       	mov	r30, r0
    2466:	19 95       	eicall
		void* temp_handle = p_task->handle;
		p_task->handle = 0;
		vTaskDelete (temp_handle);
	// If task deletion is disabled, set this task's handle to 0 but don't delete task
	#else
		p_task->handle = 0;
    2468:	1a 82       	std	Y+2, r1	; 0x02
    246a:	1b 82       	std	Y+3, r1	; 0x03

	// If task deletion is not enabled, we get here if the task run method has exited 
	// (which it shouldn't have, though). 
	for (;;)
	{
		vTaskDelay (portMAX_DELAY);
    246c:	6f ef       	ldi	r22, 0xFF	; 255
    246e:	7f ef       	ldi	r23, 0xFF	; 255
    2470:	cb 01       	movw	r24, r22
    2472:	0e 94 10 10 	call	0x2020	; 0x2020 <vTaskDelay>
    2476:	fa cf       	rjmp	.-12     	; 0x246c <_ZN8frt_task22_call_users_run_methodEPS_+0x12>

00002478 <_ZN8frt_task13transition_toEh>:
 *  help with debugging.
 *  @param new_state The state to which we will transition
 */
void frt_task::transition_to (uint8_t new_state)
{
	state = new_state;
    2478:	fc 01       	movw	r30, r24
    247a:	64 87       	std	Z+12, r22	; 0x0c
			*p_serial << tick_res_time () << ":" << (char*)(pcTaskGetTaskName (handle))
					<< ":" << previous_state << PMS ("->") << state << endl;
		}
	#endif // TRANSITION_TRACE

	previous_state = state;
    247c:	65 87       	std	Z+13, r22	; 0x0d
    247e:	08 95       	ret

00002480 <_ZN8frt_taskC1EPKchjP8emstream>:
 *                      (default: configMINIMAL_STACK_SIZE)
 *  @param p_ser_dev Pointer to a serial device (port, radio, SD card, etc.) which can
 *                   be used by this task to communicate (default: NULL)
 */

frt_task::frt_task (const char* a_name, 
    2480:	4f 92       	push	r4
    2482:	5f 92       	push	r5
    2484:	6f 92       	push	r6
    2486:	7f 92       	push	r7
    2488:	8f 92       	push	r8
    248a:	9f 92       	push	r9
    248c:	af 92       	push	r10
    248e:	bf 92       	push	r11
    2490:	cf 92       	push	r12
    2492:	df 92       	push	r13
    2494:	ef 92       	push	r14
    2496:	ff 92       	push	r15
    2498:	0f 93       	push	r16
    249a:	1f 93       	push	r17
    249c:	cf 93       	push	r28
    249e:	df 93       	push	r29
    24a0:	cd b7       	in	r28, 0x3d	; 61
    24a2:	de b7       	in	r29, 0x3e	; 62
    24a4:	2a 97       	sbiw	r28, 0x0a	; 10
    24a6:	cd bf       	out	0x3d, r28	; 61
    24a8:	de bf       	out	0x3e, r29	; 62
    24aa:	4c 01       	movw	r8, r24
    24ac:	29 01       	movw	r4, r18
    24ae:	38 01       	movw	r6, r16
					unsigned portBASE_TYPE a_priority, 
					size_t a_stack_size,
					emstream* p_ser_dev
					)
    24b0:	87 e5       	ldi	r24, 0x57	; 87
    24b2:	90 e2       	ldi	r25, 0x20	; 32
    24b4:	f4 01       	movw	r30, r8
    24b6:	80 83       	st	Z, r24
    24b8:	91 83       	std	Z+1, r25	; 0x01
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    24ba:	fb 01       	movw	r30, r22
    24bc:	80 81       	ld	r24, Z
    24be:	88 23       	and	r24, r24
    24c0:	69 f0       	breq	.+26     	; 0x24dc <_ZN8frt_taskC1EPKchjP8emstream+0x5c>
    24c2:	de 01       	movw	r26, r28
    24c4:	11 96       	adiw	r26, 0x01	; 1
    24c6:	31 96       	adiw	r30, 0x01	; 1
    24c8:	90 e0       	ldi	r25, 0x00	; 0
    24ca:	02 c0       	rjmp	.+4      	; 0x24d0 <_ZN8frt_taskC1EPKchjP8emstream+0x50>
    24cc:	99 30       	cpi	r25, 0x09	; 9
    24ce:	39 f0       	breq	.+14     	; 0x24de <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
	{
		temp_name[index++] = *a_name++;
    24d0:	9f 5f       	subi	r25, 0xFF	; 255
    24d2:	8d 93       	st	X+, r24
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
    24d4:	81 91       	ld	r24, Z+
    24d6:	81 11       	cpse	r24, r1
    24d8:	f9 cf       	rjmp	.-14     	; 0x24cc <_ZN8frt_taskC1EPKchjP8emstream+0x4c>
    24da:	01 c0       	rjmp	.+2      	; 0x24de <_ZN8frt_taskC1EPKchjP8emstream+0x5e>
{
	// Make sure the user doesn't send an excessively long task name to xTaskCreate()
	// by copying at most (configMAX_TASK_NAME_LEN - 1) characters and putting the
	// terminating null character at the end of the string
	char temp_name[configMAX_TASK_NAME_LEN];
	uint8_t index = 0;
    24dc:	90 e0       	ldi	r25, 0x00	; 0
	while (*a_name && index < (configMAX_TASK_NAME_LEN - 1))
	{
		temp_name[index++] = *a_name++;
	}
	temp_name[index] = '\0';
    24de:	e1 e0       	ldi	r30, 0x01	; 1
    24e0:	f0 e0       	ldi	r31, 0x00	; 0
    24e2:	ec 0f       	add	r30, r28
    24e4:	fd 1f       	adc	r31, r29
    24e6:	e9 0f       	add	r30, r25
    24e8:	f1 1d       	adc	r31, r1
    24ea:	10 82       	st	Z, r1

	// Create the task with a call to the RTOS task creation function
	portBASE_TYPE task_status = xTaskCreate
    24ec:	74 01       	movw	r14, r8
    24ee:	f2 e0       	ldi	r31, 0x02	; 2
    24f0:	ef 0e       	add	r14, r31
    24f2:	f1 1c       	adc	r15, r1
    24f4:	a1 2c       	mov	r10, r1
    24f6:	b1 2c       	mov	r11, r1
    24f8:	c1 2c       	mov	r12, r1
    24fa:	d1 2c       	mov	r13, r1
    24fc:	04 2f       	mov	r16, r20
    24fe:	94 01       	movw	r18, r8
    2500:	a2 01       	movw	r20, r4
    2502:	be 01       	movw	r22, r28
    2504:	6f 5f       	subi	r22, 0xFF	; 255
    2506:	7f 4f       	sbci	r23, 0xFF	; 255
    2508:	86 ea       	ldi	r24, 0xA6	; 166
    250a:	92 e0       	ldi	r25, 0x02	; 2
    250c:	0e 94 bc 0c 	call	0x1978	; 0x1978 <xTaskGenericCreate>
		 a_priority,                                 // Priority for the new task
		 &handle                                     // The new task's handle
		);

	// Save the serial port pointer and the total stack size
	p_serial = p_ser_dev;
    2510:	f4 01       	movw	r30, r8
    2512:	66 82       	std	Z+6, r6	; 0x06
    2514:	77 82       	std	Z+7, r7	; 0x07
	total_stack = a_stack_size;
    2516:	40 86       	std	Z+8, r4	; 0x08
    2518:	51 86       	std	Z+9, r5	; 0x09

	// Set the handles to the previously and last created tasks
	prev_task_pointer = last_created_task_pointer;
    251a:	20 91 52 31 	lds	r18, 0x3152	; 0x803152 <last_created_task_pointer>
    251e:	30 91 53 31 	lds	r19, 0x3153	; 0x803153 <last_created_task_pointer+0x1>
    2522:	24 83       	std	Z+4, r18	; 0x04
    2524:	35 83       	std	Z+5, r19	; 0x05
	last_created_task_pointer = this;
    2526:	80 92 52 31 	sts	0x3152, r8	; 0x803152 <last_created_task_pointer>
    252a:	90 92 53 31 	sts	0x3153, r9	; 0x803153 <last_created_task_pointer+0x1>

	// Initialize the finite state machine and its transition logger
	state = 0;
    252e:	14 86       	std	Z+12, r1	; 0x0c
	previous_state = 0;
    2530:	15 86       	std	Z+13, r1	; 0x0d

	// If stack tracing is being used, save the address of the top of the stack
	top_of_stack = ++portStackTopForTask;
    2532:	40 90 82 31 	lds	r4, 0x3182	; 0x803182 <portStackTopForTask>
    2536:	50 90 83 31 	lds	r5, 0x3183	; 0x803183 <portStackTopForTask+0x1>
    253a:	ff ef       	ldi	r31, 0xFF	; 255
    253c:	4f 1a       	sub	r4, r31
    253e:	5f 0a       	sbc	r5, r31
    2540:	40 92 82 31 	sts	0x3182, r4	; 0x803182 <portStackTopForTask>
    2544:	50 92 83 31 	sts	0x3183, r5	; 0x803183 <portStackTopForTask+0x1>
    2548:	f4 01       	movw	r30, r8
    254a:	42 86       	std	Z+10, r4	; 0x0a
    254c:	53 86       	std	Z+11, r5	; 0x0b

	// Initialize the run counter
	runs = 0;
    254e:	16 86       	std	Z+14, r1	; 0x0e
    2550:	17 86       	std	Z+15, r1	; 0x0f
    2552:	10 8a       	std	Z+16, r1	; 0x10
    2554:	11 8a       	std	Z+17, r1	; 0x11

	// If the serial port is being used, let the user know if the task was created
	// successfully
	if (p_serial != NULL)
    2556:	61 14       	cp	r6, r1
    2558:	71 04       	cpc	r7, r1
    255a:	09 f4       	brne	.+2      	; 0x255e <_ZN8frt_taskC1EPKchjP8emstream+0xde>
    255c:	44 c0       	rjmp	.+136    	; 0x25e6 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
	{
		if (task_status == pdPASS)
    255e:	81 30       	cpi	r24, 0x01	; 1
    2560:	79 f5       	brne	.+94     	; 0x25c0 <_ZN8frt_taskC1EPKchjP8emstream+0x140>
		{
			*p_serial << PMS ("Task ") << temp_name << PMS (" created")
    2562:	6a e0       	ldi	r22, 0x0A	; 10
    2564:	c3 01       	movw	r24, r6
    2566:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    256a:	7c 01       	movw	r14, r24
    256c:	69 e9       	ldi	r22, 0x99	; 153
    256e:	74 e0       	ldi	r23, 0x04	; 4
    2570:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2574:	be 01       	movw	r22, r28
    2576:	6f 5f       	subi	r22, 0xFF	; 255
    2578:	7f 4f       	sbci	r23, 0xFF	; 255
    257a:	c7 01       	movw	r24, r14
    257c:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2580:	6a e0       	ldi	r22, 0x0A	; 10
    2582:	c7 01       	movw	r24, r14
    2584:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2588:	7c 01       	movw	r14, r24
    258a:	60 e9       	ldi	r22, 0x90	; 144
    258c:	74 e0       	ldi	r23, 0x04	; 4
    258e:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
				<< PMS (", stack at 0x") << hex << top_of_stack << dec << endl;
    2592:	6a e0       	ldi	r22, 0x0A	; 10
    2594:	c7 01       	movw	r24, r14
    2596:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    259a:	7c 01       	movw	r14, r24
    259c:	62 e8       	ldi	r22, 0x82	; 130
    259e:	74 e0       	ldi	r23, 0x04	; 4
    25a0:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    25a4:	63 e0       	ldi	r22, 0x03	; 3
    25a6:	c7 01       	movw	r24, r14
    25a8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    25ac:	b2 01       	movw	r22, r4
    25ae:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <_ZN8emstreamlsEj>
    25b2:	62 e0       	ldi	r22, 0x02	; 2
    25b4:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    25b8:	66 e0       	ldi	r22, 0x06	; 6
    25ba:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    25be:	13 c0       	rjmp	.+38     	; 0x25e6 <_ZN8frt_taskC1EPKchjP8emstream+0x166>
		}
		else
		{
			*p_serial << PMS ("ERROR creating task ") << temp_name << endl;
    25c0:	6a e0       	ldi	r22, 0x0A	; 10
    25c2:	c3 01       	movw	r24, r6
    25c4:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    25c8:	4c 01       	movw	r8, r24
    25ca:	6d e6       	ldi	r22, 0x6D	; 109
    25cc:	74 e0       	ldi	r23, 0x04	; 4
    25ce:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    25d2:	be 01       	movw	r22, r28
    25d4:	6f 5f       	subi	r22, 0xFF	; 255
    25d6:	7f 4f       	sbci	r23, 0xFF	; 255
    25d8:	c4 01       	movw	r24, r8
    25da:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    25de:	66 e0       	ldi	r22, 0x06	; 6
    25e0:	c4 01       	movw	r24, r8
    25e2:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		}
	}
}
    25e6:	2a 96       	adiw	r28, 0x0a	; 10
    25e8:	cd bf       	out	0x3d, r28	; 61
    25ea:	de bf       	out	0x3e, r29	; 62
    25ec:	df 91       	pop	r29
    25ee:	cf 91       	pop	r28
    25f0:	1f 91       	pop	r17
    25f2:	0f 91       	pop	r16
    25f4:	ff 90       	pop	r15
    25f6:	ef 90       	pop	r14
    25f8:	df 90       	pop	r13
    25fa:	cf 90       	pop	r12
    25fc:	bf 90       	pop	r11
    25fe:	af 90       	pop	r10
    2600:	9f 90       	pop	r9
    2602:	8f 90       	pop	r8
    2604:	7f 90       	pop	r7
    2606:	6f 90       	pop	r6
    2608:	5f 90       	pop	r5
    260a:	4f 90       	pop	r4
    260c:	08 95       	ret

0000260e <_ZN8frt_task19print_stack_in_listEP8emstream>:
 *  stacks. The idle task's stack is printed separately afterwards. 
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
    260e:	cf 92       	push	r12
    2610:	df 92       	push	r13
    2612:	ef 92       	push	r14
    2614:	ff 92       	push	r15
    2616:	0f 93       	push	r16
    2618:	1f 93       	push	r17
    261a:	cf 93       	push	r28
    261c:	df 93       	push	r29
    261e:	ec 01       	movw	r28, r24
    2620:	7b 01       	movw	r14, r22
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
				<< (const char*)(pcTaskGetTaskName (handle)) 
    2622:	8a 81       	ldd	r24, Y+2	; 0x02
    2624:	9b 81       	ldd	r25, Y+3	; 0x03
    2626:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <pcTaskGetTaskName>
    262a:	6c 01       	movw	r12, r24
 *  @param ser_device The serial device to which each task prints its stack
 */

void frt_task::print_stack_in_list (emstream* ser_device)
{
	*ser_device << ATERM_BOLD << PMS ("Task: ") 
    262c:	6a e0       	ldi	r22, 0x0A	; 10
    262e:	c7 01       	movw	r24, r14
    2630:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2634:	8c 01       	movw	r16, r24
    2636:	6c ea       	ldi	r22, 0xAC	; 172
    2638:	74 e0       	ldi	r23, 0x04	; 4
    263a:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    263e:	6a e0       	ldi	r22, 0x0A	; 10
    2640:	c8 01       	movw	r24, r16
    2642:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2646:	8c 01       	movw	r16, r24
    2648:	65 ea       	ldi	r22, 0xA5	; 165
    264a:	74 e0       	ldi	r23, 0x04	; 4
    264c:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2650:	b6 01       	movw	r22, r12
    2652:	c8 01       	movw	r24, r16
    2654:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
				<< (const char*)(pcTaskGetTaskName (handle)) 
				<< ATERM_NORM_INT << endl;
    2658:	6a e0       	ldi	r22, 0x0A	; 10
    265a:	c8 01       	movw	r24, r16
    265c:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2660:	8c 01       	movw	r16, r24
    2662:	6f e9       	ldi	r22, 0x9F	; 159
    2664:	74 e0       	ldi	r23, 0x04	; 4
    2666:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    266a:	66 e0       	ldi	r22, 0x06	; 6
    266c:	c8 01       	movw	r24, r16
    266e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
		 *  @param p_ser_d The serial device to which the stack will be printed
		 */
		void dump_stack (emstream* p_ser_d)
		{
			hex_dump_memory ((uint8_t*)(top_of_stack - total_stack), 
								(uint8_t*)(top_of_stack), p_ser_d, true, 0x11);
    2672:	8a 85       	ldd	r24, Y+10	; 0x0a
    2674:	9b 85       	ldd	r25, Y+11	; 0x0b
    2676:	e8 85       	ldd	r30, Y+8	; 0x08
    2678:	f9 85       	ldd	r31, Y+9	; 0x09
    267a:	01 e1       	ldi	r16, 0x11	; 17
    267c:	21 e0       	ldi	r18, 0x01	; 1
    267e:	a7 01       	movw	r20, r14
    2680:	bc 01       	movw	r22, r24
    2682:	8e 1b       	sub	r24, r30
    2684:	9f 0b       	sbc	r25, r31
    2686:	0e 94 09 16 	call	0x2c12	; 0x2c12 <_Z15hex_dump_memoryPhS_P8emstreambh>

	dump_stack (ser_device);

	if (prev_task_pointer != NULL)
    268a:	8c 81       	ldd	r24, Y+4	; 0x04
    268c:	9d 81       	ldd	r25, Y+5	; 0x05
    268e:	00 97       	sbiw	r24, 0x00	; 0
    2690:	19 f0       	breq	.+6      	; 0x2698 <_ZN8frt_task19print_stack_in_listEP8emstream+0x8a>
	{
		prev_task_pointer->print_stack_in_list (ser_device);
    2692:	b7 01       	movw	r22, r14
    2694:	0e 94 07 13 	call	0x260e	; 0x260e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}
}
    2698:	df 91       	pop	r29
    269a:	cf 91       	pop	r28
    269c:	1f 91       	pop	r17
    269e:	0f 91       	pop	r16
    26a0:	ff 90       	pop	r15
    26a2:	ef 90       	pop	r14
    26a4:	df 90       	pop	r13
    26a6:	cf 90       	pop	r12
    26a8:	08 95       	ret

000026aa <_Z17print_task_stacksP8emstream>:
/** This function has all the tasks in the task list do a "stack dump", printing their
 *  stacks in hex dump format. The idle task's stack is printed afterwards. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */
void print_task_stacks (emstream* ser_dev)
{
    26aa:	0f 93       	push	r16
    26ac:	1f 93       	push	r17
    26ae:	cf 93       	push	r28
    26b0:	df 93       	push	r29
    26b2:	ec 01       	movw	r28, r24
	// Tell the most recently created task to print its stack and keep the process
	// going by telling the next most recently created task to print its stack, etc.
	if (last_created_task_pointer != NULL)
    26b4:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <last_created_task_pointer>
    26b8:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <last_created_task_pointer+0x1>
    26bc:	00 97       	sbiw	r24, 0x00	; 0
    26be:	19 f0       	breq	.+6      	; 0x26c6 <_Z17print_task_stacksP8emstream+0x1c>
	{
		last_created_task_pointer->print_stack_in_list (ser_dev);
    26c0:	be 01       	movw	r22, r28
    26c2:	0e 94 07 13 	call	0x260e	; 0x260e <_ZN8frt_task19print_stack_in_listEP8emstream>
	}

	// Now print the stack for the idle task, which isn't user created and so isn't
	// in the regular task list
	*ser_dev << ATERM_BOLD << PMS ("Task: IDLE") << ATERM_NORM_INT << endl;
    26c6:	6a e0       	ldi	r22, 0x0A	; 10
    26c8:	ce 01       	movw	r24, r28
    26ca:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    26ce:	8c 01       	movw	r16, r24
    26d0:	62 ec       	ldi	r22, 0xC2	; 194
    26d2:	74 e0       	ldi	r23, 0x04	; 4
    26d4:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    26d8:	6a e0       	ldi	r22, 0x0A	; 10
    26da:	c8 01       	movw	r24, r16
    26dc:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    26e0:	8c 01       	movw	r16, r24
    26e2:	67 eb       	ldi	r22, 0xB7	; 183
    26e4:	74 e0       	ldi	r23, 0x04	; 4
    26e6:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    26ea:	6a e0       	ldi	r22, 0x0A	; 10
    26ec:	c8 01       	movw	r24, r16
    26ee:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    26f2:	8c 01       	movw	r16, r24
    26f4:	61 eb       	ldi	r22, 0xB1	; 177
    26f6:	74 e0       	ldi	r23, 0x04	; 4
    26f8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    26fc:	66 e0       	ldi	r22, 0x06	; 6
    26fe:	c8 01       	movw	r24, r16
    2700:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	hex_dump_memory ((uint8_t*)(portStackTopForTask - configMINIMAL_STACK_SIZE + 1), 
							(uint8_t*)(portStackTopForTask + 1), ser_dev, true, 0x11);
    2704:	80 91 82 31 	lds	r24, 0x3182	; 0x803182 <portStackTopForTask>
    2708:	90 91 83 31 	lds	r25, 0x3183	; 0x803183 <portStackTopForTask+0x1>
    270c:	bc 01       	movw	r22, r24
    270e:	6f 5f       	subi	r22, 0xFF	; 255
    2710:	7f 4f       	sbci	r23, 0xFF	; 255
    2712:	01 e1       	ldi	r16, 0x11	; 17
    2714:	21 e0       	ldi	r18, 0x01	; 1
    2716:	ae 01       	movw	r20, r28
    2718:	83 56       	subi	r24, 0x63	; 99
    271a:	91 09       	sbc	r25, r1
    271c:	0e 94 09 16 	call	0x2c12	; 0x2c12 <_Z15hex_dump_memoryPhS_P8emstreambh>
}
    2720:	df 91       	pop	r29
    2722:	cf 91       	pop	r28
    2724:	1f 91       	pop	r17
    2726:	0f 91       	pop	r16
    2728:	08 95       	ret

0000272a <_ZN8frt_task12print_statusER8emstream>:
 *  information. 
 *  @param ser_dev A reference to the serial device to which to print the task status
 */

void frt_task::print_status (emstream& ser_dev)
{
    272a:	8f 92       	push	r8
    272c:	9f 92       	push	r9
    272e:	af 92       	push	r10
    2730:	bf 92       	push	r11
    2732:	cf 92       	push	r12
    2734:	df 92       	push	r13
    2736:	ef 92       	push	r14
    2738:	ff 92       	push	r15
    273a:	0f 93       	push	r16
    273c:	1f 93       	push	r17
    273e:	cf 93       	push	r28
    2740:	df 93       	push	r29
    2742:	ec 01       	movw	r28, r24
    2744:	8b 01       	movw	r16, r22
	ser_dev << (const char*)(pcTaskGetTaskName (handle));
    2746:	8a 81       	ldd	r24, Y+2	; 0x02
    2748:	9b 81       	ldd	r25, Y+3	; 0x03
    274a:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <pcTaskGetTaskName>
    274e:	bc 01       	movw	r22, r24
    2750:	c8 01       	movw	r24, r16
    2752:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
	ser_dev.putchar ('\t');
    2756:	d8 01       	movw	r26, r16
    2758:	ed 91       	ld	r30, X+
    275a:	fc 91       	ld	r31, X
    275c:	02 80       	ldd	r0, Z+2	; 0x02
    275e:	f3 81       	ldd	r31, Z+3	; 0x03
    2760:	e0 2d       	mov	r30, r0
    2762:	69 e0       	ldi	r22, 0x09	; 9
    2764:	c8 01       	movw	r24, r16
    2766:	19 95       	eicall
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
    2768:	8a 81       	ldd	r24, Y+2	; 0x02
    276a:	9b 81       	ldd	r25, Y+3	; 0x03
    276c:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <pcTaskGetTaskName>
    2770:	fc 01       	movw	r30, r24
    2772:	01 90       	ld	r0, Z+
    2774:	00 20       	and	r0, r0
    2776:	e9 f7       	brne	.-6      	; 0x2772 <_ZN8frt_task12print_statusER8emstream+0x48>
    2778:	31 97       	sbiw	r30, 0x01	; 1
    277a:	e8 1b       	sub	r30, r24
    277c:	f9 0b       	sbc	r31, r25
    277e:	38 97       	sbiw	r30, 0x08	; 8
    2780:	48 f4       	brcc	.+18     	; 0x2794 <_ZN8frt_task12print_statusER8emstream+0x6a>
	{
		ser_dev.putchar ('\t');
    2782:	d8 01       	movw	r26, r16
    2784:	ed 91       	ld	r30, X+
    2786:	fc 91       	ld	r31, X
    2788:	02 80       	ldd	r0, Z+2	; 0x02
    278a:	f3 81       	ldd	r31, Z+3	; 0x03
    278c:	e0 2d       	mov	r30, r0
    278e:	69 e0       	ldi	r22, 0x09	; 9
    2790:	c8 01       	movw	r24, r16
    2792:	19 95       	eicall
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
			<< get_total_stack () << PMS ("\t")
		#endif
			<< PMS ("\t") << runs;
    2794:	ce 84       	ldd	r12, Y+14	; 0x0e
    2796:	df 84       	ldd	r13, Y+15	; 0x0f
    2798:	e8 88       	ldd	r14, Y+16	; 0x10
    279a:	f9 88       	ldd	r15, Y+17	; 0x11
		 *  constructor call.
		 *  @return The task's total stack size in bytes
		 */
		size_t get_total_stack (void)
		{
			return (total_stack);
    279c:	a8 84       	ldd	r10, Y+8	; 0x08
    279e:	b9 84       	ldd	r11, Y+9	; 0x09
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
			<< get_state ()
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    27a0:	8a 81       	ldd	r24, Y+2	; 0x02
    27a2:	9b 81       	ldd	r25, Y+3	; 0x03
    27a4:	0e 94 86 11 	call	0x230c	; 0x230c <uxTaskGetStackHighWaterMark>
    27a8:	98 2e       	mov	r9, r24
		 *  manipulated by the user within the run() method to cause state transitions.
		 *  @return The current state
		 */
		uint8_t get_state (void)
		{
			return (state);
    27aa:	8c 84       	ldd	r8, Y+12	; 0x0c
	ser_dev.putchar ('\t');
	if (strlen ((const char*)(pcTaskGetTaskName (handle))) < 8)
	{
		ser_dev.putchar ('\t');
	}
	ser_dev << uxTaskPriorityGet (handle) << PMS ("\t")
    27ac:	8a 81       	ldd	r24, Y+2	; 0x02
    27ae:	9b 81       	ldd	r25, Y+3	; 0x03
    27b0:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <uxTaskPriorityGet>
    27b4:	68 2f       	mov	r22, r24
    27b6:	c8 01       	movw	r24, r16
    27b8:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    27bc:	6a e0       	ldi	r22, 0x0A	; 10
    27be:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    27c2:	ec 01       	movw	r28, r24
    27c4:	67 e3       	ldi	r22, 0x37	; 55
    27c6:	75 e0       	ldi	r23, 0x05	; 5
    27c8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
			<< get_state ()
    27cc:	68 2d       	mov	r22, r8
    27ce:	ce 01       	movw	r24, r28
    27d0:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t") << uxTaskGetStackHighWaterMark(handle) << PMS ("/") 
    27d4:	6a e0       	ldi	r22, 0x0A	; 10
    27d6:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    27da:	ec 01       	movw	r28, r24
    27dc:	65 e3       	ldi	r22, 0x35	; 53
    27de:	75 e0       	ldi	r23, 0x05	; 5
    27e0:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    27e4:	69 2d       	mov	r22, r9
    27e6:	ce 01       	movw	r24, r28
    27e8:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    27ec:	6a e0       	ldi	r22, 0x0A	; 10
    27ee:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    27f2:	ec 01       	movw	r28, r24
    27f4:	63 e3       	ldi	r22, 0x33	; 51
    27f6:	75 e0       	ldi	r23, 0x05	; 5
    27f8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
			<< get_total_stack () << PMS ("\t")
    27fc:	b5 01       	movw	r22, r10
    27fe:	ce 01       	movw	r24, r28
    2800:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <_ZN8emstreamlsEj>
    2804:	6a e0       	ldi	r22, 0x0A	; 10
    2806:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    280a:	ec 01       	movw	r28, r24
    280c:	61 e3       	ldi	r22, 0x31	; 49
    280e:	75 e0       	ldi	r23, 0x05	; 5
    2810:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t") << runs;
    2814:	6a e0       	ldi	r22, 0x0A	; 10
    2816:	ce 01       	movw	r24, r28
    2818:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    281c:	ec 01       	movw	r28, r24
    281e:	6f e2       	ldi	r22, 0x2F	; 47
    2820:	75 e0       	ldi	r23, 0x05	; 5
    2822:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2826:	b7 01       	movw	r22, r14
    2828:	a6 01       	movw	r20, r12
    282a:	ce 01       	movw	r24, r28
    282c:	0e 94 20 18 	call	0x3040	; 0x3040 <_ZN8emstreamlsEm>
}
    2830:	df 91       	pop	r29
    2832:	cf 91       	pop	r28
    2834:	1f 91       	pop	r17
    2836:	0f 91       	pop	r16
    2838:	ff 90       	pop	r15
    283a:	ef 90       	pop	r14
    283c:	df 90       	pop	r13
    283e:	cf 90       	pop	r12
    2840:	bf 90       	pop	r11
    2842:	af 90       	pop	r10
    2844:	9f 90       	pop	r9
    2846:	8f 90       	pop	r8
    2848:	08 95       	ret

0000284a <_ZlsR8emstreamR8frt_task>:
 *  @return A reference to the same serial device on which we write information.
 *          This is used to string together things to write with "<<" operators
 */

emstream& operator << (emstream& ser_dev, frt_task& a_task)
{
    284a:	cf 93       	push	r28
    284c:	df 93       	push	r29
    284e:	ec 01       	movw	r28, r24
    2850:	cb 01       	movw	r24, r22
	a_task.print_status (ser_dev);
    2852:	db 01       	movw	r26, r22
    2854:	ed 91       	ld	r30, X+
    2856:	fc 91       	ld	r31, X
    2858:	02 80       	ldd	r0, Z+2	; 0x02
    285a:	f3 81       	ldd	r31, Z+3	; 0x03
    285c:	e0 2d       	mov	r30, r0
    285e:	be 01       	movw	r22, r28
    2860:	19 95       	eicall
	return (ser_dev);
}
    2862:	ce 01       	movw	r24, r28
    2864:	df 91       	pop	r29
    2866:	cf 91       	pop	r28
    2868:	08 95       	ret

0000286a <_ZN8frt_task20print_status_in_listEP8emstream>:
 *  tasks to do so. The list is kept by the tasks, each having a pointer to another.
 *  @param ser_device The serial device to which each task prints its status
 */

void frt_task::print_status_in_list (emstream* ser_device)
{
    286a:	0f 93       	push	r16
    286c:	1f 93       	push	r17
    286e:	cf 93       	push	r28
    2870:	df 93       	push	r29
    2872:	ec 01       	movw	r28, r24
    2874:	8b 01       	movw	r16, r22
	*ser_device << *this << endl;
    2876:	bc 01       	movw	r22, r24
    2878:	c8 01       	movw	r24, r16
    287a:	0e 94 25 14 	call	0x284a	; 0x284a <_ZlsR8emstreamR8frt_task>
    287e:	66 e0       	ldi	r22, 0x06	; 6
    2880:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>

	if (prev_task_pointer != NULL)
    2884:	8c 81       	ldd	r24, Y+4	; 0x04
    2886:	9d 81       	ldd	r25, Y+5	; 0x05
    2888:	00 97       	sbiw	r24, 0x00	; 0
    288a:	19 f0       	breq	.+6      	; 0x2892 <_ZN8frt_task20print_status_in_listEP8emstream+0x28>
	{
		prev_task_pointer->print_status_in_list (ser_device);
    288c:	b8 01       	movw	r22, r16
    288e:	0e 94 35 14 	call	0x286a	; 0x286a <_ZN8frt_task20print_status_in_listEP8emstream>
	}
}
    2892:	df 91       	pop	r29
    2894:	cf 91       	pop	r28
    2896:	1f 91       	pop	r17
    2898:	0f 91       	pop	r16
    289a:	08 95       	ret

0000289c <_Z15print_task_listP8emstream>:
 *  The author isn't sure if it can always be trusted. 
 *  @param ser_dev Pointer to a serial device on which the information will be printed
 */

void print_task_list (emstream* ser_dev)
{
    289c:	0f 93       	push	r16
    289e:	1f 93       	push	r17
    28a0:	cf 93       	push	r28
    28a2:	df 93       	push	r29
    28a4:	ec 01       	movw	r28, r24
	// Print the first line with the top of the headings
	*ser_dev << PMS ("Task\t\t  \t ")
    28a6:	6a e0       	ldi	r22, 0x0A	; 10
    28a8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    28ac:	8c 01       	movw	r16, r24
    28ae:	64 e2       	ldi	r22, 0x24	; 36
    28b0:	75 e0       	ldi	r23, 0x05	; 5
    28b2:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tStack")
    28b6:	6a e0       	ldi	r22, 0x0A	; 10
    28b8:	c8 01       	movw	r24, r16
    28ba:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    28be:	8c 01       	movw	r16, r24
    28c0:	6d e1       	ldi	r22, 0x1D	; 29
    28c2:	75 e0       	ldi	r23, 0x05	; 5
    28c4:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#endif
			<< endl;
    28c8:	66 e0       	ldi	r22, 0x06	; 6
    28ca:	c8 01       	movw	r24, r16
    28cc:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>

	// Print the second line with the rest of the headings
	*ser_dev << PMS ("Name\t\tPri.\tState")
    28d0:	6a e0       	ldi	r22, 0x0A	; 10
    28d2:	ce 01       	movw	r24, r28
    28d4:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    28d8:	8c 01       	movw	r16, r24
    28da:	6c e0       	ldi	r22, 0x0C	; 12
    28dc:	75 e0       	ldi	r23, 0x05	; 5
    28de:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\tFree/Total")
    28e2:	6a e0       	ldi	r22, 0x0A	; 10
    28e4:	c8 01       	movw	r24, r16
    28e6:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    28ea:	8c 01       	movw	r16, r24
    28ec:	60 e0       	ldi	r22, 0x00	; 0
    28ee:	75 e0       	ldi	r23, 0x05	; 5
    28f0:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\tRuns") << endl;
    28f4:	6a e0       	ldi	r22, 0x0A	; 10
    28f6:	c8 01       	movw	r24, r16
    28f8:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    28fc:	8c 01       	movw	r16, r24
    28fe:	6a ef       	ldi	r22, 0xFA	; 250
    2900:	74 e0       	ldi	r23, 0x04	; 4
    2902:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2906:	66 e0       	ldi	r22, 0x06	; 6
    2908:	c8 01       	movw	r24, r16
    290a:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>

	// Print the third line which shows separators between headers and data
	*ser_dev << PMS ("----\t\t----\t-----")
    290e:	6a e0       	ldi	r22, 0x0A	; 10
    2910:	ce 01       	movw	r24, r28
    2912:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2916:	8c 01       	movw	r16, r24
    2918:	69 ee       	ldi	r22, 0xE9	; 233
    291a:	74 e0       	ldi	r23, 0x04	; 4
    291c:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< PMS ("\t----------")
    2920:	6a e0       	ldi	r22, 0x0A	; 10
    2922:	c8 01       	movw	r24, r16
    2924:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2928:	8c 01       	movw	r16, r24
    292a:	6d ed       	ldi	r22, 0xDD	; 221
    292c:	74 e0       	ldi	r23, 0x04	; 4
    292e:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#endif
			<< PMS ("\t----") << endl;
    2932:	6a e0       	ldi	r22, 0x0A	; 10
    2934:	c8 01       	movw	r24, r16
    2936:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    293a:	8c 01       	movw	r16, r24
    293c:	67 ed       	ldi	r22, 0xD7	; 215
    293e:	74 e0       	ldi	r23, 0x04	; 4
    2940:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2944:	66 e0       	ldi	r22, 0x06	; 6
    2946:	c8 01       	movw	r24, r16
    2948:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>

	// Now have the tasks each print out their status. Tasks form a linked list, so
	// we only need to get the last task started and it will call the next, etc.
	if (last_created_task_pointer != NULL)
    294c:	80 91 52 31 	lds	r24, 0x3152	; 0x803152 <last_created_task_pointer>
    2950:	90 91 53 31 	lds	r25, 0x3153	; 0x803153 <last_created_task_pointer+0x1>
    2954:	00 97       	sbiw	r24, 0x00	; 0
    2956:	19 f0       	breq	.+6      	; 0x295e <_Z15print_task_listP8emstream+0xc2>
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
    2958:	be 01       	movw	r22, r28
    295a:	0e 94 35 14 	call	0x286a	; 0x286a <_ZN8frt_task20print_status_in_listEP8emstream>
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    295e:	0e 94 1b 0e 	call	0x1c36	; 0x1c36 <xTaskGetIdleTaskHandle>
    2962:	0e 94 86 11 	call	0x230c	; 0x230c <uxTaskGetStackHighWaterMark>
    2966:	18 2f       	mov	r17, r24
	{
		last_created_task_pointer->print_status_in_list (ser_dev);
	}

	// Have the idle task print out its information
	*ser_dev << PMS ("IDLE\t\t0\t-\t")
    2968:	6a e0       	ldi	r22, 0x0A	; 10
    296a:	ce 01       	movw	r24, r28
    296c:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2970:	ec 01       	movw	r28, r24
    2972:	6c ec       	ldi	r22, 0xCC	; 204
    2974:	74 e0       	ldi	r23, 0x04	; 4
    2976:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#if (INCLUDE_uxTaskGetStackHighWaterMark == 1)
			<< uxTaskGetStackHighWaterMark (xTaskGetIdleTaskHandle ())
    297a:	61 2f       	mov	r22, r17
    297c:	ce 01       	movw	r24, r28
    297e:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
			<< PMS ("/") << configMINIMAL_STACK_SIZE << PMS ("\t\t")
    2982:	6a e0       	ldi	r22, 0x0A	; 10
    2984:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2988:	ec 01       	movw	r28, r24
    298a:	6a ec       	ldi	r22, 0xCA	; 202
    298c:	74 e0       	ldi	r23, 0x04	; 4
    298e:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2992:	64 e6       	ldi	r22, 0x64	; 100
    2994:	70 e0       	ldi	r23, 0x00	; 0
    2996:	ce 01       	movw	r24, r28
    2998:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <_ZN8emstreamlsEj>
    299c:	6a e0       	ldi	r22, 0x0A	; 10
    299e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    29a2:	ec 01       	movw	r28, r24
    29a4:	67 ec       	ldi	r22, 0xC7	; 199
    29a6:	74 e0       	ldi	r23, 0x04	; 4
    29a8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		#endif
		#ifdef TASK_SETUP_AND_LOOP
			<< PMS ("-")
		#endif
			<< endl;
    29ac:	66 e0       	ldi	r22, 0x06	; 6
    29ae:	ce 01       	movw	r24, r28
    29b0:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
}
    29b4:	df 91       	pop	r29
    29b6:	cf 91       	pop	r28
    29b8:	1f 91       	pop	r17
    29ba:	0f 91       	pop	r16
    29bc:	08 95       	ret

000029be <_ZN14frt_text_queue7getcharEv>:
 *  the queue, it blocks until a character is received.
 *  @return The character which was received from the queue
 */

inline int16_t frt_text_queue::getchar (void)
{
    29be:	0f 93       	push	r16
    29c0:	cf 93       	push	r28
    29c2:	df 93       	push	r29
    29c4:	1f 92       	push	r1
    29c6:	cd b7       	in	r28, 0x3d	; 61
    29c8:	de b7       	in	r29, 0x3e	; 62
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
    29ca:	00 e0       	ldi	r16, 0x00	; 0
    29cc:	2f ef       	ldi	r18, 0xFF	; 255
    29ce:	3f ef       	ldi	r19, 0xFF	; 255
    29d0:	a9 01       	movw	r20, r18
    29d2:	be 01       	movw	r22, r28
    29d4:	6f 5f       	subi	r22, 0xFF	; 255
    29d6:	7f 4f       	sbci	r23, 0xFF	; 255
    29d8:	fc 01       	movw	r30, r24
    29da:	80 85       	ldd	r24, Z+8	; 0x08
    29dc:	91 85       	ldd	r25, Z+9	; 0x09
    29de:	0e 94 9a 0b 	call	0x1734	; 0x1734 <xQueueGenericReceive>
    29e2:	81 30       	cpi	r24, 0x01	; 1
    29e4:	19 f4       	brne	.+6      	; 0x29ec <_ZN14frt_text_queue7getcharEv+0x2e>
	{
		return (-1);
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	90 e0       	ldi	r25, 0x00	; 0
    29ea:	02 c0       	rjmp	.+4      	; 0x29f0 <_ZN14frt_text_queue7getcharEv+0x32>
	char recv_char;							// Character read from the queue

	// If xQueueReceive doesn't return pdTrue, nothing was found in the queue
	if (xQueueReceive (the_queue, &recv_char, portMAX_DELAY) != pdTRUE)
	{
		return (-1);
    29ec:	8f ef       	ldi	r24, 0xFF	; 255
    29ee:	9f ef       	ldi	r25, 0xFF	; 255
	}

	// OK, we got good data from the queue, so return it
	return (recv_char);
}
    29f0:	0f 90       	pop	r0
    29f2:	df 91       	pop	r29
    29f4:	cf 91       	pop	r28
    29f6:	0f 91       	pop	r16
    29f8:	08 95       	ret

000029fa <_ZN14frt_text_queue14check_for_charEv>:
 *  @return True for character available, false for no character available
 */

inline bool frt_text_queue::check_for_char (void)
{
	if (uxQueueMessagesWaiting (the_queue) == 0)
    29fa:	fc 01       	movw	r30, r24
    29fc:	80 85       	ldd	r24, Z+8	; 0x08
    29fe:	91 85       	ldd	r25, Z+9	; 0x09
    2a00:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <uxQueueMessagesWaiting>
    2a04:	91 e0       	ldi	r25, 0x01	; 1
    2a06:	81 11       	cpse	r24, r1
    2a08:	01 c0       	rjmp	.+2      	; 0x2a0c <_ZN14frt_text_queue14check_for_charEv+0x12>
    2a0a:	90 e0       	ldi	r25, 0x00	; 0
	{
		return (false);
	}
	return (true);
}
    2a0c:	89 2f       	mov	r24, r25
    2a0e:	08 95       	ret

00002a10 <_ZN14frt_text_queue7putcharEc>:
 *  @param a_char The character to be sent to the queue
 *  @return True if the character was successfully sent, false if something went wrong
 */

inline bool frt_text_queue::putchar (char a_char)
{
    2a10:	0f 93       	push	r16
    2a12:	cf 93       	push	r28
    2a14:	df 93       	push	r29
    2a16:	1f 92       	push	r1
    2a18:	cd b7       	in	r28, 0x3d	; 61
    2a1a:	de b7       	in	r29, 0x3e	; 62
    2a1c:	69 83       	std	Y+1, r22	; 0x01
	// If the data is successfully put in the queue, return true
	if (xQueueSendToBack (the_queue, &a_char, ticks_to_wait))
    2a1e:	fc 01       	movw	r30, r24
    2a20:	22 85       	ldd	r18, Z+10	; 0x0a
    2a22:	33 85       	ldd	r19, Z+11	; 0x0b
    2a24:	44 85       	ldd	r20, Z+12	; 0x0c
    2a26:	55 85       	ldd	r21, Z+13	; 0x0d
    2a28:	00 e0       	ldi	r16, 0x00	; 0
    2a2a:	be 01       	movw	r22, r28
    2a2c:	6f 5f       	subi	r22, 0xFF	; 255
    2a2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a30:	80 85       	ldd	r24, Z+8	; 0x08
    2a32:	91 85       	ldd	r25, Z+9	; 0x09
    2a34:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <xQueueGenericSend>
    2a38:	91 e0       	ldi	r25, 0x01	; 1
    2a3a:	81 11       	cpse	r24, r1
    2a3c:	01 c0       	rjmp	.+2      	; 0x2a40 <_ZN14frt_text_queue7putcharEc+0x30>
    2a3e:	90 e0       	ldi	r25, 0x00	; 0
		return (true);
	}

	// If we get here, something went wrong (probably a timeout), so return false
	return (false);
}
    2a40:	89 2f       	mov	r24, r25
    2a42:	0f 90       	pop	r0
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	0f 91       	pop	r16
    2a4a:	08 95       	ret

00002a4c <_ZN14frt_text_queueC1EjP8emstreamm>:
 *                     portMAX_DELAY causes a send to block indefinitely
 *  @param p_ser_dev A pointer which points to a serial device which can be used for
 *                   diagnostic logging or printing
 */

frt_text_queue::frt_text_queue (uint16_t queue_size, emstream* p_ser_dev,
    2a4c:	8f 92       	push	r8
    2a4e:	9f 92       	push	r9
    2a50:	bf 92       	push	r11
    2a52:	cf 92       	push	r12
    2a54:	df 92       	push	r13
    2a56:	ef 92       	push	r14
    2a58:	ff 92       	push	r15
    2a5a:	0f 93       	push	r16
    2a5c:	1f 93       	push	r17
    2a5e:	cf 93       	push	r28
    2a60:	df 93       	push	r29
    2a62:	ec 01       	movw	r28, r24
    2a64:	b6 2e       	mov	r11, r22
    2a66:	4a 01       	movw	r8, r20
    2a68:	68 01       	movw	r12, r16
    2a6a:	79 01       	movw	r14, r18
							   portTickType a_wait_time)
    2a6c:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <_ZN8emstreamC1Ev>
    2a70:	8f e5       	ldi	r24, 0x5F	; 95
    2a72:	90 e2       	ldi	r25, 0x20	; 32
    2a74:	88 83       	st	Y, r24
    2a76:	99 83       	std	Y+1, r25	; 0x01
{
	// Save the pointer to the serial device which is used for debugging
	p_serial = p_ser_dev;
    2a78:	8e 86       	std	Y+14, r8	; 0x0e
    2a7a:	9f 86       	std	Y+15, r9	; 0x0f

	// Create a FreeRTOS queue object which holds the given number of characters
	the_queue = xQueueCreate (queue_size, sizeof (char));
    2a7c:	40 e0       	ldi	r20, 0x00	; 0
    2a7e:	61 e0       	ldi	r22, 0x01	; 1
    2a80:	8b 2d       	mov	r24, r11
    2a82:	0e 94 d1 0a 	call	0x15a2	; 0x15a2 <xQueueGenericCreate>
    2a86:	88 87       	std	Y+8, r24	; 0x08
    2a88:	99 87       	std	Y+9, r25	; 0x09

	// Store the wait time; it will be used when writing to the queue
	ticks_to_wait = a_wait_time;
    2a8a:	ca 86       	std	Y+10, r12	; 0x0a
    2a8c:	db 86       	std	Y+11, r13	; 0x0b
    2a8e:	ec 86       	std	Y+12, r14	; 0x0c
    2a90:	fd 86       	std	Y+13, r15	; 0x0d
}
    2a92:	df 91       	pop	r29
    2a94:	cf 91       	pop	r28
    2a96:	1f 91       	pop	r17
    2a98:	0f 91       	pop	r16
    2a9a:	ff 90       	pop	r15
    2a9c:	ef 90       	pop	r14
    2a9e:	df 90       	pop	r13
    2aa0:	cf 90       	pop	r12
    2aa2:	bf 90       	pop	r11
    2aa4:	9f 90       	pop	r9
    2aa6:	8f 90       	pop	r8
    2aa8:	08 95       	ret

00002aaa <_ZN10time_stamp12get_microsecEv>:
 *  integer number of ticks per second.
 *  @return The number of microseconds in time stamp
 */

uint32_t time_stamp::get_microsec (void)
{
    2aaa:	cf 92       	push	r12
    2aac:	df 92       	push	r13
    2aae:	ef 92       	push	r14
    2ab0:	ff 92       	push	r15
    2ab2:	cf 93       	push	r28
    2ab4:	df 93       	push	r29
    2ab6:	ec 01       	movw	r28, r24
	return 
	(
		(int32_t)(tick_count % configTICK_RATE_HZ) * 1000000L / configTICK_RATE_HZ
			+ (int32_t)hardware_count * 1000000L 
				/ (configCPU_CLOCK_HZ / portCLOCK_PRESCALER)
	);
    2ab8:	68 81       	ld	r22, Y
    2aba:	79 81       	ldd	r23, Y+1	; 0x01
    2abc:	8a 81       	ldd	r24, Y+2	; 0x02
    2abe:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac0:	0f 2e       	mov	r0, r31
    2ac2:	f8 ee       	ldi	r31, 0xE8	; 232
    2ac4:	cf 2e       	mov	r12, r31
    2ac6:	f3 e0       	ldi	r31, 0x03	; 3
    2ac8:	df 2e       	mov	r13, r31
    2aca:	e1 2c       	mov	r14, r1
    2acc:	f1 2c       	mov	r15, r1
    2ace:	f0 2d       	mov	r31, r0
    2ad0:	a7 01       	movw	r20, r14
    2ad2:	96 01       	movw	r18, r12
    2ad4:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
    2ad8:	9b 01       	movw	r18, r22
    2ada:	ac 01       	movw	r20, r24
    2adc:	60 e4       	ldi	r22, 0x40	; 64
    2ade:	72 e4       	ldi	r23, 0x42	; 66
    2ae0:	8f e0       	ldi	r24, 0x0F	; 15
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <__mulsi3>
    2ae8:	a7 01       	movw	r20, r14
    2aea:	96 01       	movw	r18, r12
    2aec:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
    2af0:	69 01       	movw	r12, r18
    2af2:	7a 01       	movw	r14, r20
    2af4:	ac 81       	ldd	r26, Y+4	; 0x04
    2af6:	bd 81       	ldd	r27, Y+5	; 0x05
    2af8:	20 e4       	ldi	r18, 0x40	; 64
    2afa:	32 e4       	ldi	r19, 0x42	; 66
    2afc:	4f e0       	ldi	r20, 0x0F	; 15
    2afe:	50 e0       	ldi	r21, 0x00	; 0
    2b00:	0e 94 c3 1c 	call	0x3986	; 0x3986 <__muluhisi3>
    2b04:	20 e0       	ldi	r18, 0x00	; 0
    2b06:	38 e4       	ldi	r19, 0x48	; 72
    2b08:	48 ee       	ldi	r20, 0xE8	; 232
    2b0a:	51 e0       	ldi	r21, 0x01	; 1
    2b0c:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
    2b10:	c7 01       	movw	r24, r14
    2b12:	b6 01       	movw	r22, r12
    2b14:	62 0f       	add	r22, r18
    2b16:	73 1f       	adc	r23, r19
    2b18:	84 1f       	adc	r24, r20
    2b1a:	95 1f       	adc	r25, r21
}
    2b1c:	df 91       	pop	r29
    2b1e:	cf 91       	pop	r28
    2b20:	ff 90       	pop	r15
    2b22:	ef 90       	pop	r14
    2b24:	df 90       	pop	r13
    2b26:	cf 90       	pop	r12
    2b28:	08 95       	ret

00002b2a <_ZlsR8emstreamR10time_stamp>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& operator<< (emstream& serial, time_stamp& stamp)
{
    2b2a:	cf 92       	push	r12
    2b2c:	df 92       	push	r13
    2b2e:	ef 92       	push	r14
    2b30:	ff 92       	push	r15
    2b32:	0f 93       	push	r16
    2b34:	1f 93       	push	r17
    2b36:	cf 93       	push	r28
    2b38:	df 93       	push	r29
    2b3a:	cd b7       	in	r28, 0x3d	; 61
    2b3c:	de b7       	in	r29, 0x3e	; 62
    2b3e:	2f 97       	sbiw	r28, 0x0f	; 15
    2b40:	cd bf       	out	0x3d, r28	; 61
    2b42:	de bf       	out	0x3e, r29	; 62
    2b44:	6c 01       	movw	r12, r24
    2b46:	8b 01       	movw	r16, r22
	char dig_buffer[7];						// Holds digits we compute
	ldiv_t div_result;						// Holds results of long integer division

	// First write the seconds in the time stamp, then a decimal
	serial << stamp.get_seconds ();
    2b48:	db 01       	movw	r26, r22
    2b4a:	6d 91       	ld	r22, X+
    2b4c:	7d 91       	ld	r23, X+
    2b4e:	8d 91       	ld	r24, X+
    2b50:	9c 91       	ld	r25, X
    2b52:	28 ee       	ldi	r18, 0xE8	; 232
    2b54:	33 e0       	ldi	r19, 0x03	; 3
    2b56:	40 e0       	ldi	r20, 0x00	; 0
    2b58:	50 e0       	ldi	r21, 0x00	; 0
    2b5a:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
    2b5e:	ba 01       	movw	r22, r20
    2b60:	a9 01       	movw	r20, r18
    2b62:	c6 01       	movw	r24, r12
    2b64:	0e 94 20 18 	call	0x3040	; 0x3040 <_ZN8emstreamlsEm>
	serial.putchar ('.');
    2b68:	d6 01       	movw	r26, r12
    2b6a:	ed 91       	ld	r30, X+
    2b6c:	fc 91       	ld	r31, X
    2b6e:	02 80       	ldd	r0, Z+2	; 0x02
    2b70:	f3 81       	ldd	r31, Z+3	; 0x03
    2b72:	e0 2d       	mov	r30, r0
    2b74:	6e e2       	ldi	r22, 0x2E	; 46
    2b76:	c6 01       	movw	r24, r12
    2b78:	19 95       	eicall

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
    2b7a:	c8 01       	movw	r24, r16
    2b7c:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <_ZN10time_stamp12get_microsecEv>
    2b80:	8e 01       	movw	r16, r28
    2b82:	09 5f       	subi	r16, 0xF9	; 249
    2b84:	1f 4f       	sbci	r17, 0xFF	; 255
    2b86:	fe 01       	movw	r30, r28
    2b88:	31 96       	adiw	r30, 0x01	; 1
    2b8a:	7f 01       	movw	r14, r30
	for (int8_t index = 5; index >= 0; index--)
	{
		div_result = ldiv (div_result.quot, 10);
    2b8c:	2a e0       	ldi	r18, 0x0A	; 10
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	40 e0       	ldi	r20, 0x00	; 0
    2b92:	50 e0       	ldi	r21, 0x00	; 0
    2b94:	0e 94 9b 1c 	call	0x3936	; 0x3936 <__divmodsi4>
    2b98:	e6 2f       	mov	r30, r22
    2b9a:	28 87       	std	Y+8, r18	; 0x08
    2b9c:	39 87       	std	Y+9, r19	; 0x09
    2b9e:	4a 87       	std	Y+10, r20	; 0x0a
    2ba0:	5b 87       	std	Y+11, r21	; 0x0b
    2ba2:	68 85       	ldd	r22, Y+8	; 0x08
    2ba4:	79 85       	ldd	r23, Y+9	; 0x09
    2ba6:	8a 85       	ldd	r24, Y+10	; 0x0a
    2ba8:	9b 85       	ldd	r25, Y+11	; 0x0b
		dig_buffer[index] = div_result.rem + '0';
    2baa:	20 e3       	ldi	r18, 0x30	; 48
    2bac:	2e 0f       	add	r18, r30
    2bae:	d8 01       	movw	r26, r16
    2bb0:	2e 93       	st	-X, r18
    2bb2:	8d 01       	movw	r16, r26
	serial << stamp.get_seconds ();
	serial.putchar ('.');

	// Now get the microseconds; these will be written with leading zeros as needed
	div_result.quot = stamp.get_microsec ();
	for (int8_t index = 5; index >= 0; index--)
    2bb4:	ae 15       	cp	r26, r14
    2bb6:	bf 05       	cpc	r27, r15
    2bb8:	49 f7       	brne	.-46     	; 0x2b8c <_ZlsR8emstreamR10time_stamp+0x62>
		div_result = ldiv (div_result.quot, 10);
		dig_buffer[index] = div_result.rem + '0';
	}

	// The last item in the string must be a '\0' null character
	dig_buffer[6] = '\0';
    2bba:	1f 82       	std	Y+7, r1	; 0x07
    2bbc:	be 01       	movw	r22, r28
    2bbe:	6f 5f       	subi	r22, 0xFF	; 255
    2bc0:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc2:	c6 01       	movw	r24, r12
    2bc4:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>

	// Write the buffer, which now contains microsecond digits
	serial << dig_buffer;

	return (serial);
}
    2bc8:	c6 01       	movw	r24, r12
    2bca:	2f 96       	adiw	r28, 0x0f	; 15
    2bcc:	cd bf       	out	0x3d, r28	; 61
    2bce:	de bf       	out	0x3e, r29	; 62
    2bd0:	df 91       	pop	r29
    2bd2:	cf 91       	pop	r28
    2bd4:	1f 91       	pop	r17
    2bd6:	0f 91       	pop	r16
    2bd8:	ff 90       	pop	r15
    2bda:	ef 90       	pop	r14
    2bdc:	df 90       	pop	r13
    2bde:	cf 90       	pop	r12
    2be0:	08 95       	ret

00002be2 <_ZN10time_stamp10set_to_nowEv>:
 *  tick count. Still trying to figure out how to detect and fix this problem... 
 *  @return A reference to this time_stamp object, useful for printing the current time
 */

time_stamp& time_stamp::set_to_now (void)
{
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	ec 01       	movw	r28, r24
	// First disable interrupts so that if the hardware timer hits its maximum value
	// after this point and before we're done, the RTOS tick count won't be incremented
	// and also this function won't be interrupted by a task switch
	portENTER_CRITICAL ();
    2be8:	0f b6       	in	r0, 0x3f	; 63
    2bea:	f8 94       	cli
    2bec:	0f 92       	push	r0
	#elif (defined TIMER3_COMPA_vect)
		hardware_count = TCNT3;
	#elif (defined TIMER1_COMPA_vect)
	hardware_count = TCNT1;
	#else
		hardware_count = TCC0.CNT;
    2bee:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2bf2:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2bf6:	8c 83       	std	Y+4, r24	; 0x04
    2bf8:	9d 83       	std	Y+5, r25	; 0x05
	#endif

	// Now get the tick count (interrupts are still disabled)
	tick_count = xTaskGetTickCount ();
    2bfa:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <xTaskGetTickCount>
    2bfe:	68 83       	st	Y, r22
    2c00:	79 83       	std	Y+1, r23	; 0x01
    2c02:	8a 83       	std	Y+2, r24	; 0x02
    2c04:	9b 83       	std	Y+3, r25	; 0x03

	// Re-enable interrupts here; if the tick count is incremented now, that's fine
	portEXIT_CRITICAL ();
    2c06:	0f 90       	pop	r0
    2c08:	0f be       	out	0x3f, r0	; 63

	// Return a reference to this object
	return (*this);
}
    2c0a:	ce 01       	movw	r24, r28
    2c0c:	df 91       	pop	r29
    2c0e:	cf 91       	pop	r28
    2c10:	08 95       	ret

00002c12 <_Z15hex_dump_memoryPhS_P8emstreambh>:
 *      of a task's stack memory space. 
 */

void hex_dump_memory (uint8_t* start_address, uint8_t* end_address,
					  emstream* p_ser_dev, bool highlight, uint8_t empty_code)
{
    2c12:	5f 92       	push	r5
    2c14:	6f 92       	push	r6
    2c16:	7f 92       	push	r7
    2c18:	8f 92       	push	r8
    2c1a:	9f 92       	push	r9
    2c1c:	af 92       	push	r10
    2c1e:	bf 92       	push	r11
    2c20:	cf 92       	push	r12
    2c22:	df 92       	push	r13
    2c24:	ef 92       	push	r14
    2c26:	ff 92       	push	r15
    2c28:	0f 93       	push	r16
    2c2a:	1f 93       	push	r17
    2c2c:	cf 93       	push	r28
    2c2e:	df 93       	push	r29
    2c30:	5c 01       	movw	r10, r24
    2c32:	4b 01       	movw	r8, r22
    2c34:	7a 01       	movw	r14, r20
    2c36:	12 2f       	mov	r17, r18
    2c38:	70 2e       	mov	r7, r16
	// pointers together, we convert the pointers into equivalent integers (this is
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
    2c3a:	63 e0       	ldi	r22, 0x03	; 3
    2c3c:	ca 01       	movw	r24, r20
    2c3e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	while (start_address < end_address)
    2c42:	a8 14       	cp	r10, r8
    2c44:	b9 04       	cpc	r11, r9
    2c46:	08 f0       	brcs	.+2      	; 0x2c4a <_Z15hex_dump_memoryPhS_P8emstreambh+0x38>
    2c48:	7d c0       	rjmp	.+250    	; 0x2d44 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2c4a:	65 01       	movw	r12, r10
    2c4c:	84 e1       	ldi	r24, 0x14	; 20
    2c4e:	c8 0e       	add	r12, r24
    2c50:	d1 1c       	adc	r13, r1
    2c52:	00 e0       	ldi	r16, 0x00	; 0
	{
		// Print the line address 
		*p_ser_dev << (size_t)(start_address) << PMS ("  ");
    2c54:	6a 2c       	mov	r6, r10
    2c56:	5b 2c       	mov	r5, r11
    2c58:	b5 01       	movw	r22, r10
    2c5a:	c7 01       	movw	r24, r14
    2c5c:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <_ZN8emstreamlsEj>
    2c60:	6a e0       	ldi	r22, 0x0A	; 10
    2c62:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2c66:	69 e4       	ldi	r22, 0x49	; 73
    2c68:	75 e0       	ldi	r23, 0x05	; 5
    2c6a:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>

		// Show a line full of data in hexadecimal format. If the memory has not been
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
    2c6e:	11 23       	and	r17, r17
    2c70:	09 f4       	brne	.+2      	; 0x2c74 <_Z15hex_dump_memoryPhS_P8emstreambh+0x62>
    2c72:	6d c0       	rjmp	.+218    	; 0x2d4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
    2c74:	00 23       	and	r16, r16
    2c76:	09 f4       	brne	.+2      	; 0x2c7a <_Z15hex_dump_memoryPhS_P8emstreambh+0x68>
    2c78:	6a c0       	rjmp	.+212    	; 0x2d4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		{
			*p_ser_dev << ATERM_BOLD;
    2c7a:	6a e0       	ldi	r22, 0x0A	; 10
    2c7c:	c7 01       	movw	r24, r14
    2c7e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2c82:	64 e4       	ldi	r22, 0x44	; 68
    2c84:	75 e0       	ldi	r23, 0x05	; 5
    2c86:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    2c8a:	61 c0       	rjmp	.+194    	; 0x2d4e <_Z15hex_dump_memoryPhS_P8emstreambh+0x13c>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
    2c8c:	11 23       	and	r17, r17
    2c8e:	71 f0       	breq	.+28     	; 0x2cac <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2c90:	01 11       	cpse	r16, r1
    2c92:	0c c0       	rjmp	.+24     	; 0x2cac <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
    2c94:	88 81       	ld	r24, Y
    2c96:	87 15       	cp	r24, r7
    2c98:	49 f0       	breq	.+18     	; 0x2cac <_Z15hex_dump_memoryPhS_P8emstreambh+0x9a>
			{
				found_changes = true;
				*p_ser_dev << ATERM_BOLD;
    2c9a:	6a e0       	ldi	r22, 0x0A	; 10
    2c9c:	c7 01       	movw	r24, r14
    2c9e:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2ca2:	6f e3       	ldi	r22, 0x3F	; 63
    2ca4:	75 e0       	ldi	r23, 0x05	; 5
    2ca6:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2caa:	01 e0       	ldi	r16, 0x01	; 1
				*p_ser_dev << ATERM_BOLD;
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
    2cac:	69 91       	ld	r22, Y+
    2cae:	c7 01       	movw	r24, r14
    2cb0:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2cb4:	dc 01       	movw	r26, r24
    2cb6:	ed 91       	ld	r30, X+
    2cb8:	fc 91       	ld	r31, X
    2cba:	02 80       	ldd	r0, Z+2	; 0x02
    2cbc:	f3 81       	ldd	r31, Z+3	; 0x03
    2cbe:	e0 2d       	mov	r30, r0
    2cc0:	60 e2       	ldi	r22, 0x20	; 32
    2cc2:	19 95       	eicall
		// changed from its original value, show it non-highlighted
		if (highlight && found_changes)
		{
			*p_ser_dev << ATERM_BOLD;
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
    2cc4:	cc 16       	cp	r12, r28
    2cc6:	dd 06       	cpc	r13, r29
    2cc8:	09 f7       	brne	.-62     	; 0x2c8c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>
			}
			*p_ser_dev << (uint8_t)(*start_address++) << (char)(' ');
		}

		// Show the same line full of data in text format
		if (highlight)
    2cca:	11 23       	and	r17, r17
    2ccc:	89 f0       	breq	.+34     	; 0x2cf0 <_Z15hex_dump_memoryPhS_P8emstreambh+0xde>
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
    2cce:	6a e0       	ldi	r22, 0x0A	; 10
    2cd0:	c7 01       	movw	r24, r14
    2cd2:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2cd6:	ec 01       	movw	r28, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    2cd8:	69 e3       	ldi	r22, 0x39	; 57
    2cda:	75 e0       	ldi	r23, 0x05	; 5
    2cdc:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
		 *  @param ch The character to be printed
		 *  @return A reference to the serial device on which the printing is done
		 */
		emstream& operator<< (char ch)
		{
			putchar (ch); 
    2ce0:	e8 81       	ld	r30, Y
    2ce2:	f9 81       	ldd	r31, Y+1	; 0x01
    2ce4:	02 80       	ldd	r0, Z+2	; 0x02
    2ce6:	f3 81       	ldd	r31, Z+3	; 0x03
    2ce8:	e0 2d       	mov	r30, r0
    2cea:	60 e2       	ldi	r22, 0x20	; 32
    2cec:	ce 01       	movw	r24, r28
    2cee:	19 95       	eicall
		}
		for (byte_count = 0; byte_count < DUMP_BYTES_PER_LINE; byte_count++)
		{
			if (highlight && (!found_changes) && ((*start_address) != empty_code))
			{
				found_changes = true;
    2cf0:	c6 2d       	mov	r28, r6
    2cf2:	d5 2d       	mov	r29, r5
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
		{
			temp_byte = *start_address++;
    2cf4:	69 91       	ld	r22, Y+
			if (temp_byte >= ' ' && temp_byte <= '~')
    2cf6:	80 ee       	ldi	r24, 0xE0	; 224
    2cf8:	86 0f       	add	r24, r22
    2cfa:	8f 35       	cpi	r24, 0x5F	; 95
    2cfc:	48 f4       	brcc	.+18     	; 0x2d10 <_Z15hex_dump_memoryPhS_P8emstreambh+0xfe>
				p_ser_dev->putchar (temp_byte);
    2cfe:	d7 01       	movw	r26, r14
    2d00:	ed 91       	ld	r30, X+
    2d02:	fc 91       	ld	r31, X
    2d04:	02 80       	ldd	r0, Z+2	; 0x02
    2d06:	f3 81       	ldd	r31, Z+3	; 0x03
    2d08:	e0 2d       	mov	r30, r0
    2d0a:	c7 01       	movw	r24, r14
    2d0c:	19 95       	eicall
    2d0e:	09 c0       	rjmp	.+18     	; 0x2d22 <_Z15hex_dump_memoryPhS_P8emstreambh+0x110>
			else
				p_ser_dev->putchar ('.');
    2d10:	d7 01       	movw	r26, r14
    2d12:	ed 91       	ld	r30, X+
    2d14:	fc 91       	ld	r31, X
    2d16:	02 80       	ldd	r0, Z+2	; 0x02
    2d18:	f3 81       	ldd	r31, Z+3	; 0x03
    2d1a:	e0 2d       	mov	r30, r0
    2d1c:	6e e2       	ldi	r22, 0x2E	; 46
    2d1e:	c7 01       	movw	r24, r14
    2d20:	19 95       	eicall
		// Show the same line full of data in text format
		if (highlight)
		{
			*p_ser_dev << ATERM_NORM_INT << (char)(' ');
		}
		for (start_address -= DUMP_BYTES_PER_LINE; byte_count > 0; byte_count--)
    2d22:	cc 16       	cp	r12, r28
    2d24:	dd 06       	cpc	r13, r29
    2d26:	31 f7       	brne	.-52     	; 0x2cf4 <_Z15hex_dump_memoryPhS_P8emstreambh+0xe2>
    2d28:	b4 e1       	ldi	r27, 0x14	; 20
    2d2a:	ab 0e       	add	r10, r27
    2d2c:	b1 1c       	adc	r11, r1
			else
				p_ser_dev->putchar ('.');
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
    2d2e:	66 e0       	ldi	r22, 0x06	; 6
    2d30:	c7 01       	movw	r24, r14
    2d32:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    2d36:	84 e1       	ldi	r24, 0x14	; 20
    2d38:	c8 0e       	add	r12, r24
    2d3a:	d1 1c       	adc	r13, r1
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d3c:	a8 14       	cp	r10, r8
    2d3e:	b9 04       	cpc	r11, r9
    2d40:	08 f4       	brcc	.+2      	; 0x2d44 <_Z15hex_dump_memoryPhS_P8emstreambh+0x132>
    2d42:	88 cf       	rjmp	.-240    	; 0x2c54 <_Z15hex_dump_memoryPhS_P8emstreambh+0x42>
		}

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
    2d44:	62 e0       	ldi	r22, 0x02	; 2
    2d46:	c7 01       	movw	r24, r14
    2d48:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
}
    2d4c:	03 c0       	rjmp	.+6      	; 0x2d54 <_Z15hex_dump_memoryPhS_P8emstreambh+0x142>
	// non-portable and may need to be changed for other processors!), add those
	// together, then convert back into a pointer

	// Print DUMP_BYTES_PER_LINE bytes on each line
	*p_ser_dev << hex;
	while (start_address < end_address)
    2d4e:	c6 2d       	mov	r28, r6
    2d50:	d5 2d       	mov	r29, r5
    2d52:	9c cf       	rjmp	.-200    	; 0x2c8c <_Z15hex_dump_memoryPhS_P8emstreambh+0x7a>

		// Put a return at the end of the line
		*p_ser_dev << endl;
	}
	*p_ser_dev << dec;
}
    2d54:	df 91       	pop	r29
    2d56:	cf 91       	pop	r28
    2d58:	1f 91       	pop	r17
    2d5a:	0f 91       	pop	r16
    2d5c:	ff 90       	pop	r15
    2d5e:	ef 90       	pop	r14
    2d60:	df 90       	pop	r13
    2d62:	cf 90       	pop	r12
    2d64:	bf 90       	pop	r11
    2d66:	af 90       	pop	r10
    2d68:	9f 90       	pop	r9
    2d6a:	8f 90       	pop	r8
    2d6c:	7f 90       	pop	r7
    2d6e:	6f 90       	pop	r6
    2d70:	5f 90       	pop	r5
    2d72:	08 95       	ret

00002d74 <_Znwj>:
 *  @param g A pointer to some random thing
 */
extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    2d74:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pvPortMalloc>
    2d78:	08 95       	ret

00002d7a <_Znaj>:
    2d7a:	0e 94 eb 06 	call	0xdd6	; 0xdd6 <pvPortMalloc>
    2d7e:	08 95       	ret

00002d80 <__cxa_pure_virtual>:
 */

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    2d80:	08 95       	ret

00002d82 <_ZN7base232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

base232::base232 (unsigned int baud_rate, USART_t* p_usart)
    2d82:	cf 93       	push	r28
    2d84:	df 93       	push	r29
    2d86:	fc 01       	movw	r30, r24
    2d88:	da 01       	movw	r26, r20
{
	// Store pointers to usart struct and port struct
	p_usart = p_usart;
	p_port = p_port;
	
	if(p_usart == &USARTC0)
    2d8a:	40 3a       	cpi	r20, 0xA0	; 160
    2d8c:	68 e0       	ldi	r22, 0x08	; 8
    2d8e:	56 07       	cpc	r21, r22
    2d90:	49 f4       	brne	.+18     	; 0x2da4 <_ZN7base232C1EjP12USART_struct+0x22>
	{
		p_port = &PORTC;
    2d92:	80 e4       	ldi	r24, 0x40	; 64
    2d94:	96 e0       	ldi	r25, 0x06	; 6
    2d96:	82 83       	std	Z+2, r24	; 0x02
    2d98:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2d9a:	82 e0       	ldi	r24, 0x02	; 2
    2d9c:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2d9e:	83 e0       	ldi	r24, 0x03	; 3
    2da0:	85 83       	std	Z+5, r24	; 0x05
    2da2:	32 c0       	rjmp	.+100    	; 0x2e08 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#ifdef USARTC1 
	else if(p_usart == &USARTC1)
    2da4:	40 3b       	cpi	r20, 0xB0	; 176
    2da6:	78 e0       	ldi	r23, 0x08	; 8
    2da8:	57 07       	cpc	r21, r23
    2daa:	49 f4       	brne	.+18     	; 0x2dbe <_ZN7base232C1EjP12USART_struct+0x3c>
	{
		p_port = &PORTC;
    2dac:	80 e4       	ldi	r24, 0x40	; 64
    2dae:	96 e0       	ldi	r25, 0x06	; 6
    2db0:	82 83       	std	Z+2, r24	; 0x02
    2db2:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2db4:	86 e0       	ldi	r24, 0x06	; 6
    2db6:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2db8:	87 e0       	ldi	r24, 0x07	; 7
    2dba:	85 83       	std	Z+5, r24	; 0x05
    2dbc:	25 c0       	rjmp	.+74     	; 0x2e08 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    2dbe:	40 3a       	cpi	r20, 0xA0	; 160
    2dc0:	89 e0       	ldi	r24, 0x09	; 9
    2dc2:	58 07       	cpc	r21, r24
    2dc4:	49 f4       	brne	.+18     	; 0x2dd8 <_ZN7base232C1EjP12USART_struct+0x56>
	{
		p_port = &PORTD;
    2dc6:	80 e6       	ldi	r24, 0x60	; 96
    2dc8:	96 e0       	ldi	r25, 0x06	; 6
    2dca:	82 83       	std	Z+2, r24	; 0x02
    2dcc:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2dce:	82 e0       	ldi	r24, 0x02	; 2
    2dd0:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2dd2:	83 e0       	ldi	r24, 0x03	; 3
    2dd4:	85 83       	std	Z+5, r24	; 0x05
    2dd6:	18 c0       	rjmp	.+48     	; 0x2e08 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTD1 
	else if(p_usart == &USARTD1)
    2dd8:	40 3b       	cpi	r20, 0xB0	; 176
    2dda:	69 e0       	ldi	r22, 0x09	; 9
    2ddc:	56 07       	cpc	r21, r22
    2dde:	49 f4       	brne	.+18     	; 0x2df2 <_ZN7base232C1EjP12USART_struct+0x70>
	{
		p_port = &PORTD;
    2de0:	80 e6       	ldi	r24, 0x60	; 96
    2de2:	96 e0       	ldi	r25, 0x06	; 6
    2de4:	82 83       	std	Z+2, r24	; 0x02
    2de6:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 6;
    2de8:	86 e0       	ldi	r24, 0x06	; 6
    2dea:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 7;
    2dec:	87 e0       	ldi	r24, 0x07	; 7
    2dee:	85 83       	std	Z+5, r24	; 0x05
    2df0:	0b c0       	rjmp	.+22     	; 0x2e08 <_ZN7base232C1EjP12USART_struct+0x86>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    2df2:	40 3a       	cpi	r20, 0xA0	; 160
    2df4:	5a 40       	sbci	r21, 0x0A	; 10
    2df6:	41 f4       	brne	.+16     	; 0x2e08 <_ZN7base232C1EjP12USART_struct+0x86>
	{
		p_port = &PORTE;
    2df8:	80 e8       	ldi	r24, 0x80	; 128
    2dfa:	96 e0       	ldi	r25, 0x06	; 6
    2dfc:	82 83       	std	Z+2, r24	; 0x02
    2dfe:	93 83       	std	Z+3, r25	; 0x03
		rxd_pin = 2;
    2e00:	82 e0       	ldi	r24, 0x02	; 2
    2e02:	84 83       	std	Z+4, r24	; 0x04
		txd_pin = 3;
    2e04:	83 e0       	ldi	r24, 0x03	; 3
    2e06:	85 83       	std	Z+5, r24	; 0x05
	else
	{
	}
	
	// Store pointers to data, status, config registers
	p_UDR = &(p_usart->DATA);
    2e08:	a6 83       	std	Z+6, r26	; 0x06
    2e0a:	b7 83       	std	Z+7, r27	; 0x07
	p_USR = &(p_usart->STATUS);
    2e0c:	cd 01       	movw	r24, r26
    2e0e:	01 96       	adiw	r24, 0x01	; 1
    2e10:	80 87       	std	Z+8, r24	; 0x08
    2e12:	91 87       	std	Z+9, r25	; 0x09
	p_UCR = &(p_usart->CTRLB);
    2e14:	03 96       	adiw	r24, 0x03	; 3
    2e16:	82 87       	std	Z+10, r24	; 0x0a
    2e18:	93 87       	std	Z+11, r25	; 0x0b
	
	// Set up TXD as an output that is high
	p_port->OUT |= (1 << txd_pin);
    2e1a:	25 81       	ldd	r18, Z+5	; 0x05
    2e1c:	c2 81       	ldd	r28, Z+2	; 0x02
    2e1e:	d3 81       	ldd	r29, Z+3	; 0x03
    2e20:	4c 81       	ldd	r20, Y+4	; 0x04
    2e22:	81 e0       	ldi	r24, 0x01	; 1
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	bc 01       	movw	r22, r24
    2e28:	02 c0       	rjmp	.+4      	; 0x2e2e <_ZN7base232C1EjP12USART_struct+0xac>
    2e2a:	66 0f       	add	r22, r22
    2e2c:	77 1f       	adc	r23, r23
    2e2e:	2a 95       	dec	r18
    2e30:	e2 f7       	brpl	.-8      	; 0x2e2a <_ZN7base232C1EjP12USART_struct+0xa8>
    2e32:	9b 01       	movw	r18, r22
    2e34:	24 2b       	or	r18, r20
    2e36:	2c 83       	std	Y+4, r18	; 0x04
	p_port->DIR |= (1 << txd_pin);
    2e38:	25 81       	ldd	r18, Z+5	; 0x05
    2e3a:	c2 81       	ldd	r28, Z+2	; 0x02
    2e3c:	d3 81       	ldd	r29, Z+3	; 0x03
    2e3e:	48 81       	ld	r20, Y
    2e40:	bc 01       	movw	r22, r24
    2e42:	02 c0       	rjmp	.+4      	; 0x2e48 <_ZN7base232C1EjP12USART_struct+0xc6>
    2e44:	66 0f       	add	r22, r22
    2e46:	77 1f       	adc	r23, r23
    2e48:	2a 95       	dec	r18
    2e4a:	e2 f7       	brpl	.-8      	; 0x2e44 <_ZN7base232C1EjP12USART_struct+0xc2>
    2e4c:	9b 01       	movw	r18, r22
    2e4e:	24 2b       	or	r18, r20
    2e50:	28 83       	st	Y, r18
	
	// Set up RXD as an input
	p_port->DIR &= ~(1 << rxd_pin);
    2e52:	34 81       	ldd	r19, Z+4	; 0x04
    2e54:	c2 81       	ldd	r28, Z+2	; 0x02
    2e56:	d3 81       	ldd	r29, Z+3	; 0x03
    2e58:	28 81       	ld	r18, Y
    2e5a:	02 c0       	rjmp	.+4      	; 0x2e60 <_ZN7base232C1EjP12USART_struct+0xde>
    2e5c:	88 0f       	add	r24, r24
    2e5e:	99 1f       	adc	r25, r25
    2e60:	3a 95       	dec	r19
    2e62:	e2 f7       	brpl	.-8      	; 0x2e5c <_ZN7base232C1EjP12USART_struct+0xda>
    2e64:	80 95       	com	r24
    2e66:	90 95       	com	r25
    2e68:	82 23       	and	r24, r18
    2e6a:	88 83       	st	Y, r24
	
	// Enable interrupts for RX at high priority
	p_usart->CTRLA = (0 << USART_RXCINTLVL1_bp | 1 << USART_RXCINTLVL0_bp);
    2e6c:	80 e1       	ldi	r24, 0x10	; 16
    2e6e:	13 96       	adiw	r26, 0x03	; 3
    2e70:	8c 93       	st	X, r24
    2e72:	13 97       	sbiw	r26, 0x03	; 3
	
	// Select USART Asynchronous Mode and choose character size
	p_usart->CTRLC = (1 << USART_CHSIZE0_bp | 1 << USART_CHSIZE1_bp );
    2e74:	83 e0       	ldi	r24, 0x03	; 3
    2e76:	15 96       	adiw	r26, 0x05	; 5
    2e78:	8c 93       	st	X, r24
    2e7a:	15 97       	sbiw	r26, 0x05	; 5

	// Select the baudrate according to Table 23-5 in the datasheet
	p_usart->BAUDCTRLB = (-1 << USART_BSCALE0_bp);
    2e7c:	80 ef       	ldi	r24, 0xF0	; 240
    2e7e:	17 96       	adiw	r26, 0x07	; 7
    2e80:	8c 93       	st	X, r24
    2e82:	17 97       	sbiw	r26, 0x07	; 7
	p_usart->BAUDCTRLA = (33 << USART_BSEL0_bp);
    2e84:	81 e2       	ldi	r24, 0x21	; 33
    2e86:	16 96       	adiw	r26, 0x06	; 6
    2e88:	8c 93       	st	X, r24
    2e8a:	16 97       	sbiw	r26, 0x06	; 6

	// Enable the RX and TX devices
	p_usart->CTRLB = (1 << USART_RXEN_bp | 1<< USART_TXEN_bp);
    2e8c:	88 e1       	ldi	r24, 0x18	; 24
    2e8e:	14 96       	adiw	r26, 0x04	; 4
    2e90:	8c 93       	st	X, r24

	// Save some masks
	mask_RXC = USART_RXCIF_bm;
    2e92:	80 e8       	ldi	r24, 0x80	; 128
    2e94:	85 87       	std	Z+13, r24	; 0x0d
	mask_TXC = USART_TXCIF_bm;
    2e96:	80 e4       	ldi	r24, 0x40	; 64
    2e98:	86 87       	std	Z+14, r24	; 0x0e
	mask_UDRE = USART_DREIF_bm;
    2e9a:	80 e2       	ldi	r24, 0x20	; 32
    2e9c:	84 87       	std	Z+12, r24	; 0x0c
	
	// Read the data register to ensure that it's empty
	p_UDR[0]; p_UDR[0];
    2e9e:	06 80       	ldd	r0, Z+6	; 0x06
    2ea0:	f7 81       	ldd	r31, Z+7	; 0x07
    2ea2:	e0 2d       	mov	r30, r0
    2ea4:	80 81       	ld	r24, Z
    2ea6:	80 81       	ld	r24, Z
}
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	08 95       	ret

00002eae <_ZN8emstream13ready_to_sendEv>:
		digits = 7;
	}
	bts_glob_prec = digits;

	return (manip_set_precision);
}
    2eae:	81 e0       	ldi	r24, 0x01	; 1
    2eb0:	08 95       	ret

00002eb2 <_ZN8emstream7getcharEv>:
    2eb2:	80 e0       	ldi	r24, 0x00	; 0
    2eb4:	90 e0       	ldi	r25, 0x00	; 0
    2eb6:	08 95       	ret

00002eb8 <_ZN8emstream14check_for_charEv>:
    2eb8:	80 e0       	ldi	r24, 0x00	; 0
    2eba:	08 95       	ret

00002ebc <_ZN8emstream12transmit_nowEv>:
    2ebc:	08 95       	ret

00002ebe <_ZN8emstream12clear_screenEv>:
    2ebe:	08 95       	ret

00002ec0 <_ZN8emstreamC1Ev>:
    2ec0:	fc 01       	movw	r30, r24
    2ec2:	8f e6       	ldi	r24, 0x6F	; 111
    2ec4:	90 e2       	ldi	r25, 0x20	; 32
    2ec6:	80 83       	st	Z, r24
    2ec8:	91 83       	std	Z+1, r25	; 0x01
    2eca:	8a e0       	ldi	r24, 0x0A	; 10
    2ecc:	82 83       	std	Z+2, r24	; 0x02
    2ece:	13 82       	std	Z+3, r1	; 0x03
    2ed0:	83 e0       	ldi	r24, 0x03	; 3
    2ed2:	85 83       	std	Z+5, r24	; 0x05
    2ed4:	14 82       	std	Z+4, r1	; 0x04
    2ed6:	16 82       	std	Z+6, r1	; 0x06
    2ed8:	17 82       	std	Z+7, r1	; 0x07
    2eda:	08 95       	ret

00002edc <_ZN8emstream4putsEPKc>:
    2edc:	0f 93       	push	r16
    2ede:	1f 93       	push	r17
    2ee0:	cf 93       	push	r28
    2ee2:	df 93       	push	r29
    2ee4:	8c 01       	movw	r16, r24
    2ee6:	fb 01       	movw	r30, r22
    2ee8:	dc 01       	movw	r26, r24
    2eea:	14 96       	adiw	r26, 0x04	; 4
    2eec:	8c 91       	ld	r24, X
    2eee:	81 11       	cpse	r24, r1
    2ef0:	04 c0       	rjmp	.+8      	; 0x2efa <_ZN8emstream4putsEPKc+0x1e>
    2ef2:	60 81       	ld	r22, Z
    2ef4:	61 11       	cpse	r22, r1
    2ef6:	17 c0       	rjmp	.+46     	; 0x2f26 <_ZN8emstream4putsEPKc+0x4a>
    2ef8:	23 c0       	rjmp	.+70     	; 0x2f40 <_ZN8emstream4putsEPKc+0x64>
    2efa:	d8 01       	movw	r26, r16
    2efc:	14 96       	adiw	r26, 0x04	; 4
    2efe:	1c 92       	st	X, r1
    2f00:	eb 01       	movw	r28, r22
    2f02:	21 96       	adiw	r28, 0x01	; 1
    2f04:	64 91       	lpm	r22, Z
    2f06:	66 23       	and	r22, r22
    2f08:	d9 f0       	breq	.+54     	; 0x2f40 <_ZN8emstream4putsEPKc+0x64>
    2f0a:	d8 01       	movw	r26, r16
    2f0c:	ed 91       	ld	r30, X+
    2f0e:	fc 91       	ld	r31, X
    2f10:	02 80       	ldd	r0, Z+2	; 0x02
    2f12:	f3 81       	ldd	r31, Z+3	; 0x03
    2f14:	e0 2d       	mov	r30, r0
    2f16:	c8 01       	movw	r24, r16
    2f18:	19 95       	eicall
    2f1a:	fe 01       	movw	r30, r28
    2f1c:	64 91       	lpm	r22, Z
    2f1e:	21 96       	adiw	r28, 0x01	; 1
    2f20:	61 11       	cpse	r22, r1
    2f22:	f3 cf       	rjmp	.-26     	; 0x2f0a <_ZN8emstream4putsEPKc+0x2e>
    2f24:	0d c0       	rjmp	.+26     	; 0x2f40 <_ZN8emstream4putsEPKc+0x64>
    2f26:	ef 01       	movw	r28, r30
    2f28:	21 96       	adiw	r28, 0x01	; 1
    2f2a:	d8 01       	movw	r26, r16
    2f2c:	ed 91       	ld	r30, X+
    2f2e:	fc 91       	ld	r31, X
    2f30:	02 80       	ldd	r0, Z+2	; 0x02
    2f32:	f3 81       	ldd	r31, Z+3	; 0x03
    2f34:	e0 2d       	mov	r30, r0
    2f36:	c8 01       	movw	r24, r16
    2f38:	19 95       	eicall
    2f3a:	69 91       	ld	r22, Y+
    2f3c:	61 11       	cpse	r22, r1
    2f3e:	f5 cf       	rjmp	.-22     	; 0x2f2a <_ZN8emstream4putsEPKc+0x4e>
    2f40:	df 91       	pop	r29
    2f42:	cf 91       	pop	r28
    2f44:	1f 91       	pop	r17
    2f46:	0f 91       	pop	r16
    2f48:	08 95       	ret

00002f4a <_ZN8emstreamlsE15ser_manipulator>:
 *  @return A reference to the serial device to which the data was printed. This
 *          reference is used to string printable items together with "<<" operators
 */

emstream& emstream::operator<< (ser_manipulator new_manip)
{
    2f4a:	cf 93       	push	r28
    2f4c:	df 93       	push	r29
    2f4e:	ec 01       	movw	r28, r24
	switch (new_manip)
    2f50:	86 2f       	mov	r24, r22
    2f52:	90 e0       	ldi	r25, 0x00	; 0
    2f54:	8b 30       	cpi	r24, 0x0B	; 11
    2f56:	91 05       	cpc	r25, r1
    2f58:	d8 f5       	brcc	.+118    	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	88 27       	eor	r24, r24
    2f5e:	e2 50       	subi	r30, 0x02	; 2
    2f60:	ff 4f       	sbci	r31, 0xFF	; 255
    2f62:	8f 4f       	sbci	r24, 0xFF	; 255
    2f64:	0c 94 ba 1c 	jmp	0x3974	; 0x3974 <__tablejump2__>
	{
		case (bin):                         // Print integers in binary
			base = 2;
    2f68:	82 e0       	ldi	r24, 0x02	; 2
    2f6a:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f6c:	31 c0       	rjmp	.+98     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (oct):                         // Print integers in octal
			base = 8;
    2f6e:	88 e0       	ldi	r24, 0x08	; 8
    2f70:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f72:	2e c0       	rjmp	.+92     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (dec):                         // Print integers in decimal
			base = 10;
    2f74:	8a e0       	ldi	r24, 0x0A	; 10
    2f76:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f78:	2b c0       	rjmp	.+86     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (hex):                         // Print integers in hexadecimal
			base = 16;
    2f7a:	80 e1       	ldi	r24, 0x10	; 16
    2f7c:	8a 83       	std	Y+2, r24	; 0x02
			break;
    2f7e:	28 c0       	rjmp	.+80     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (ascii):                       // Print chars as ASCII letters, etc.
			print_ascii = true;
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	8b 83       	std	Y+3, r24	; 0x03
			break;
    2f84:	25 c0       	rjmp	.+74     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (numeric):                     // Print chars as numbers
			print_ascii = false;
    2f86:	1b 82       	std	Y+3, r1	; 0x03
			break;
    2f88:	23 c0       	rjmp	.+70     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (endl):                        // Send an end-of-line
			ENDL_STYLE ();
    2f8a:	e8 81       	ld	r30, Y
    2f8c:	f9 81       	ldd	r31, Y+1	; 0x01
    2f8e:	02 80       	ldd	r0, Z+2	; 0x02
    2f90:	f3 81       	ldd	r31, Z+3	; 0x03
    2f92:	e0 2d       	mov	r30, r0
    2f94:	6d e0       	ldi	r22, 0x0D	; 13
    2f96:	ce 01       	movw	r24, r28
    2f98:	19 95       	eicall
    2f9a:	e8 81       	ld	r30, Y
    2f9c:	f9 81       	ldd	r31, Y+1	; 0x01
    2f9e:	02 80       	ldd	r0, Z+2	; 0x02
    2fa0:	f3 81       	ldd	r31, Z+3	; 0x03
    2fa2:	e0 2d       	mov	r30, r0
    2fa4:	6a e0       	ldi	r22, 0x0A	; 10
    2fa6:	ce 01       	movw	r24, r28
    2fa8:	19 95       	eicall
			break;
    2faa:	12 c0       	rjmp	.+36     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (clrscr):                      // Send a clear-screen code
			clear_screen ();
    2fac:	e8 81       	ld	r30, Y
    2fae:	f9 81       	ldd	r31, Y+1	; 0x01
    2fb0:	02 84       	ldd	r0, Z+10	; 0x0a
    2fb2:	f3 85       	ldd	r31, Z+11	; 0x0b
    2fb4:	e0 2d       	mov	r30, r0
    2fb6:	ce 01       	movw	r24, r28
    2fb8:	19 95       	eicall
			break;
    2fba:	0a c0       	rjmp	.+20     	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (send_now):                    // Send whatever's in the send buffer
			transmit_now ();
    2fbc:	e8 81       	ld	r30, Y
    2fbe:	f9 81       	ldd	r31, Y+1	; 0x01
    2fc0:	00 84       	ldd	r0, Z+8	; 0x08
    2fc2:	f1 85       	ldd	r31, Z+9	; 0x09
    2fc4:	e0 2d       	mov	r30, r0
    2fc6:	ce 01       	movw	r24, r28
    2fc8:	19 95       	eicall
			break;
    2fca:	02 c0       	rjmp	.+4      	; 0x2fd0 <_ZN8emstreamlsE15ser_manipulator+0x86>
		case (_p_str):                      // The next string is in program memory
			pgm_string = true;
    2fcc:	81 e0       	ldi	r24, 0x01	; 1
    2fce:	8c 83       	std	Y+4, r24	; 0x04
		case (manip_set_precision):         // Set precision for printing floats
			break;
	};

	return (*this);
}
    2fd0:	ce 01       	movw	r24, r28
    2fd2:	df 91       	pop	r29
    2fd4:	cf 91       	pop	r28
    2fd6:	08 95       	ret

00002fd8 <_ZN8emstreamlsEj>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 16-bit number to be sent out
 */

emstream& emstream::operator<< (uint16_t num)
{
    2fd8:	ff 92       	push	r15
    2fda:	0f 93       	push	r16
    2fdc:	1f 93       	push	r17
    2fde:	cf 93       	push	r28
    2fe0:	df 93       	push	r29
    2fe2:	cd b7       	in	r28, 0x3d	; 61
    2fe4:	de b7       	in	r29, 0x3e	; 62
    2fe6:	61 97       	sbiw	r28, 0x11	; 17
    2fe8:	cd bf       	out	0x3d, r28	; 61
    2fea:	de bf       	out	0x3e, r29	; 62
    2fec:	8c 01       	movw	r16, r24
    2fee:	f6 2e       	mov	r15, r22
    2ff0:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    2ff2:	f8 01       	movw	r30, r16
    2ff4:	42 81       	ldd	r20, Z+2	; 0x02
    2ff6:	40 31       	cpi	r20, 0x10	; 16
    2ff8:	21 f0       	breq	.+8      	; 0x3002 <_ZN8emstreamlsEj+0x2a>
    2ffa:	48 30       	cpi	r20, 0x08	; 8
    2ffc:	11 f0       	breq	.+4      	; 0x3002 <_ZN8emstreamlsEj+0x2a>
    2ffe:	42 30       	cpi	r20, 0x02	; 2
    3000:	41 f4       	brne	.+16     	; 0x3012 <_ZN8emstreamlsEj+0x3a>
		{
			uint16_t whole;
			uint8_t bits[2];
		} parts;
		parts.whole = num;
		*this << parts.bits[1] << parts.bits[0];
    3002:	69 2f       	mov	r22, r25
    3004:	c8 01       	movw	r24, r16
    3006:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    300a:	6f 2d       	mov	r22, r15
    300c:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    3010:	0d c0       	rjmp	.+26     	; 0x302c <_ZN8emstreamlsEj+0x54>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    3012:	50 e0       	ldi	r21, 0x00	; 0
    3014:	be 01       	movw	r22, r28
    3016:	6f 5f       	subi	r22, 0xFF	; 255
    3018:	7f 4f       	sbci	r23, 0xFF	; 255
    301a:	8f 2d       	mov	r24, r15
    301c:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <utoa>
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
		puts (out_str);
    3020:	be 01       	movw	r22, r28
    3022:	6f 5f       	subi	r22, 0xFF	; 255
    3024:	7f 4f       	sbci	r23, 0xFF	; 255
    3026:	c8 01       	movw	r24, r16
    3028:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    302c:	c8 01       	movw	r24, r16
    302e:	61 96       	adiw	r28, 0x11	; 17
    3030:	cd bf       	out	0x3d, r28	; 61
    3032:	de bf       	out	0x3e, r29	; 62
    3034:	df 91       	pop	r29
    3036:	cf 91       	pop	r28
    3038:	1f 91       	pop	r17
    303a:	0f 91       	pop	r16
    303c:	ff 90       	pop	r15
    303e:	08 95       	ret

00003040 <_ZN8emstreamlsEm>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 32-bit number to be sent out
 */

emstream& emstream::operator<< (uint32_t num)
{
    3040:	df 92       	push	r13
    3042:	ef 92       	push	r14
    3044:	ff 92       	push	r15
    3046:	0f 93       	push	r16
    3048:	1f 93       	push	r17
    304a:	cf 93       	push	r28
    304c:	df 93       	push	r29
    304e:	cd b7       	in	r28, 0x3d	; 61
    3050:	de b7       	in	r29, 0x3e	; 62
    3052:	a1 97       	sbiw	r28, 0x21	; 33
    3054:	cd bf       	out	0x3d, r28	; 61
    3056:	de bf       	out	0x3e, r29	; 62
    3058:	8c 01       	movw	r16, r24
    305a:	d4 2e       	mov	r13, r20
    305c:	e5 2e       	mov	r14, r21
    305e:	f6 2e       	mov	r15, r22
    3060:	97 2f       	mov	r25, r23
	if (base == 16 || base == 8 || base == 2)
    3062:	f8 01       	movw	r30, r16
    3064:	22 81       	ldd	r18, Z+2	; 0x02
    3066:	20 31       	cpi	r18, 0x10	; 16
    3068:	21 f0       	breq	.+8      	; 0x3072 <_ZN8emstreamlsEm+0x32>
    306a:	28 30       	cpi	r18, 0x08	; 8
    306c:	11 f0       	breq	.+4      	; 0x3072 <_ZN8emstreamlsEm+0x32>
    306e:	22 30       	cpi	r18, 0x02	; 2
    3070:	71 f4       	brne	.+28     	; 0x308e <_ZN8emstreamlsEm+0x4e>
		{
			uint32_t whole;
			uint8_t bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    3072:	69 2f       	mov	r22, r25
    3074:	c8 01       	movw	r24, r16
    3076:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    307a:	6f 2d       	mov	r22, r15
    307c:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    3080:	6e 2d       	mov	r22, r14
    3082:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    3086:	6d 2d       	mov	r22, r13
    3088:	0e 94 62 18 	call	0x30c4	; 0x30c4 <_ZN8emstreamlsEh>
    308c:	0f c0       	rjmp	.+30     	; 0x30ac <_ZN8emstreamlsEm+0x6c>
extern __inline__ __ATTR_GNU_INLINE__
char *ultoa (unsigned long __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__ultoa (unsigned long, char *, int);
	return __ultoa (__val, __s, __radix);
    308e:	30 e0       	ldi	r19, 0x00	; 0
    3090:	ae 01       	movw	r20, r28
    3092:	4f 5f       	subi	r20, 0xFF	; 255
    3094:	5f 4f       	sbci	r21, 0xFF	; 255
    3096:	6d 2d       	mov	r22, r13
    3098:	7e 2d       	mov	r23, r14
    309a:	8f 2d       	mov	r24, r15
    309c:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <ultoa>
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
		puts (out_str);
    30a0:	be 01       	movw	r22, r28
    30a2:	6f 5f       	subi	r22, 0xFF	; 255
    30a4:	7f 4f       	sbci	r23, 0xFF	; 255
    30a6:	c8 01       	movw	r24, r16
    30a8:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
	}

	return (*this);
}
    30ac:	c8 01       	movw	r24, r16
    30ae:	a1 96       	adiw	r28, 0x21	; 33
    30b0:	cd bf       	out	0x3d, r28	; 61
    30b2:	de bf       	out	0x3e, r29	; 62
    30b4:	df 91       	pop	r29
    30b6:	cf 91       	pop	r28
    30b8:	1f 91       	pop	r17
    30ba:	0f 91       	pop	r16
    30bc:	ff 90       	pop	r15
    30be:	ef 90       	pop	r14
    30c0:	df 90       	pop	r13
    30c2:	08 95       	ret

000030c4 <_ZN8emstreamlsEh>:
 *          reference is used to string printable items together with "<<" operators
 *  @param num The 8-bit number or character to be sent out
 */

emstream& emstream::operator<< (uint8_t num)
{
    30c4:	cf 92       	push	r12
    30c6:	df 92       	push	r13
    30c8:	ef 92       	push	r14
    30ca:	ff 92       	push	r15
    30cc:	0f 93       	push	r16
    30ce:	1f 93       	push	r17
    30d0:	cf 93       	push	r28
    30d2:	df 93       	push	r29
    30d4:	cd b7       	in	r28, 0x3d	; 61
    30d6:	de b7       	in	r29, 0x3e	; 62
    30d8:	29 97       	sbiw	r28, 0x09	; 9
    30da:	cd bf       	out	0x3d, r28	; 61
    30dc:	de bf       	out	0x3e, r29	; 62
    30de:	8c 01       	movw	r16, r24
    30e0:	e6 2e       	mov	r14, r22
	uint8_t temp_char;                      // Temporary storage for a nibble

	if (print_ascii)
    30e2:	dc 01       	movw	r26, r24
    30e4:	13 96       	adiw	r26, 0x03	; 3
    30e6:	8c 91       	ld	r24, X
    30e8:	13 97       	sbiw	r26, 0x03	; 3
    30ea:	88 23       	and	r24, r24
    30ec:	41 f0       	breq	.+16     	; 0x30fe <_ZN8emstreamlsEh+0x3a>
	{
		putchar (num);
    30ee:	ed 91       	ld	r30, X+
    30f0:	fc 91       	ld	r31, X
    30f2:	02 80       	ldd	r0, Z+2	; 0x02
    30f4:	f3 81       	ldd	r31, Z+3	; 0x03
    30f6:	e0 2d       	mov	r30, r0
    30f8:	c8 01       	movw	r24, r16
    30fa:	19 95       	eicall
    30fc:	56 c0       	rjmp	.+172    	; 0x31aa <_ZN8emstreamlsEh+0xe6>
	}
	else if (base == 2)
    30fe:	f8 01       	movw	r30, r16
    3100:	42 81       	ldd	r20, Z+2	; 0x02
    3102:	42 30       	cpi	r20, 0x02	; 2
    3104:	19 f5       	brne	.+70     	; 0x314c <_ZN8emstreamlsEh+0x88>
    3106:	68 94       	set
    3108:	cc 24       	eor	r12, r12
    310a:	c3 f8       	bld	r12, 3
    310c:	d1 2c       	mov	r13, r1
    310e:	68 94       	set
    3110:	ff 24       	eor	r15, r15
    3112:	f7 f8       	bld	r15, 7
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    3114:	8e 2d       	mov	r24, r14
    3116:	8f 21       	and	r24, r15
    3118:	51 f0       	breq	.+20     	; 0x312e <_ZN8emstreamlsEh+0x6a>
    311a:	d8 01       	movw	r26, r16
    311c:	ed 91       	ld	r30, X+
    311e:	fc 91       	ld	r31, X
    3120:	02 80       	ldd	r0, Z+2	; 0x02
    3122:	f3 81       	ldd	r31, Z+3	; 0x03
    3124:	e0 2d       	mov	r30, r0
    3126:	61 e3       	ldi	r22, 0x31	; 49
    3128:	c8 01       	movw	r24, r16
    312a:	19 95       	eicall
    312c:	09 c0       	rjmp	.+18     	; 0x3140 <_ZN8emstreamlsEh+0x7c>
			else             putchar ('0');
    312e:	d8 01       	movw	r26, r16
    3130:	ed 91       	ld	r30, X+
    3132:	fc 91       	ld	r31, X
    3134:	02 80       	ldd	r0, Z+2	; 0x02
    3136:	f3 81       	ldd	r31, Z+3	; 0x03
    3138:	e0 2d       	mov	r30, r0
    313a:	60 e3       	ldi	r22, 0x30	; 48
    313c:	c8 01       	movw	r24, r16
    313e:	19 95       	eicall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (uint8_t bmask = 0x80; bmask != 0; bmask >>= 1)
    3140:	f6 94       	lsr	r15
    3142:	b1 e0       	ldi	r27, 0x01	; 1
    3144:	cb 1a       	sub	r12, r27
    3146:	d1 08       	sbc	r13, r1
    3148:	29 f7       	brne	.-54     	; 0x3114 <_ZN8emstreamlsEh+0x50>
    314a:	2f c0       	rjmp	.+94     	; 0x31aa <_ZN8emstreamlsEh+0xe6>
		{
			if (num & bmask) putchar ('1');
			else             putchar ('0');
		}
	}
	else if (base == 16)
    314c:	40 31       	cpi	r20, 0x10	; 16
    314e:	f9 f4       	brne	.+62     	; 0x318e <_ZN8emstreamlsEh+0xca>
	{
		temp_char = (num >> 4) & 0x0F;
    3150:	62 95       	swap	r22
    3152:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3154:	01 90       	ld	r0, Z+
    3156:	f0 81       	ld	r31, Z
    3158:	e0 2d       	mov	r30, r0
    315a:	02 80       	ldd	r0, Z+2	; 0x02
    315c:	f3 81       	ldd	r31, Z+3	; 0x03
    315e:	e0 2d       	mov	r30, r0
    3160:	6a 30       	cpi	r22, 0x0A	; 10
    3162:	10 f0       	brcs	.+4      	; 0x3168 <_ZN8emstreamlsEh+0xa4>
    3164:	69 5c       	subi	r22, 0xC9	; 201
    3166:	01 c0       	rjmp	.+2      	; 0x316a <_ZN8emstreamlsEh+0xa6>
    3168:	60 5d       	subi	r22, 0xD0	; 208
    316a:	c8 01       	movw	r24, r16
    316c:	19 95       	eicall
		temp_char = num & 0x0F;
    316e:	6e 2d       	mov	r22, r14
    3170:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    3172:	d8 01       	movw	r26, r16
    3174:	ed 91       	ld	r30, X+
    3176:	fc 91       	ld	r31, X
    3178:	02 80       	ldd	r0, Z+2	; 0x02
    317a:	f3 81       	ldd	r31, Z+3	; 0x03
    317c:	e0 2d       	mov	r30, r0
    317e:	6a 30       	cpi	r22, 0x0A	; 10
    3180:	10 f0       	brcs	.+4      	; 0x3186 <_ZN8emstreamlsEh+0xc2>
    3182:	69 5c       	subi	r22, 0xC9	; 201
    3184:	01 c0       	rjmp	.+2      	; 0x3188 <_ZN8emstreamlsEh+0xc4>
    3186:	60 5d       	subi	r22, 0xD0	; 208
    3188:	c8 01       	movw	r24, r16
    318a:	19 95       	eicall
    318c:	0e c0       	rjmp	.+28     	; 0x31aa <_ZN8emstreamlsEh+0xe6>
extern __inline__ __ATTR_GNU_INLINE__
char *utoa (unsigned int __val, char *__s, int __radix)
{
    if (!__builtin_constant_p (__radix)) {
	extern char *__utoa (unsigned int, char *, int);
	return __utoa (__val, __s, __radix);
    318e:	50 e0       	ldi	r21, 0x00	; 0
    3190:	be 01       	movw	r22, r28
    3192:	6f 5f       	subi	r22, 0xFF	; 255
    3194:	7f 4f       	sbci	r23, 0xFF	; 255
    3196:	8e 2d       	mov	r24, r14
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	0e 94 29 1d 	call	0x3a52	; 0x3a52 <utoa>
	}
	else
	{
		char out_str[9];
		utoa ((uint16_t)num, out_str, base);
		puts (out_str);
    319e:	be 01       	movw	r22, r28
    31a0:	6f 5f       	subi	r22, 0xFF	; 255
    31a2:	7f 4f       	sbci	r23, 0xFF	; 255
    31a4:	c8 01       	movw	r24, r16
    31a6:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
	}
	return (*this);
}
    31aa:	c8 01       	movw	r24, r16
    31ac:	29 96       	adiw	r28, 0x09	; 9
    31ae:	cd bf       	out	0x3d, r28	; 61
    31b0:	de bf       	out	0x3e, r29	; 62
    31b2:	df 91       	pop	r29
    31b4:	cf 91       	pop	r28
    31b6:	1f 91       	pop	r17
    31b8:	0f 91       	pop	r16
    31ba:	ff 90       	pop	r15
    31bc:	ef 90       	pop	r14
    31be:	df 90       	pop	r13
    31c0:	cf 90       	pop	r12
    31c2:	08 95       	ret

000031c4 <_ZN5rs2327putcharEc>:
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
{
    31c4:	dc 01       	movw	r26, r24
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    31c6:	50 96       	adiw	r26, 0x10	; 16
    31c8:	ed 91       	ld	r30, X+
    31ca:	fc 91       	ld	r31, X
    31cc:	51 97       	sbiw	r26, 0x11	; 17
    31ce:	80 81       	ld	r24, Z
    31d0:	54 96       	adiw	r26, 0x14	; 20
    31d2:	4c 91       	ld	r20, X
    31d4:	54 97       	sbiw	r26, 0x14	; 20
    31d6:	84 23       	and	r24, r20
    31d8:	29 f0       	breq	.+10     	; 0x31e4 <_ZN5rs2327putcharEc+0x20>
    31da:	09 c0       	rjmp	.+18     	; 0x31ee <_ZN5rs2327putcharEc+0x2a>
    31dc:	21 50       	subi	r18, 0x01	; 1
    31de:	31 09       	sbc	r19, r1
	{
		if (count > UART_TX_TOUT)
    31e0:	19 f4       	brne	.+6      	; 0x31e8 <_ZN5rs2327putcharEc+0x24>
    31e2:	12 c0       	rjmp	.+36     	; 0x3208 <_ZN5rs2327putcharEc+0x44>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
    31e4:	21 e2       	ldi	r18, 0x21	; 33
    31e6:	3e e4       	ldi	r19, 0x4E	; 78
    31e8:	90 81       	ld	r25, Z
    31ea:	94 23       	and	r25, r20
    31ec:	b9 f3       	breq	.-18     	; 0x31dc <_ZN5rs2327putcharEc+0x18>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
    31ee:	90 81       	ld	r25, Z
    31f0:	56 96       	adiw	r26, 0x16	; 22
    31f2:	8c 91       	ld	r24, X
    31f4:	56 97       	sbiw	r26, 0x16	; 22
    31f6:	89 2b       	or	r24, r25
    31f8:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
    31fa:	1e 96       	adiw	r26, 0x0e	; 14
    31fc:	ed 91       	ld	r30, X+
    31fe:	fc 91       	ld	r31, X
    3200:	1f 97       	sbiw	r26, 0x0f	; 15
    3202:	60 83       	st	Z, r22
	return (true);
    3204:	81 e0       	ldi	r24, 0x01	; 1
    3206:	08 95       	ret
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (uint16_t count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
			return (false);
    3208:	80 e0       	ldi	r24, 0x00	; 0
	*p_USR |= mask_TXC;

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
	return (true);
}
    320a:	08 95       	ret

0000320c <_ZN5rs2327getcharEv>:
 *  check_for_char() to ensure that there's data available first. 
 *  @return The character which was found in the serial port receive buffer
 */

int16_t rs232::getchar (void)
{
    320c:	cf 93       	push	r28
    320e:	df 93       	push	r29
    3210:	fc 01       	movw	r30, r24
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	while (*p_rcv_read_index == *p_rcv_write_index);
    3212:	c1 8d       	ldd	r28, Z+25	; 0x19
    3214:	d2 8d       	ldd	r29, Z+26	; 0x1a
    3216:	28 81       	ld	r18, Y
    3218:	39 81       	ldd	r19, Y+1	; 0x01
    321a:	a3 8d       	ldd	r26, Z+27	; 0x1b
    321c:	b4 8d       	ldd	r27, Z+28	; 0x1c
    321e:	4d 91       	ld	r20, X+
    3220:	5c 91       	ld	r21, X
    3222:	24 17       	cp	r18, r20
    3224:	35 07       	cpc	r19, r21
    3226:	e9 f3       	breq	.-6      	; 0x3222 <_ZN5rs2327getcharEv+0x16>
	recv_char = (*p_rcv_buffer)[*p_rcv_read_index];
    3228:	a7 89       	ldd	r26, Z+23	; 0x17
    322a:	b0 8d       	ldd	r27, Z+24	; 0x18
    322c:	0d 90       	ld	r0, X+
    322e:	bc 91       	ld	r27, X
    3230:	a0 2d       	mov	r26, r0
    3232:	a2 0f       	add	r26, r18
    3234:	b3 1f       	adc	r27, r19
    3236:	8c 91       	ld	r24, X
	if (++(*p_rcv_read_index) >= RSINT_BUF_SIZE)
    3238:	2f 5f       	subi	r18, 0xFF	; 255
    323a:	3f 4f       	sbci	r19, 0xFF	; 255
    323c:	28 83       	st	Y, r18
    323e:	39 83       	std	Y+1, r19	; 0x01
    3240:	24 36       	cpi	r18, 0x64	; 100
    3242:	31 05       	cpc	r19, r1
    3244:	28 f0       	brcs	.+10     	; 0x3250 <_ZN5rs2327getcharEv+0x44>
		*p_rcv_read_index = 0;
    3246:	01 8c       	ldd	r0, Z+25	; 0x19
    3248:	f2 8d       	ldd	r31, Z+26	; 0x1a
    324a:	e0 2d       	mov	r30, r0
    324c:	10 82       	st	Z, r1
    324e:	11 82       	std	Z+1, r1	; 0x01

	return (recv_char);
}
    3250:	90 e0       	ldi	r25, 0x00	; 0
    3252:	df 91       	pop	r29
    3254:	cf 91       	pop	r28
    3256:	08 95       	ret

00003258 <_ZN5rs23214check_for_charEv>:
 *  caused an interrupt. 
 *  @return True for character available, false for no character available
 */

bool rs232::check_for_char (void)
{
    3258:	cf 93       	push	r28
    325a:	df 93       	push	r29
	return (*p_rcv_read_index != *p_rcv_write_index);
    325c:	ec 01       	movw	r28, r24
    325e:	a9 8d       	ldd	r26, Y+25	; 0x19
    3260:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3262:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3264:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3266:	81 e0       	ldi	r24, 0x01	; 1
    3268:	4d 91       	ld	r20, X+
    326a:	5c 91       	ld	r21, X
    326c:	20 81       	ld	r18, Z
    326e:	31 81       	ldd	r19, Z+1	; 0x01
    3270:	42 17       	cp	r20, r18
    3272:	53 07       	cpc	r21, r19
    3274:	09 f4       	brne	.+2      	; 0x3278 <_ZN5rs23214check_for_charEv+0x20>
    3276:	80 e0       	ldi	r24, 0x00	; 0
}
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
    327c:	08 95       	ret

0000327e <_ZN5rs23212clear_screenEv>:
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
{
	putchar (CLRSCR_STYLE);
    327e:	dc 01       	movw	r26, r24
    3280:	ed 91       	ld	r30, X+
    3282:	fc 91       	ld	r31, X
    3284:	02 80       	ldd	r0, Z+2	; 0x02
    3286:	f3 81       	ldd	r31, Z+3	; 0x03
    3288:	e0 2d       	mov	r30, r0
    328a:	6c e0       	ldi	r22, 0x0C	; 12
    328c:	19 95       	eicall
    328e:	08 95       	ret

00003290 <_ZN5rs232C1EjP12USART_struct>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param p_usart A pointer to the desired USART c-struct. The default is USARTC0. On an
 *                 XMGEGA choices are C0, C1, D0, D1, E0, E1, F0  
 */

rs232::rs232 (uint16_t baud_rate, USART_t* p_usart)
    3290:	ef 92       	push	r14
    3292:	ff 92       	push	r15
    3294:	0f 93       	push	r16
    3296:	1f 93       	push	r17
    3298:	cf 93       	push	r28
    329a:	df 93       	push	r29
    329c:	ec 01       	movw	r28, r24
    329e:	7b 01       	movw	r14, r22
    32a0:	8a 01       	movw	r16, r20
	: emstream (), base232 (baud_rate, p_usart)
    32a2:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <_ZN8emstreamC1Ev>
    32a6:	a8 01       	movw	r20, r16
    32a8:	b7 01       	movw	r22, r14
    32aa:	ce 01       	movw	r24, r28
    32ac:	08 96       	adiw	r24, 0x08	; 8
    32ae:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <_ZN7base232C1EjP12USART_struct>
    32b2:	8f e7       	ldi	r24, 0x7F	; 127
    32b4:	90 e2       	ldi	r25, 0x20	; 32
    32b6:	88 83       	st	Y, r24
    32b8:	99 83       	std	Y+1, r25	; 0x01
{
	if(p_usart == &USARTC0)
    32ba:	00 3a       	cpi	r16, 0xA0	; 160
    32bc:	88 e0       	ldi	r24, 0x08	; 8
    32be:	18 07       	cpc	r17, r24
    32c0:	69 f4       	brne	.+26     	; 0x32dc <_ZN5rs232C1EjP12USART_struct+0x4c>
	{
		p_rcv_buffer		= &rcvC0_buffer;
    32c2:	80 e7       	ldi	r24, 0x70	; 112
    32c4:	91 e3       	ldi	r25, 0x31	; 49
    32c6:	8f 8b       	std	Y+23, r24	; 0x17
    32c8:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC0_read_index;
    32ca:	86 e6       	ldi	r24, 0x66	; 102
    32cc:	91 e3       	ldi	r25, 0x31	; 49
    32ce:	89 8f       	std	Y+25, r24	; 0x19
    32d0:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC0_write_index;
    32d2:	8c e5       	ldi	r24, 0x5C	; 92
    32d4:	91 e3       	ldi	r25, 0x31	; 49
    32d6:	8b 8f       	std	Y+27, r24	; 0x1b
    32d8:	9c 8f       	std	Y+28, r25	; 0x1c
    32da:	42 c0       	rjmp	.+132    	; 0x3360 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#ifdef USARTC1
	else if(p_usart == &USARTC1)
    32dc:	00 3b       	cpi	r16, 0xB0	; 176
    32de:	e8 e0       	ldi	r30, 0x08	; 8
    32e0:	1e 07       	cpc	r17, r30
    32e2:	69 f4       	brne	.+26     	; 0x32fe <_ZN5rs232C1EjP12USART_struct+0x6e>
	{
		p_rcv_buffer		= &rcvC1_buffer;
    32e4:	8e e6       	ldi	r24, 0x6E	; 110
    32e6:	91 e3       	ldi	r25, 0x31	; 49
    32e8:	8f 8b       	std	Y+23, r24	; 0x17
    32ea:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvC1_read_index;
    32ec:	84 e6       	ldi	r24, 0x64	; 100
    32ee:	91 e3       	ldi	r25, 0x31	; 49
    32f0:	89 8f       	std	Y+25, r24	; 0x19
    32f2:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvC1_write_index;
    32f4:	8a e5       	ldi	r24, 0x5A	; 90
    32f6:	91 e3       	ldi	r25, 0x31	; 49
    32f8:	8b 8f       	std	Y+27, r24	; 0x1b
    32fa:	9c 8f       	std	Y+28, r25	; 0x1c
    32fc:	31 c0       	rjmp	.+98     	; 0x3360 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD0
	else if(p_usart == &USARTD0)
    32fe:	00 3a       	cpi	r16, 0xA0	; 160
    3300:	f9 e0       	ldi	r31, 0x09	; 9
    3302:	1f 07       	cpc	r17, r31
    3304:	69 f4       	brne	.+26     	; 0x3320 <_ZN5rs232C1EjP12USART_struct+0x90>
	{
		p_rcv_buffer		= &rcvD0_buffer;
    3306:	8c e6       	ldi	r24, 0x6C	; 108
    3308:	91 e3       	ldi	r25, 0x31	; 49
    330a:	8f 8b       	std	Y+23, r24	; 0x17
    330c:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD0_read_index;
    330e:	82 e6       	ldi	r24, 0x62	; 98
    3310:	91 e3       	ldi	r25, 0x31	; 49
    3312:	89 8f       	std	Y+25, r24	; 0x19
    3314:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD0_write_index;
    3316:	88 e5       	ldi	r24, 0x58	; 88
    3318:	91 e3       	ldi	r25, 0x31	; 49
    331a:	8b 8f       	std	Y+27, r24	; 0x1b
    331c:	9c 8f       	std	Y+28, r25	; 0x1c
    331e:	20 c0       	rjmp	.+64     	; 0x3360 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTD1
	else if(p_usart == &USARTD1)
    3320:	00 3b       	cpi	r16, 0xB0	; 176
    3322:	89 e0       	ldi	r24, 0x09	; 9
    3324:	18 07       	cpc	r17, r24
    3326:	69 f4       	brne	.+26     	; 0x3342 <_ZN5rs232C1EjP12USART_struct+0xb2>
	{
		p_rcv_buffer		= &rcvD1_buffer;
    3328:	8a e6       	ldi	r24, 0x6A	; 106
    332a:	91 e3       	ldi	r25, 0x31	; 49
    332c:	8f 8b       	std	Y+23, r24	; 0x17
    332e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvD1_read_index;
    3330:	80 e6       	ldi	r24, 0x60	; 96
    3332:	91 e3       	ldi	r25, 0x31	; 49
    3334:	89 8f       	std	Y+25, r24	; 0x19
    3336:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvD1_write_index;
    3338:	86 e5       	ldi	r24, 0x56	; 86
    333a:	91 e3       	ldi	r25, 0x31	; 49
    333c:	8b 8f       	std	Y+27, r24	; 0x1b
    333e:	9c 8f       	std	Y+28, r25	; 0x1c
    3340:	0f c0       	rjmp	.+30     	; 0x3360 <_ZN5rs232C1EjP12USART_struct+0xd0>
	}
#endif
#ifdef USARTE0
	else if(p_usart == &USARTE0)
    3342:	00 3a       	cpi	r16, 0xA0	; 160
    3344:	1a 40       	sbci	r17, 0x0A	; 10
    3346:	61 f4       	brne	.+24     	; 0x3360 <_ZN5rs232C1EjP12USART_struct+0xd0>
	{
		p_rcv_buffer		= &rcvE0_buffer;
    3348:	88 e6       	ldi	r24, 0x68	; 104
    334a:	91 e3       	ldi	r25, 0x31	; 49
    334c:	8f 8b       	std	Y+23, r24	; 0x17
    334e:	98 8f       	std	Y+24, r25	; 0x18
		p_rcv_read_index	= &rcvE0_read_index;
    3350:	8e e5       	ldi	r24, 0x5E	; 94
    3352:	91 e3       	ldi	r25, 0x31	; 49
    3354:	89 8f       	std	Y+25, r24	; 0x19
    3356:	9a 8f       	std	Y+26, r25	; 0x1a
		p_rcv_write_index	= &rcvE0_write_index;
    3358:	84 e5       	ldi	r24, 0x54	; 84
    335a:	91 e3       	ldi	r25, 0x31	; 49
    335c:	8b 8f       	std	Y+27, r24	; 0x1b
    335e:	9c 8f       	std	Y+28, r25	; 0x1c
#endif
	else
	{
	}
	
	*p_rcv_buffer = new uint8_t[RSINT_BUF_SIZE];
    3360:	0f 89       	ldd	r16, Y+23	; 0x17
    3362:	18 8d       	ldd	r17, Y+24	; 0x18
    3364:	84 e6       	ldi	r24, 0x64	; 100
    3366:	90 e0       	ldi	r25, 0x00	; 0
    3368:	0e 94 bd 16 	call	0x2d7a	; 0x2d7a <_Znaj>
    336c:	f8 01       	movw	r30, r16
    336e:	80 83       	st	Z, r24
    3370:	91 83       	std	Z+1, r25	; 0x01
	*p_rcv_read_index = 0;
    3372:	e9 8d       	ldd	r30, Y+25	; 0x19
    3374:	fa 8d       	ldd	r31, Y+26	; 0x1a
    3376:	10 82       	st	Z, r1
    3378:	11 82       	std	Z+1, r1	; 0x01
	*p_rcv_write_index = 0;
    337a:	eb 8d       	ldd	r30, Y+27	; 0x1b
    337c:	fc 8d       	ldd	r31, Y+28	; 0x1c
    337e:	10 82       	st	Z, r1
    3380:	11 82       	std	Z+1, r1	; 0x01
}
    3382:	df 91       	pop	r29
    3384:	cf 91       	pop	r28
    3386:	1f 91       	pop	r17
    3388:	0f 91       	pop	r16
    338a:	ff 90       	pop	r15
    338c:	ef 90       	pop	r14
    338e:	08 95       	ret

00003390 <__vector_25>:
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

#ifdef USARTC0_RXC_vect
ISR (USARTC0_RXC_vect)
{
    3390:	1f 92       	push	r1
    3392:	0f 92       	push	r0
    3394:	0f b6       	in	r0, 0x3f	; 63
    3396:	0f 92       	push	r0
    3398:	11 24       	eor	r1, r1
    339a:	08 b6       	in	r0, 0x38	; 56
    339c:	0f 92       	push	r0
    339e:	18 be       	out	0x38, r1	; 56
    33a0:	0b b6       	in	r0, 0x3b	; 59
    33a2:	0f 92       	push	r0
    33a4:	1b be       	out	0x3b, r1	; 59
    33a6:	2f 93       	push	r18
    33a8:	3f 93       	push	r19
    33aa:	8f 93       	push	r24
    33ac:	9f 93       	push	r25
    33ae:	ef 93       	push	r30
    33b0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;
    33b2:	20 91 a0 08 	lds	r18, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    33b6:	e0 91 70 31 	lds	r30, 0x3170	; 0x803170 <rcvC0_buffer>
    33ba:	f0 91 71 31 	lds	r31, 0x3171	; 0x803171 <rcvC0_buffer+0x1>
    33be:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC0_write_index>
    33c2:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC0_write_index+0x1>
    33c6:	e8 0f       	add	r30, r24
    33c8:	f9 1f       	adc	r31, r25
    33ca:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
    33cc:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC0_write_index>
    33d0:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC0_write_index+0x1>
    33d4:	01 96       	adiw	r24, 0x01	; 1
    33d6:	84 36       	cpi	r24, 0x64	; 100
    33d8:	91 05       	cpc	r25, r1
    33da:	60 f4       	brcc	.+24     	; 0x33f4 <__vector_25+0x64>
    33dc:	80 93 5c 31 	sts	0x315C, r24	; 0x80315c <rcvC0_write_index>
    33e0:	90 93 5d 31 	sts	0x315D, r25	; 0x80315d <rcvC0_write_index+0x1>
		rcvC0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    33e4:	20 91 66 31 	lds	r18, 0x3166	; 0x803166 <rcvC0_read_index>
    33e8:	30 91 67 31 	lds	r19, 0x3167	; 0x803167 <rcvC0_read_index+0x1>
    33ec:	82 17       	cp	r24, r18
    33ee:	93 07       	cpc	r25, r19
    33f0:	f1 f4       	brne	.+60     	; 0x342e <__vector_25+0x9e>
    33f2:	0c c0       	rjmp	.+24     	; 0x340c <__vector_25+0x7c>

	rcvC0_buffer[rcvC0_write_index] = USARTC0.DATA;

	// Increment the write pointer
	if (++rcvC0_write_index >= RSINT_BUF_SIZE)
		rcvC0_write_index = 0;
    33f4:	10 92 5c 31 	sts	0x315C, r1	; 0x80315c <rcvC0_write_index>
    33f8:	10 92 5d 31 	sts	0x315D, r1	; 0x80315d <rcvC0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
    33fc:	80 91 66 31 	lds	r24, 0x3166	; 0x803166 <rcvC0_read_index>
    3400:	90 91 67 31 	lds	r25, 0x3167	; 0x803167 <rcvC0_read_index+0x1>
    3404:	18 16       	cp	r1, r24
    3406:	19 06       	cpc	r1, r25
    3408:	91 f4       	brne	.+36     	; 0x342e <__vector_25+0x9e>
    340a:	0e c0       	rjmp	.+28     	; 0x3428 <__vector_25+0x98>
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    340c:	01 96       	adiw	r24, 0x01	; 1
    340e:	84 36       	cpi	r24, 0x64	; 100
    3410:	91 05       	cpc	r25, r1
    3412:	28 f4       	brcc	.+10     	; 0x341e <__vector_25+0x8e>
    3414:	80 93 66 31 	sts	0x3166, r24	; 0x803166 <rcvC0_read_index>
    3418:	90 93 67 31 	sts	0x3167, r25	; 0x803167 <rcvC0_read_index+0x1>
    341c:	08 c0       	rjmp	.+16     	; 0x342e <__vector_25+0x9e>
			rcvC0_read_index = 0;
    341e:	10 92 66 31 	sts	0x3166, r1	; 0x803166 <rcvC0_read_index>
    3422:	10 92 67 31 	sts	0x3167, r1	; 0x803167 <rcvC0_read_index+0x1>
}
    3426:	03 c0       	rjmp	.+6      	; 0x342e <__vector_25+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC0_write_index == rcvC0_read_index)
		if (++rcvC0_read_index >= RSINT_BUF_SIZE)
    3428:	81 e0       	ldi	r24, 0x01	; 1
    342a:	90 e0       	ldi	r25, 0x00	; 0
    342c:	f3 cf       	rjmp	.-26     	; 0x3414 <__vector_25+0x84>
			rcvC0_read_index = 0;
}
    342e:	ff 91       	pop	r31
    3430:	ef 91       	pop	r30
    3432:	9f 91       	pop	r25
    3434:	8f 91       	pop	r24
    3436:	3f 91       	pop	r19
    3438:	2f 91       	pop	r18
    343a:	0f 90       	pop	r0
    343c:	0b be       	out	0x3b, r0	; 59
    343e:	0f 90       	pop	r0
    3440:	08 be       	out	0x38, r0	; 56
    3442:	0f 90       	pop	r0
    3444:	0f be       	out	0x3f, r0	; 63
    3446:	0f 90       	pop	r0
    3448:	1f 90       	pop	r1
    344a:	18 95       	reti

0000344c <__vector_28>:
#endif

#ifdef USARTC1_RXC_vect
ISR (USARTC1_RXC_vect)
{
    344c:	1f 92       	push	r1
    344e:	0f 92       	push	r0
    3450:	0f b6       	in	r0, 0x3f	; 63
    3452:	0f 92       	push	r0
    3454:	11 24       	eor	r1, r1
    3456:	08 b6       	in	r0, 0x38	; 56
    3458:	0f 92       	push	r0
    345a:	18 be       	out	0x38, r1	; 56
    345c:	0b b6       	in	r0, 0x3b	; 59
    345e:	0f 92       	push	r0
    3460:	1b be       	out	0x3b, r1	; 59
    3462:	2f 93       	push	r18
    3464:	3f 93       	push	r19
    3466:	8f 93       	push	r24
    3468:	9f 93       	push	r25
    346a:	ef 93       	push	r30
    346c:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;
    346e:	20 91 b0 08 	lds	r18, 0x08B0	; 0x8008b0 <__TEXT_REGION_LENGTH__+0x7008b0>
    3472:	e0 91 6e 31 	lds	r30, 0x316E	; 0x80316e <rcvC1_buffer>
    3476:	f0 91 6f 31 	lds	r31, 0x316F	; 0x80316f <rcvC1_buffer+0x1>
    347a:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvC1_write_index>
    347e:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvC1_write_index+0x1>
    3482:	e8 0f       	add	r30, r24
    3484:	f9 1f       	adc	r31, r25
    3486:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
    3488:	80 91 5a 31 	lds	r24, 0x315A	; 0x80315a <rcvC1_write_index>
    348c:	90 91 5b 31 	lds	r25, 0x315B	; 0x80315b <rcvC1_write_index+0x1>
    3490:	01 96       	adiw	r24, 0x01	; 1
    3492:	84 36       	cpi	r24, 0x64	; 100
    3494:	91 05       	cpc	r25, r1
    3496:	60 f4       	brcc	.+24     	; 0x34b0 <__vector_28+0x64>
    3498:	80 93 5a 31 	sts	0x315A, r24	; 0x80315a <rcvC1_write_index>
    349c:	90 93 5b 31 	sts	0x315B, r25	; 0x80315b <rcvC1_write_index+0x1>
	rcvC1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    34a0:	20 91 64 31 	lds	r18, 0x3164	; 0x803164 <rcvC1_read_index>
    34a4:	30 91 65 31 	lds	r19, 0x3165	; 0x803165 <rcvC1_read_index+0x1>
    34a8:	82 17       	cp	r24, r18
    34aa:	93 07       	cpc	r25, r19
    34ac:	f1 f4       	brne	.+60     	; 0x34ea <__vector_28+0x9e>
    34ae:	0c c0       	rjmp	.+24     	; 0x34c8 <__vector_28+0x7c>

	rcvC1_buffer[rcvC1_write_index] = USARTC1.DATA;

	// Increment the write pointer
	if (++rcvC1_write_index >= RSINT_BUF_SIZE)
	rcvC1_write_index = 0;
    34b0:	10 92 5a 31 	sts	0x315A, r1	; 0x80315a <rcvC1_write_index>
    34b4:	10 92 5b 31 	sts	0x315B, r1	; 0x80315b <rcvC1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
    34b8:	80 91 64 31 	lds	r24, 0x3164	; 0x803164 <rcvC1_read_index>
    34bc:	90 91 65 31 	lds	r25, 0x3165	; 0x803165 <rcvC1_read_index+0x1>
    34c0:	18 16       	cp	r1, r24
    34c2:	19 06       	cpc	r1, r25
    34c4:	91 f4       	brne	.+36     	; 0x34ea <__vector_28+0x9e>
    34c6:	0e c0       	rjmp	.+28     	; 0x34e4 <__vector_28+0x98>
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    34c8:	01 96       	adiw	r24, 0x01	; 1
    34ca:	84 36       	cpi	r24, 0x64	; 100
    34cc:	91 05       	cpc	r25, r1
    34ce:	28 f4       	brcc	.+10     	; 0x34da <__vector_28+0x8e>
    34d0:	80 93 64 31 	sts	0x3164, r24	; 0x803164 <rcvC1_read_index>
    34d4:	90 93 65 31 	sts	0x3165, r25	; 0x803165 <rcvC1_read_index+0x1>
    34d8:	08 c0       	rjmp	.+16     	; 0x34ea <__vector_28+0x9e>
	rcvC1_read_index = 0;
    34da:	10 92 64 31 	sts	0x3164, r1	; 0x803164 <rcvC1_read_index>
    34de:	10 92 65 31 	sts	0x3165, r1	; 0x803165 <rcvC1_read_index+0x1>
}
    34e2:	03 c0       	rjmp	.+6      	; 0x34ea <__vector_28+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvC1_write_index == rcvC1_read_index)
	if (++rcvC1_read_index >= RSINT_BUF_SIZE)
    34e4:	81 e0       	ldi	r24, 0x01	; 1
    34e6:	90 e0       	ldi	r25, 0x00	; 0
    34e8:	f3 cf       	rjmp	.-26     	; 0x34d0 <__vector_28+0x84>
	rcvC1_read_index = 0;
}
    34ea:	ff 91       	pop	r31
    34ec:	ef 91       	pop	r30
    34ee:	9f 91       	pop	r25
    34f0:	8f 91       	pop	r24
    34f2:	3f 91       	pop	r19
    34f4:	2f 91       	pop	r18
    34f6:	0f 90       	pop	r0
    34f8:	0b be       	out	0x3b, r0	; 59
    34fa:	0f 90       	pop	r0
    34fc:	08 be       	out	0x38, r0	; 56
    34fe:	0f 90       	pop	r0
    3500:	0f be       	out	0x3f, r0	; 63
    3502:	0f 90       	pop	r0
    3504:	1f 90       	pop	r1
    3506:	18 95       	reti

00003508 <__vector_88>:
#endif

#ifdef USARTD0_RXC_vect
ISR (USARTD0_RXC_vect)
{
    3508:	1f 92       	push	r1
    350a:	0f 92       	push	r0
    350c:	0f b6       	in	r0, 0x3f	; 63
    350e:	0f 92       	push	r0
    3510:	11 24       	eor	r1, r1
    3512:	08 b6       	in	r0, 0x38	; 56
    3514:	0f 92       	push	r0
    3516:	18 be       	out	0x38, r1	; 56
    3518:	0b b6       	in	r0, 0x3b	; 59
    351a:	0f 92       	push	r0
    351c:	1b be       	out	0x3b, r1	; 59
    351e:	2f 93       	push	r18
    3520:	3f 93       	push	r19
    3522:	8f 93       	push	r24
    3524:	9f 93       	push	r25
    3526:	ef 93       	push	r30
    3528:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;
    352a:	20 91 a0 09 	lds	r18, 0x09A0	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
    352e:	e0 91 6c 31 	lds	r30, 0x316C	; 0x80316c <rcvD0_buffer>
    3532:	f0 91 6d 31 	lds	r31, 0x316D	; 0x80316d <rcvD0_buffer+0x1>
    3536:	80 91 5c 31 	lds	r24, 0x315C	; 0x80315c <rcvC0_write_index>
    353a:	90 91 5d 31 	lds	r25, 0x315D	; 0x80315d <rcvC0_write_index+0x1>
    353e:	e8 0f       	add	r30, r24
    3540:	f9 1f       	adc	r31, r25
    3542:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
    3544:	80 91 58 31 	lds	r24, 0x3158	; 0x803158 <rcvD0_write_index>
    3548:	90 91 59 31 	lds	r25, 0x3159	; 0x803159 <rcvD0_write_index+0x1>
    354c:	01 96       	adiw	r24, 0x01	; 1
    354e:	84 36       	cpi	r24, 0x64	; 100
    3550:	91 05       	cpc	r25, r1
    3552:	60 f4       	brcc	.+24     	; 0x356c <__vector_88+0x64>
    3554:	80 93 58 31 	sts	0x3158, r24	; 0x803158 <rcvD0_write_index>
    3558:	90 93 59 31 	sts	0x3159, r25	; 0x803159 <rcvD0_write_index+0x1>
	rcvD0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    355c:	20 91 62 31 	lds	r18, 0x3162	; 0x803162 <rcvD0_read_index>
    3560:	30 91 63 31 	lds	r19, 0x3163	; 0x803163 <rcvD0_read_index+0x1>
    3564:	82 17       	cp	r24, r18
    3566:	93 07       	cpc	r25, r19
    3568:	f1 f4       	brne	.+60     	; 0x35a6 <__vector_88+0x9e>
    356a:	0c c0       	rjmp	.+24     	; 0x3584 <__vector_88+0x7c>

	rcvD0_buffer[rcvC0_write_index] = USARTD0.DATA;

	// Increment the write pointer
	if (++rcvD0_write_index >= RSINT_BUF_SIZE)
	rcvD0_write_index = 0;
    356c:	10 92 58 31 	sts	0x3158, r1	; 0x803158 <rcvD0_write_index>
    3570:	10 92 59 31 	sts	0x3159, r1	; 0x803159 <rcvD0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
    3574:	80 91 62 31 	lds	r24, 0x3162	; 0x803162 <rcvD0_read_index>
    3578:	90 91 63 31 	lds	r25, 0x3163	; 0x803163 <rcvD0_read_index+0x1>
    357c:	18 16       	cp	r1, r24
    357e:	19 06       	cpc	r1, r25
    3580:	91 f4       	brne	.+36     	; 0x35a6 <__vector_88+0x9e>
    3582:	0e c0       	rjmp	.+28     	; 0x35a0 <__vector_88+0x98>
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    3584:	01 96       	adiw	r24, 0x01	; 1
    3586:	84 36       	cpi	r24, 0x64	; 100
    3588:	91 05       	cpc	r25, r1
    358a:	28 f4       	brcc	.+10     	; 0x3596 <__vector_88+0x8e>
    358c:	80 93 62 31 	sts	0x3162, r24	; 0x803162 <rcvD0_read_index>
    3590:	90 93 63 31 	sts	0x3163, r25	; 0x803163 <rcvD0_read_index+0x1>
    3594:	08 c0       	rjmp	.+16     	; 0x35a6 <__vector_88+0x9e>
	rcvD0_read_index = 0;
    3596:	10 92 62 31 	sts	0x3162, r1	; 0x803162 <rcvD0_read_index>
    359a:	10 92 63 31 	sts	0x3163, r1	; 0x803163 <rcvD0_read_index+0x1>
}
    359e:	03 c0       	rjmp	.+6      	; 0x35a6 <__vector_88+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD0_write_index == rcvD0_read_index)
	if (++rcvD0_read_index >= RSINT_BUF_SIZE)
    35a0:	81 e0       	ldi	r24, 0x01	; 1
    35a2:	90 e0       	ldi	r25, 0x00	; 0
    35a4:	f3 cf       	rjmp	.-26     	; 0x358c <__vector_88+0x84>
	rcvD0_read_index = 0;
}
    35a6:	ff 91       	pop	r31
    35a8:	ef 91       	pop	r30
    35aa:	9f 91       	pop	r25
    35ac:	8f 91       	pop	r24
    35ae:	3f 91       	pop	r19
    35b0:	2f 91       	pop	r18
    35b2:	0f 90       	pop	r0
    35b4:	0b be       	out	0x3b, r0	; 59
    35b6:	0f 90       	pop	r0
    35b8:	08 be       	out	0x38, r0	; 56
    35ba:	0f 90       	pop	r0
    35bc:	0f be       	out	0x3f, r0	; 63
    35be:	0f 90       	pop	r0
    35c0:	1f 90       	pop	r1
    35c2:	18 95       	reti

000035c4 <__vector_91>:
#endif

#ifdef USARTD1_RXC_vect
ISR (USARTD1_RXC_vect)
{
    35c4:	1f 92       	push	r1
    35c6:	0f 92       	push	r0
    35c8:	0f b6       	in	r0, 0x3f	; 63
    35ca:	0f 92       	push	r0
    35cc:	11 24       	eor	r1, r1
    35ce:	08 b6       	in	r0, 0x38	; 56
    35d0:	0f 92       	push	r0
    35d2:	18 be       	out	0x38, r1	; 56
    35d4:	0b b6       	in	r0, 0x3b	; 59
    35d6:	0f 92       	push	r0
    35d8:	1b be       	out	0x3b, r1	; 59
    35da:	2f 93       	push	r18
    35dc:	3f 93       	push	r19
    35de:	8f 93       	push	r24
    35e0:	9f 93       	push	r25
    35e2:	ef 93       	push	r30
    35e4:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;
    35e6:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <__TEXT_REGION_LENGTH__+0x7009b0>
    35ea:	e0 91 6a 31 	lds	r30, 0x316A	; 0x80316a <rcvD1_buffer>
    35ee:	f0 91 6b 31 	lds	r31, 0x316B	; 0x80316b <rcvD1_buffer+0x1>
    35f2:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvD1_write_index>
    35f6:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvD1_write_index+0x1>
    35fa:	e8 0f       	add	r30, r24
    35fc:	f9 1f       	adc	r31, r25
    35fe:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
    3600:	80 91 56 31 	lds	r24, 0x3156	; 0x803156 <rcvD1_write_index>
    3604:	90 91 57 31 	lds	r25, 0x3157	; 0x803157 <rcvD1_write_index+0x1>
    3608:	01 96       	adiw	r24, 0x01	; 1
    360a:	84 36       	cpi	r24, 0x64	; 100
    360c:	91 05       	cpc	r25, r1
    360e:	60 f4       	brcc	.+24     	; 0x3628 <__vector_91+0x64>
    3610:	80 93 56 31 	sts	0x3156, r24	; 0x803156 <rcvD1_write_index>
    3614:	90 93 57 31 	sts	0x3157, r25	; 0x803157 <rcvD1_write_index+0x1>
	rcvD1_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3618:	20 91 60 31 	lds	r18, 0x3160	; 0x803160 <rcvD1_read_index>
    361c:	30 91 61 31 	lds	r19, 0x3161	; 0x803161 <rcvD1_read_index+0x1>
    3620:	82 17       	cp	r24, r18
    3622:	93 07       	cpc	r25, r19
    3624:	f1 f4       	brne	.+60     	; 0x3662 <__vector_91+0x9e>
    3626:	0c c0       	rjmp	.+24     	; 0x3640 <__vector_91+0x7c>

	rcvD1_buffer[rcvD1_write_index] = USARTD1.DATA;

	// Increment the write pointer
	if (++rcvD1_write_index >= RSINT_BUF_SIZE)
	rcvD1_write_index = 0;
    3628:	10 92 56 31 	sts	0x3156, r1	; 0x803156 <rcvD1_write_index>
    362c:	10 92 57 31 	sts	0x3157, r1	; 0x803157 <rcvD1_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
    3630:	80 91 60 31 	lds	r24, 0x3160	; 0x803160 <rcvD1_read_index>
    3634:	90 91 61 31 	lds	r25, 0x3161	; 0x803161 <rcvD1_read_index+0x1>
    3638:	18 16       	cp	r1, r24
    363a:	19 06       	cpc	r1, r25
    363c:	91 f4       	brne	.+36     	; 0x3662 <__vector_91+0x9e>
    363e:	0e c0       	rjmp	.+28     	; 0x365c <__vector_91+0x98>
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    3640:	01 96       	adiw	r24, 0x01	; 1
    3642:	84 36       	cpi	r24, 0x64	; 100
    3644:	91 05       	cpc	r25, r1
    3646:	28 f4       	brcc	.+10     	; 0x3652 <__vector_91+0x8e>
    3648:	80 93 60 31 	sts	0x3160, r24	; 0x803160 <rcvD1_read_index>
    364c:	90 93 61 31 	sts	0x3161, r25	; 0x803161 <rcvD1_read_index+0x1>
    3650:	08 c0       	rjmp	.+16     	; 0x3662 <__vector_91+0x9e>
	rcvD1_read_index = 0;
    3652:	10 92 60 31 	sts	0x3160, r1	; 0x803160 <rcvD1_read_index>
    3656:	10 92 61 31 	sts	0x3161, r1	; 0x803161 <rcvD1_read_index+0x1>
}
    365a:	03 c0       	rjmp	.+6      	; 0x3662 <__vector_91+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvD1_write_index == rcvD1_read_index)
	if (++rcvD1_read_index >= RSINT_BUF_SIZE)
    365c:	81 e0       	ldi	r24, 0x01	; 1
    365e:	90 e0       	ldi	r25, 0x00	; 0
    3660:	f3 cf       	rjmp	.-26     	; 0x3648 <__vector_91+0x84>
	rcvD1_read_index = 0;
}
    3662:	ff 91       	pop	r31
    3664:	ef 91       	pop	r30
    3666:	9f 91       	pop	r25
    3668:	8f 91       	pop	r24
    366a:	3f 91       	pop	r19
    366c:	2f 91       	pop	r18
    366e:	0f 90       	pop	r0
    3670:	0b be       	out	0x3b, r0	; 59
    3672:	0f 90       	pop	r0
    3674:	08 be       	out	0x38, r0	; 56
    3676:	0f 90       	pop	r0
    3678:	0f be       	out	0x3f, r0	; 63
    367a:	0f 90       	pop	r0
    367c:	1f 90       	pop	r1
    367e:	18 95       	reti

00003680 <__vector_58>:
#endif

#ifdef USARTE0_RXC_vect
ISR (USARTE0_RXC_vect)
{
    3680:	1f 92       	push	r1
    3682:	0f 92       	push	r0
    3684:	0f b6       	in	r0, 0x3f	; 63
    3686:	0f 92       	push	r0
    3688:	11 24       	eor	r1, r1
    368a:	08 b6       	in	r0, 0x38	; 56
    368c:	0f 92       	push	r0
    368e:	18 be       	out	0x38, r1	; 56
    3690:	0b b6       	in	r0, 0x3b	; 59
    3692:	0f 92       	push	r0
    3694:	1b be       	out	0x3b, r1	; 59
    3696:	2f 93       	push	r18
    3698:	3f 93       	push	r19
    369a:	8f 93       	push	r24
    369c:	9f 93       	push	r25
    369e:	ef 93       	push	r30
    36a0:	ff 93       	push	r31
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;
    36a2:	20 91 a0 0a 	lds	r18, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    36a6:	e0 91 68 31 	lds	r30, 0x3168	; 0x803168 <rcvE0_buffer>
    36aa:	f0 91 69 31 	lds	r31, 0x3169	; 0x803169 <rcvE0_buffer+0x1>
    36ae:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvE0_write_index>
    36b2:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvE0_write_index+0x1>
    36b6:	e8 0f       	add	r30, r24
    36b8:	f9 1f       	adc	r31, r25
    36ba:	20 83       	st	Z, r18

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
    36bc:	80 91 54 31 	lds	r24, 0x3154	; 0x803154 <rcvE0_write_index>
    36c0:	90 91 55 31 	lds	r25, 0x3155	; 0x803155 <rcvE0_write_index+0x1>
    36c4:	01 96       	adiw	r24, 0x01	; 1
    36c6:	84 36       	cpi	r24, 0x64	; 100
    36c8:	91 05       	cpc	r25, r1
    36ca:	60 f4       	brcc	.+24     	; 0x36e4 <__vector_58+0x64>
    36cc:	80 93 54 31 	sts	0x3154, r24	; 0x803154 <rcvE0_write_index>
    36d0:	90 93 55 31 	sts	0x3155, r25	; 0x803155 <rcvE0_write_index+0x1>
	rcvE0_write_index = 0;

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    36d4:	20 91 5e 31 	lds	r18, 0x315E	; 0x80315e <rcvE0_read_index>
    36d8:	30 91 5f 31 	lds	r19, 0x315F	; 0x80315f <rcvE0_read_index+0x1>
    36dc:	82 17       	cp	r24, r18
    36de:	93 07       	cpc	r25, r19
    36e0:	f1 f4       	brne	.+60     	; 0x371e <__vector_58+0x9e>
    36e2:	0c c0       	rjmp	.+24     	; 0x36fc <__vector_58+0x7c>

	rcvE0_buffer[rcvE0_write_index] = USARTE0.DATA;

	// Increment the write pointer
	if (++rcvE0_write_index >= RSINT_BUF_SIZE)
	rcvE0_write_index = 0;
    36e4:	10 92 54 31 	sts	0x3154, r1	; 0x803154 <rcvE0_write_index>
    36e8:	10 92 55 31 	sts	0x3155, r1	; 0x803155 <rcvE0_write_index+0x1>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
    36ec:	80 91 5e 31 	lds	r24, 0x315E	; 0x80315e <rcvE0_read_index>
    36f0:	90 91 5f 31 	lds	r25, 0x315F	; 0x80315f <rcvE0_read_index+0x1>
    36f4:	18 16       	cp	r1, r24
    36f6:	19 06       	cpc	r1, r25
    36f8:	91 f4       	brne	.+36     	; 0x371e <__vector_58+0x9e>
    36fa:	0e c0       	rjmp	.+28     	; 0x3718 <__vector_58+0x98>
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    36fc:	01 96       	adiw	r24, 0x01	; 1
    36fe:	84 36       	cpi	r24, 0x64	; 100
    3700:	91 05       	cpc	r25, r1
    3702:	28 f4       	brcc	.+10     	; 0x370e <__vector_58+0x8e>
    3704:	80 93 5e 31 	sts	0x315E, r24	; 0x80315e <rcvE0_read_index>
    3708:	90 93 5f 31 	sts	0x315F, r25	; 0x80315f <rcvE0_read_index+0x1>
    370c:	08 c0       	rjmp	.+16     	; 0x371e <__vector_58+0x9e>
	rcvE0_read_index = 0;
    370e:	10 92 5e 31 	sts	0x315E, r1	; 0x80315e <rcvE0_read_index>
    3712:	10 92 5f 31 	sts	0x315F, r1	; 0x80315f <rcvE0_read_index+0x1>
}
    3716:	03 c0       	rjmp	.+6      	; 0x371e <__vector_58+0x9e>

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcvE0_write_index == rcvE0_read_index)
	if (++rcvE0_read_index >= RSINT_BUF_SIZE)
    3718:	81 e0       	ldi	r24, 0x01	; 1
    371a:	90 e0       	ldi	r25, 0x00	; 0
    371c:	f3 cf       	rjmp	.-26     	; 0x3704 <__vector_58+0x84>
	rcvE0_read_index = 0;
}
    371e:	ff 91       	pop	r31
    3720:	ef 91       	pop	r30
    3722:	9f 91       	pop	r25
    3724:	8f 91       	pop	r24
    3726:	3f 91       	pop	r19
    3728:	2f 91       	pop	r18
    372a:	0f 90       	pop	r0
    372c:	0b be       	out	0x3b, r0	; 59
    372e:	0f 90       	pop	r0
    3730:	08 be       	out	0x38, r0	; 56
    3732:	0f 90       	pop	r0
    3734:	0f be       	out	0x3f, r0	; 63
    3736:	0f 90       	pop	r0
    3738:	1f 90       	pop	r1
    373a:	18 95       	reti

0000373c <_Z8CCPWritePVhh>:
 *  \param address A pointer to the address to write to.
 *  \param value   The value to put in to the register.
 */

void CCPWrite( volatile uint8_t * address, uint8_t value )
{
    373c:	0f 93       	push	r16
    373e:	cf 93       	push	r28
    3740:	df 93       	push	r29
    3742:	1f 92       	push	r1
    3744:	cd b7       	in	r28, 0x3d	; 61
    3746:	de b7       	in	r29, 0x3e	; 62
	#if defined __GNUC__
	uint8_t volatile saved_sreg = SREG;
    3748:	2f b7       	in	r18, 0x3f	; 63
    374a:	29 83       	std	Y+1, r18	; 0x01
	cli();
    374c:	f8 94       	cli
	volatile uint8_t * tmpAddr = address;
	#ifdef RAMPZ
	RAMPZ = 0;
    374e:	1b be       	out	0x3b, r1	; 59
	"out   %3, r16"	      "\n\t"
	"st     Z,  %1"       "\n\t"
	:
	: "r" (tmpAddr), "r" (value), "M" (0xD8), "i" (&CCP)
	: "r16", "r30", "r31"
	);
    3750:	fc 01       	movw	r30, r24
    3752:	08 ed       	ldi	r16, 0xD8	; 216
    3754:	04 bf       	out	0x34, r16	; 52
    3756:	60 83       	st	Z, r22

	SREG = saved_sreg;
    3758:	89 81       	ldd	r24, Y+1	; 0x01
    375a:	8f bf       	out	0x3f, r24	; 63
	#endif
}
    375c:	0f 90       	pop	r0
    375e:	df 91       	pop	r29
    3760:	cf 91       	pop	r28
    3762:	0f 91       	pop	r16
    3764:	08 95       	ret

00003766 <main>:
 *  reset.
 *  @return This is a real-time microcontroller program which doesn't return. Ever.
 */

int main (void)
{
    3766:	0f 93       	push	r16
    3768:	1f 93       	push	r17
    376a:	cf 93       	push	r28
    376c:	df 93       	push	r29
    376e:	cd b7       	in	r28, 0x3d	; 61
    3770:	de b7       	in	r29, 0x3e	; 62
    3772:	6d 97       	sbiw	r28, 0x1d	; 29
    3774:	cd bf       	out	0x3d, r28	; 61
    3776:	de bf       	out	0x3e, r29	; 62
	// Set up pins for LED output
	PORTD.DIRSET = PIN4_bm;									// set pin D4 as output LED0: turns on when power is on.
    3778:	e0 e6       	ldi	r30, 0x60	; 96
    377a:	f6 e0       	ldi	r31, 0x06	; 6
    377c:	80 e1       	ldi	r24, 0x10	; 16
    377e:	81 83       	std	Z+1, r24	; 0x01
	PORTD.OUTSET = PIN4_bm;									// set pin high, LED 1
    3780:	85 83       	std	Z+5, r24	; 0x05
	//PORTD.DIRSET = PIN5_bm;
	//PORTD.OUTSET = PIN5_bm;
	//PORTD.DIRSET = PIN6_bm;
	//PORTD.OUTSET = PIN6_bm;

	cli();
    3782:	f8 94       	cli
	// Configure the system clock
	{	
		// Enable the 32MHz internal RC oscillator and the external 32KHz oscillator
		OSC.CTRL |= (1 << OSC_RC32MEN_bp);
    3784:	e0 e5       	ldi	r30, 0x50	; 80
    3786:	f0 e0       	ldi	r31, 0x00	; 0
    3788:	80 81       	ld	r24, Z
    378a:	82 60       	ori	r24, 0x02	; 2
    378c:	80 83       	st	Z, r24
		do {} while((OSC.STATUS & (1 << OSC_RC32MRDY_bp)) != (1 << OSC_RC32MRDY_bp));
    378e:	81 81       	ldd	r24, Z+1	; 0x01
    3790:	81 ff       	sbrs	r24, 1
    3792:	fd cf       	rjmp	.-6      	; 0x378e <main+0x28>
		

		// Select the clock
		CCPWrite(&(CLK.CTRL),((CLK.CTRL & ~CLK_SCLKSEL_gm) | (1 << CLK_SCLKSEL0_bp)));
    3794:	60 91 40 00 	lds	r22, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
    3798:	68 7f       	andi	r22, 0xF8	; 248
    379a:	61 60       	ori	r22, 0x01	; 1
    379c:	80 e4       	ldi	r24, 0x40	; 64
    379e:	90 e0       	ldi	r25, 0x00	; 0
    37a0:	0e 94 9e 1b 	call	0x373c	; 0x373c <_Z8CCPWritePVhh>
		// Enable the RTC as an external oscillator
		//CLK.RTCCTRL = (CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm);
		// CCPWrite(&(CLK.RTCCTRL),(CLK_RTCSRC_TOSC_gc | CLK_RTCEN_bm));
		
		// Disable the 2MHz internal RC oscillator
		OSC.CTRL &= ~(1 << OSC_RC2MEN_bp);
    37a4:	e0 e5       	ldi	r30, 0x50	; 80
    37a6:	f0 e0       	ldi	r31, 0x00	; 0
    37a8:	80 81       	ld	r24, Z
    37aa:	8e 7f       	andi	r24, 0xFE	; 254
    37ac:	80 83       	st	Z, r24
	}
	
	// Disable the watchdog timer unless it's needed later. This is important because
	// sometimes the watchdog timer may have been left on...and it tends to stay on	 
	wdt_disable ();
    37ae:	9d ef       	ldi	r25, 0xFD	; 253
    37b0:	88 ed       	ldi	r24, 0xD8	; 216
    37b2:	08 b6       	in	r0, 0x38	; 56
    37b4:	18 be       	out	0x38, r1	; 56
    37b6:	84 bf       	out	0x34, r24	; 52
    37b8:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
    37bc:	08 be       	out	0x38, r0	; 56

	// Configure a serial port which can be used by a task to print debugging infor-
	// mation, or to allow user interaction, or for whatever use is appropriate.  The
	// serial port will be used by the user interface task after setup is complete and
	// the task scheduler has been started by the function vTaskStartScheduler()
	rs232 ser_dev(0, &USARTC1); // Create a serial device on USART C1, baud 115200
    37be:	40 eb       	ldi	r20, 0xB0	; 176
    37c0:	58 e0       	ldi	r21, 0x08	; 8
    37c2:	60 e0       	ldi	r22, 0x00	; 0
    37c4:	70 e0       	ldi	r23, 0x00	; 0
    37c6:	ce 01       	movw	r24, r28
    37c8:	01 96       	adiw	r24, 0x01	; 1
    37ca:	0e 94 48 19 	call	0x3290	; 0x3290 <_ZN5rs232C1EjP12USART_struct>
	ser_dev << clrscr << "FreeRTOS Xmega Testing Program" << endl << endl;
    37ce:	67 e0       	ldi	r22, 0x07	; 7
    37d0:	ce 01       	movw	r24, r28
    37d2:	01 96       	adiw	r24, 0x01	; 1
    37d4:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    37d8:	8c 01       	movw	r16, r24
		 *          reference is used to string (bad pun) printable items together with 
		 *          many "<<" operators
		 */
		emstream& operator<< (const char* p_string)
		{
			puts (p_string);
    37da:	6b e8       	ldi	r22, 0x8B	; 139
    37dc:	70 e2       	ldi	r23, 0x20	; 32
    37de:	0e 94 6e 17 	call	0x2edc	; 0x2edc <_ZN8emstream4putsEPKc>
    37e2:	66 e0       	ldi	r22, 0x06	; 6
    37e4:	c8 01       	movw	r24, r16
    37e6:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
    37ea:	66 e0       	ldi	r22, 0x06	; 6
    37ec:	0e 94 a5 17 	call	0x2f4a	; 0x2f4a <_ZN8emstreamlsE15ser_manipulator>
	
	// The user interface is at low priority; it could have been run in the idle task
	// but it is desired to exercise the RTOS more thoroughly in this test program
	new task_user ("UserInt", task_priority (0), 260, &ser_dev);
    37f0:	82 e1       	ldi	r24, 0x12	; 18
    37f2:	90 e0       	ldi	r25, 0x00	; 0
    37f4:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    37f8:	8e 01       	movw	r16, r28
    37fa:	0f 5f       	subi	r16, 0xFF	; 255
    37fc:	1f 4f       	sbci	r17, 0xFF	; 255
    37fe:	24 e0       	ldi	r18, 0x04	; 4
    3800:	31 e0       	ldi	r19, 0x01	; 1
    3802:	40 e0       	ldi	r20, 0x00	; 0
    3804:	6a ea       	ldi	r22, 0xAA	; 170
    3806:	70 e2       	ldi	r23, 0x20	; 32
    3808:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <_ZN9task_userC1EPKchjP8emstream>

	new task_limit_switch ("LeftSwitch", task_priority (6), 260, &ser_dev);
    380c:	82 e1       	ldi	r24, 0x12	; 18
    380e:	90 e0       	ldi	r25, 0x00	; 0
    3810:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    3814:	24 e0       	ldi	r18, 0x04	; 4
    3816:	31 e0       	ldi	r19, 0x01	; 1
    3818:	44 e0       	ldi	r20, 0x04	; 4
    381a:	62 eb       	ldi	r22, 0xB2	; 178
    381c:	70 e2       	ldi	r23, 0x20	; 32
    381e:	0e 94 23 03 	call	0x646	; 0x646 <_ZN17task_limit_switchC1EPKchjP8emstream>
	new task_limit_switch ("RightSwitch", task_priority (5), 260, &ser_dev);
    3822:	82 e1       	ldi	r24, 0x12	; 18
    3824:	90 e0       	ldi	r25, 0x00	; 0
    3826:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    382a:	24 e0       	ldi	r18, 0x04	; 4
    382c:	31 e0       	ldi	r19, 0x01	; 1
    382e:	44 e0       	ldi	r20, 0x04	; 4
    3830:	6d eb       	ldi	r22, 0xBD	; 189
    3832:	70 e2       	ldi	r23, 0x20	; 32
    3834:	0e 94 23 03 	call	0x646	; 0x646 <_ZN17task_limit_switchC1EPKchjP8emstream>
	new task_pendulum_encoder ("EncPen", task_priority (4), 260, &ser_dev);
    3838:	82 e1       	ldi	r24, 0x12	; 18
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    3840:	24 e0       	ldi	r18, 0x04	; 4
    3842:	31 e0       	ldi	r19, 0x01	; 1
    3844:	44 e0       	ldi	r20, 0x04	; 4
    3846:	69 ec       	ldi	r22, 0xC9	; 201
    3848:	70 e2       	ldi	r23, 0x20	; 32
    384a:	0e 94 19 04 	call	0x832	; 0x832 <_ZN21task_pendulum_encoderC1EPKchjP8emstream>
	new task_motor_encoder ("EncMtr", task_priority (3), 260, &ser_dev);
    384e:	82 e1       	ldi	r24, 0x12	; 18
    3850:	90 e0       	ldi	r25, 0x00	; 0
    3852:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    3856:	24 e0       	ldi	r18, 0x04	; 4
    3858:	31 e0       	ldi	r19, 0x01	; 1
    385a:	43 e0       	ldi	r20, 0x03	; 3
    385c:	60 ed       	ldi	r22, 0xD0	; 208
    385e:	70 e2       	ldi	r23, 0x20	; 32
    3860:	0e 94 c7 03 	call	0x78e	; 0x78e <_ZN18task_motor_encoderC1EPKchjP8emstream>
	new task_system_controller ("CtrlCalc", task_priority (2), 260, &ser_dev);
    3864:	82 e1       	ldi	r24, 0x12	; 18
    3866:	90 e0       	ldi	r25, 0x00	; 0
    3868:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    386c:	24 e0       	ldi	r18, 0x04	; 4
    386e:	31 e0       	ldi	r19, 0x01	; 1
    3870:	42 e0       	ldi	r20, 0x02	; 2
    3872:	67 ed       	ldi	r22, 0xD7	; 215
    3874:	70 e2       	ldi	r23, 0x20	; 32
    3876:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <_ZN22task_system_controllerC1EPKchjP8emstream>
	new task_motor_command ("MtrCmd", task_priority (1), 260, &ser_dev);
    387a:	82 e1       	ldi	r24, 0x12	; 18
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	0e 94 ba 16 	call	0x2d74	; 0x2d74 <_Znwj>
    3882:	24 e0       	ldi	r18, 0x04	; 4
    3884:	31 e0       	ldi	r19, 0x01	; 1
    3886:	41 e0       	ldi	r20, 0x01	; 1
    3888:	60 ee       	ldi	r22, 0xE0	; 224
    388a:	70 e2       	ldi	r23, 0x20	; 32
    388c:	0e 94 75 03 	call	0x6ea	; 0x6ea <_ZN18task_motor_commandC1EPKchjP8emstream>
	
	// Enable high level interrupts and global interrupts
	PMIC_CTRL = (1 << PMIC_HILVLEN_bp | 1 << PMIC_MEDLVLEN_bp | 1 << PMIC_LOLVLEN_bp);
    3890:	87 e0       	ldi	r24, 0x07	; 7
    3892:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    3896:	78 94       	sei
	
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
    3898:	0e 94 cc 0d 	call	0x1b98	; 0x1b98 <vTaskStartScheduler>
	
	return 0;
    389c:	80 e0       	ldi	r24, 0x00	; 0
    389e:	90 e0       	ldi	r25, 0x00	; 0
    38a0:	6d 96       	adiw	r28, 0x1d	; 29
    38a2:	cd bf       	out	0x3d, r28	; 61
    38a4:	de bf       	out	0x3e, r29	; 62
    38a6:	df 91       	pop	r29
    38a8:	cf 91       	pop	r28
    38aa:	1f 91       	pop	r17
    38ac:	0f 91       	pop	r16
    38ae:	08 95       	ret

000038b0 <_GLOBAL__sub_I_counter>:
    38b0:	0f 93       	push	r16
    38b2:	1f 93       	push	r17
#include "task_motor_encoder.h"
#include "task_system_controller.h"
#include "task_motor_command.h"

volatile int counter;
frt_text_queue print_ser_queue (32, NULL, 10);
    38b4:	0a e0       	ldi	r16, 0x0A	; 10
    38b6:	10 e0       	ldi	r17, 0x00	; 0
    38b8:	20 e0       	ldi	r18, 0x00	; 0
    38ba:	30 e0       	ldi	r19, 0x00	; 0
    38bc:	40 e0       	ldi	r20, 0x00	; 0
    38be:	50 e0       	ldi	r21, 0x00	; 0
    38c0:	60 e2       	ldi	r22, 0x20	; 32
    38c2:	70 e0       	ldi	r23, 0x00	; 0
    38c4:	82 e7       	ldi	r24, 0x72	; 114
    38c6:	91 e3       	ldi	r25, 0x31	; 49
    38c8:	0e 94 26 15 	call	0x2a4c	; 0x2a4c <_ZN14frt_text_queueC1EjP8emstreamm>
	// Here's where the RTOS scheduler is started up. It should never exit as long as
	// power is on and the microcontroller isn't rebooted
	vTaskStartScheduler ();
	
	return 0;
    38cc:	1f 91       	pop	r17
    38ce:	0f 91       	pop	r16
    38d0:	08 95       	ret

000038d2 <__mulsi3>:
    38d2:	db 01       	movw	r26, r22
    38d4:	8f 93       	push	r24
    38d6:	9f 93       	push	r25
    38d8:	0e 94 c3 1c 	call	0x3986	; 0x3986 <__muluhisi3>
    38dc:	bf 91       	pop	r27
    38de:	af 91       	pop	r26
    38e0:	a2 9f       	mul	r26, r18
    38e2:	80 0d       	add	r24, r0
    38e4:	91 1d       	adc	r25, r1
    38e6:	a3 9f       	mul	r26, r19
    38e8:	90 0d       	add	r25, r0
    38ea:	b2 9f       	mul	r27, r18
    38ec:	90 0d       	add	r25, r0
    38ee:	11 24       	eor	r1, r1
    38f0:	08 95       	ret

000038f2 <__udivmodsi4>:
    38f2:	a1 e2       	ldi	r26, 0x21	; 33
    38f4:	1a 2e       	mov	r1, r26
    38f6:	aa 1b       	sub	r26, r26
    38f8:	bb 1b       	sub	r27, r27
    38fa:	fd 01       	movw	r30, r26
    38fc:	0d c0       	rjmp	.+26     	; 0x3918 <__udivmodsi4_ep>

000038fe <__udivmodsi4_loop>:
    38fe:	aa 1f       	adc	r26, r26
    3900:	bb 1f       	adc	r27, r27
    3902:	ee 1f       	adc	r30, r30
    3904:	ff 1f       	adc	r31, r31
    3906:	a2 17       	cp	r26, r18
    3908:	b3 07       	cpc	r27, r19
    390a:	e4 07       	cpc	r30, r20
    390c:	f5 07       	cpc	r31, r21
    390e:	20 f0       	brcs	.+8      	; 0x3918 <__udivmodsi4_ep>
    3910:	a2 1b       	sub	r26, r18
    3912:	b3 0b       	sbc	r27, r19
    3914:	e4 0b       	sbc	r30, r20
    3916:	f5 0b       	sbc	r31, r21

00003918 <__udivmodsi4_ep>:
    3918:	66 1f       	adc	r22, r22
    391a:	77 1f       	adc	r23, r23
    391c:	88 1f       	adc	r24, r24
    391e:	99 1f       	adc	r25, r25
    3920:	1a 94       	dec	r1
    3922:	69 f7       	brne	.-38     	; 0x38fe <__udivmodsi4_loop>
    3924:	60 95       	com	r22
    3926:	70 95       	com	r23
    3928:	80 95       	com	r24
    392a:	90 95       	com	r25
    392c:	9b 01       	movw	r18, r22
    392e:	ac 01       	movw	r20, r24
    3930:	bd 01       	movw	r22, r26
    3932:	cf 01       	movw	r24, r30
    3934:	08 95       	ret

00003936 <__divmodsi4>:
    3936:	05 2e       	mov	r0, r21
    3938:	97 fb       	bst	r25, 7
    393a:	1e f4       	brtc	.+6      	; 0x3942 <__divmodsi4+0xc>
    393c:	00 94       	com	r0
    393e:	0e 94 b2 1c 	call	0x3964	; 0x3964 <__negsi2>
    3942:	57 fd       	sbrc	r21, 7
    3944:	07 d0       	rcall	.+14     	; 0x3954 <__divmodsi4_neg2>
    3946:	0e 94 79 1c 	call	0x38f2	; 0x38f2 <__udivmodsi4>
    394a:	07 fc       	sbrc	r0, 7
    394c:	03 d0       	rcall	.+6      	; 0x3954 <__divmodsi4_neg2>
    394e:	4e f4       	brtc	.+18     	; 0x3962 <__divmodsi4_exit>
    3950:	0c 94 b2 1c 	jmp	0x3964	; 0x3964 <__negsi2>

00003954 <__divmodsi4_neg2>:
    3954:	50 95       	com	r21
    3956:	40 95       	com	r20
    3958:	30 95       	com	r19
    395a:	21 95       	neg	r18
    395c:	3f 4f       	sbci	r19, 0xFF	; 255
    395e:	4f 4f       	sbci	r20, 0xFF	; 255
    3960:	5f 4f       	sbci	r21, 0xFF	; 255

00003962 <__divmodsi4_exit>:
    3962:	08 95       	ret

00003964 <__negsi2>:
    3964:	90 95       	com	r25
    3966:	80 95       	com	r24
    3968:	70 95       	com	r23
    396a:	61 95       	neg	r22
    396c:	7f 4f       	sbci	r23, 0xFF	; 255
    396e:	8f 4f       	sbci	r24, 0xFF	; 255
    3970:	9f 4f       	sbci	r25, 0xFF	; 255
    3972:	08 95       	ret

00003974 <__tablejump2__>:
    3974:	ee 0f       	add	r30, r30
    3976:	ff 1f       	adc	r31, r31
    3978:	88 1f       	adc	r24, r24
    397a:	8b bf       	out	0x3b, r24	; 59
    397c:	07 90       	elpm	r0, Z+
    397e:	f6 91       	elpm	r31, Z
    3980:	e0 2d       	mov	r30, r0
    3982:	1b be       	out	0x3b, r1	; 59
    3984:	19 94       	eijmp

00003986 <__muluhisi3>:
    3986:	0e 94 ce 1c 	call	0x399c	; 0x399c <__umulhisi3>
    398a:	a5 9f       	mul	r26, r21
    398c:	90 0d       	add	r25, r0
    398e:	b4 9f       	mul	r27, r20
    3990:	90 0d       	add	r25, r0
    3992:	a4 9f       	mul	r26, r20
    3994:	80 0d       	add	r24, r0
    3996:	91 1d       	adc	r25, r1
    3998:	11 24       	eor	r1, r1
    399a:	08 95       	ret

0000399c <__umulhisi3>:
    399c:	a2 9f       	mul	r26, r18
    399e:	b0 01       	movw	r22, r0
    39a0:	b3 9f       	mul	r27, r19
    39a2:	c0 01       	movw	r24, r0
    39a4:	a3 9f       	mul	r26, r19
    39a6:	70 0d       	add	r23, r0
    39a8:	81 1d       	adc	r24, r1
    39aa:	11 24       	eor	r1, r1
    39ac:	91 1d       	adc	r25, r1
    39ae:	b2 9f       	mul	r27, r18
    39b0:	70 0d       	add	r23, r0
    39b2:	81 1d       	adc	r24, r1
    39b4:	11 24       	eor	r1, r1
    39b6:	91 1d       	adc	r25, r1
    39b8:	08 95       	ret

000039ba <memcpy>:
    39ba:	fb 01       	movw	r30, r22
    39bc:	dc 01       	movw	r26, r24
    39be:	02 c0       	rjmp	.+4      	; 0x39c4 <memcpy+0xa>
    39c0:	01 90       	ld	r0, Z+
    39c2:	0d 92       	st	X+, r0
    39c4:	41 50       	subi	r20, 0x01	; 1
    39c6:	50 40       	sbci	r21, 0x00	; 0
    39c8:	d8 f7       	brcc	.-10     	; 0x39c0 <memcpy+0x6>
    39ca:	08 95       	ret

000039cc <memset>:
    39cc:	dc 01       	movw	r26, r24
    39ce:	01 c0       	rjmp	.+2      	; 0x39d2 <memset+0x6>
    39d0:	6d 93       	st	X+, r22
    39d2:	41 50       	subi	r20, 0x01	; 1
    39d4:	50 40       	sbci	r21, 0x00	; 0
    39d6:	e0 f7       	brcc	.-8      	; 0x39d0 <memset+0x4>
    39d8:	08 95       	ret

000039da <strncpy>:
    39da:	fb 01       	movw	r30, r22
    39dc:	dc 01       	movw	r26, r24
    39de:	41 50       	subi	r20, 0x01	; 1
    39e0:	50 40       	sbci	r21, 0x00	; 0
    39e2:	48 f0       	brcs	.+18     	; 0x39f6 <strncpy+0x1c>
    39e4:	01 90       	ld	r0, Z+
    39e6:	0d 92       	st	X+, r0
    39e8:	00 20       	and	r0, r0
    39ea:	c9 f7       	brne	.-14     	; 0x39de <strncpy+0x4>
    39ec:	01 c0       	rjmp	.+2      	; 0x39f0 <strncpy+0x16>
    39ee:	1d 92       	st	X+, r1
    39f0:	41 50       	subi	r20, 0x01	; 1
    39f2:	50 40       	sbci	r21, 0x00	; 0
    39f4:	e0 f7       	brcc	.-8      	; 0x39ee <strncpy+0x14>
    39f6:	08 95       	ret

000039f8 <ultoa>:
    39f8:	25 32       	cpi	r18, 0x25	; 37
    39fa:	31 05       	cpc	r19, r1
    39fc:	20 f4       	brcc	.+8      	; 0x3a06 <ultoa+0xe>
    39fe:	22 30       	cpi	r18, 0x02	; 2
    3a00:	10 f0       	brcs	.+4      	; 0x3a06 <ultoa+0xe>
    3a02:	0c 94 07 1d 	jmp	0x3a0e	; 0x3a0e <__ultoa_ncheck>
    3a06:	fa 01       	movw	r30, r20
    3a08:	10 82       	st	Z, r1
    3a0a:	ca 01       	movw	r24, r20
    3a0c:	08 95       	ret

00003a0e <__ultoa_ncheck>:
    3a0e:	bb 27       	eor	r27, r27

00003a10 <__ultoa_common>:
    3a10:	fa 01       	movw	r30, r20
    3a12:	a6 2f       	mov	r26, r22
    3a14:	62 17       	cp	r22, r18
    3a16:	71 05       	cpc	r23, r1
    3a18:	81 05       	cpc	r24, r1
    3a1a:	91 05       	cpc	r25, r1
    3a1c:	33 0b       	sbc	r19, r19
    3a1e:	30 fb       	bst	r19, 0
    3a20:	66 f0       	brts	.+24     	; 0x3a3a <__ultoa_common+0x2a>
    3a22:	aa 27       	eor	r26, r26
    3a24:	66 0f       	add	r22, r22
    3a26:	77 1f       	adc	r23, r23
    3a28:	88 1f       	adc	r24, r24
    3a2a:	99 1f       	adc	r25, r25
    3a2c:	aa 1f       	adc	r26, r26
    3a2e:	a2 17       	cp	r26, r18
    3a30:	10 f0       	brcs	.+4      	; 0x3a36 <__ultoa_common+0x26>
    3a32:	a2 1b       	sub	r26, r18
    3a34:	63 95       	inc	r22
    3a36:	38 50       	subi	r19, 0x08	; 8
    3a38:	a9 f7       	brne	.-22     	; 0x3a24 <__ultoa_common+0x14>
    3a3a:	a0 5d       	subi	r26, 0xD0	; 208
    3a3c:	aa 33       	cpi	r26, 0x3A	; 58
    3a3e:	08 f0       	brcs	.+2      	; 0x3a42 <__ultoa_common+0x32>
    3a40:	a9 5d       	subi	r26, 0xD9	; 217
    3a42:	a1 93       	st	Z+, r26
    3a44:	36 f7       	brtc	.-52     	; 0x3a12 <__ultoa_common+0x2>
    3a46:	b1 11       	cpse	r27, r1
    3a48:	b1 93       	st	Z+, r27
    3a4a:	10 82       	st	Z, r1
    3a4c:	ca 01       	movw	r24, r20
    3a4e:	0c 94 4e 1d 	jmp	0x3a9c	; 0x3a9c <strrev>

00003a52 <utoa>:
    3a52:	45 32       	cpi	r20, 0x25	; 37
    3a54:	51 05       	cpc	r21, r1
    3a56:	20 f4       	brcc	.+8      	; 0x3a60 <utoa+0xe>
    3a58:	42 30       	cpi	r20, 0x02	; 2
    3a5a:	10 f0       	brcs	.+4      	; 0x3a60 <utoa+0xe>
    3a5c:	0c 94 34 1d 	jmp	0x3a68	; 0x3a68 <__utoa_ncheck>
    3a60:	fb 01       	movw	r30, r22
    3a62:	10 82       	st	Z, r1
    3a64:	cb 01       	movw	r24, r22
    3a66:	08 95       	ret

00003a68 <__utoa_ncheck>:
    3a68:	bb 27       	eor	r27, r27

00003a6a <__utoa_common>:
    3a6a:	fb 01       	movw	r30, r22
    3a6c:	55 27       	eor	r21, r21
    3a6e:	aa 27       	eor	r26, r26
    3a70:	88 0f       	add	r24, r24
    3a72:	99 1f       	adc	r25, r25
    3a74:	aa 1f       	adc	r26, r26
    3a76:	a4 17       	cp	r26, r20
    3a78:	10 f0       	brcs	.+4      	; 0x3a7e <__utoa_common+0x14>
    3a7a:	a4 1b       	sub	r26, r20
    3a7c:	83 95       	inc	r24
    3a7e:	50 51       	subi	r21, 0x10	; 16
    3a80:	b9 f7       	brne	.-18     	; 0x3a70 <__utoa_common+0x6>
    3a82:	a0 5d       	subi	r26, 0xD0	; 208
    3a84:	aa 33       	cpi	r26, 0x3A	; 58
    3a86:	08 f0       	brcs	.+2      	; 0x3a8a <__utoa_common+0x20>
    3a88:	a9 5d       	subi	r26, 0xD9	; 217
    3a8a:	a1 93       	st	Z+, r26
    3a8c:	00 97       	sbiw	r24, 0x00	; 0
    3a8e:	79 f7       	brne	.-34     	; 0x3a6e <__utoa_common+0x4>
    3a90:	b1 11       	cpse	r27, r1
    3a92:	b1 93       	st	Z+, r27
    3a94:	11 92       	st	Z+, r1
    3a96:	cb 01       	movw	r24, r22
    3a98:	0c 94 4e 1d 	jmp	0x3a9c	; 0x3a9c <strrev>

00003a9c <strrev>:
    3a9c:	dc 01       	movw	r26, r24
    3a9e:	fc 01       	movw	r30, r24
    3aa0:	67 2f       	mov	r22, r23
    3aa2:	71 91       	ld	r23, Z+
    3aa4:	77 23       	and	r23, r23
    3aa6:	e1 f7       	brne	.-8      	; 0x3aa0 <strrev+0x4>
    3aa8:	32 97       	sbiw	r30, 0x02	; 2
    3aaa:	04 c0       	rjmp	.+8      	; 0x3ab4 <strrev+0x18>
    3aac:	7c 91       	ld	r23, X
    3aae:	6d 93       	st	X+, r22
    3ab0:	70 83       	st	Z, r23
    3ab2:	62 91       	ld	r22, -Z
    3ab4:	ae 17       	cp	r26, r30
    3ab6:	bf 07       	cpc	r27, r31
    3ab8:	c8 f3       	brcs	.-14     	; 0x3aac <strrev+0x10>
    3aba:	08 95       	ret

00003abc <_exit>:
    3abc:	f8 94       	cli

00003abe <__stop_program>:
    3abe:	ff cf       	rjmp	.-2      	; 0x3abe <__stop_program>
